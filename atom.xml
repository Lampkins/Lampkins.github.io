<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>博客</title>
  
  <subtitle>Creator by ❤️</subtitle>
  <link href="http://lampkins.gitee.io/atom.xml" rel="self"/>
  
  <link href="http://lampkins.gitee.io/"/>
  <updated>2021-09-18T01:45:07.700Z</updated>
  <id>http://lampkins.gitee.io/</id>
  
  <author>
    <name>Lampkins</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>logtail采集配置</title>
    <link href="http://lampkins.gitee.io/2021/08/03/logtail%E9%87%87%E9%9B%86%E9%85%8D%E7%BD%AE/"/>
    <id>http://lampkins.gitee.io/2021/08/03/logtail%E9%87%87%E9%9B%86%E9%85%8D%E7%BD%AE/</id>
    <published>2021-08-03T14:46:57.000Z</published>
    <updated>2021-09-18T01:45:07.700Z</updated>
    
    <content type="html"><![CDATA[<h2 id="%E4%B8%80.%20%E5%AE%89%E8%A3%85Logtail"><a class="header-anchor" href="#%E4%B8%80.%20%E5%AE%89%E8%A3%85Logtail">¶</a> 一. 安装Logtail</h2><ol><li>下载Logtail安装脚本</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://logtail-release-cn-hangzhou.oss-cn-hangzhou.aliyuncs.com/linux64/logtail.sh -O logtail.sh;chmod 755 logtail.sh</span><br></pre></td></tr></table></figure><ol start="2"><li>使用auto参数安装logtail</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./logtail.sh install auto</span><br></pre></td></tr></table></figure><ol start="3"><li>logtail常用命令</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动logtail</span></span><br><span class="line">/etc/init.d/ilogtaild start</span><br><span class="line"><span class="comment"># 停止logtail</span></span><br><span class="line">/etc/init.d/ilogtaild stop</span><br><span class="line"><span class="comment"># 查看logtail状态</span></span><br><span class="line">/etc/init.d/ilogtaild status</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="%E4%BA%8C.%20%E9%85%8D%E7%BD%AE%E7%94%A8%E6%88%B7%E6%A0%87%E8%AF%86"><a class="header-anchor" href="#%E4%BA%8C.%20%E9%85%8D%E7%BD%AE%E7%94%A8%E6%88%B7%E6%A0%87%E8%AF%86">¶</a> 二. 配置用户标识</h2><p>打开<a href="https://shell.aliyun.com/?spm=a2c4g.11186623.2.10.56471727wJd6GR">云命令行</a>，执行命令<code>echo $ALIBABA_CLOUD_ACCOUNT_ID</code>，复制用户标识，在 /etc/ilogtail/users目录下，创建账号ID同名文件：<code>touch /etc/ilogtail/users/1*************</code></p><h2 id="%E4%B8%89.%20%E9%85%8D%E7%BD%AE%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%87%E8%AF%86%E6%9C%BA%E5%99%A8%E7%BB%84"><a class="header-anchor" href="#%E4%B8%89.%20%E9%85%8D%E7%BD%AE%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%87%E8%AF%86%E6%9C%BA%E5%99%A8%E7%BB%84">¶</a> 三. 配置用户自定义标识机器组</h2><ol><li>在<code>/etc/ilogtail/</code>目录下创建<code>user_defined_id</code>文件，编辑该文件，配置自定义的标识</li><li>创建机器组，状态中心跳为OK即为配置成功</li></ol><p><img src="/2021/08/03/logtail%E9%87%87%E9%9B%86%E9%85%8D%E7%BD%AE/image-20210803235223988.png" alt="image-20210803235223988"></p><p><img src="/2021/08/03/logtail%E9%87%87%E9%9B%86%E9%85%8D%E7%BD%AE/image-20210803235353431.png" alt="image-20210803235353431"></p><h2 id="%E5%9B%9B.%20%E9%85%8D%E7%BD%AE%E6%97%A5%E5%BF%97%E5%AD%98%E5%82%A8Logstore"><a class="header-anchor" href="#%E5%9B%9B.%20%E9%85%8D%E7%BD%AE%E6%97%A5%E5%BF%97%E5%AD%98%E5%82%A8Logstore">¶</a> 四. 配置日志存储Logstore</h2><ol><li>按官方说明创建即可</li></ol><p><img src="/2021/08/03/logtail%E9%87%87%E9%9B%86%E9%85%8D%E7%BD%AE/image-20210803235841584.png" alt="image-20210803235841584"></p><ol start="2"><li><p>logtail配置，接入数据</p><p>按需求选择数据类型，我这里接入的分隔符-文本日志；</p></li></ol><p><img src="/2021/08/03/logtail%E9%87%87%E9%9B%86%E9%85%8D%E7%BD%AE/image-20210804000219705.png" alt="image-20210804000219705"></p><p>​创建机器组直接使用前面配置的机器组</p><p><img src="/2021/08/03/logtail%E9%87%87%E9%9B%86%E9%85%8D%E7%BD%AE/image-20210804000411775.png" alt="image-20210804000411775"></p><p>​Logtail配置：日志样例，可复制实际项目的日志记录，再编写正则验证是否成功匹配</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">行首正则表达：\[\w+-\w+]\s\d+-\d+-\d+\s.*</span><br></pre></td></tr></table></figure><p><img src="/2021/08/03/logtail%E9%87%87%E9%9B%86%E9%85%8D%E7%BD%AE/image-20210804002203581.png" alt="image-20210804002203581"></p><p>可以看到已经接入了日志数据</p><p><img src="/2021/08/03/logtail%E9%87%87%E9%9B%86%E9%85%8D%E7%BD%AE/image-20210804003003880.png" alt="image-20210804003003880"></p><hr><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭应用的脚本</span></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">PID=$(ps -ef |grep app.jar |grep -v grep |awk <span class="string">&#x27;&#123; print $2 &#125;&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> [ -z<span class="string">&quot;<span class="variable">$PID</span>&quot;</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> Application is already stopped</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="built_in">kill</span> <span class="variable">$PID</span></span><br><span class="line">    <span class="built_in">kill</span> <span class="variable">$PID</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动应用的脚本</span></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">nohup java -jar app.jar &gt;tmp.log &amp;</span><br></pre></td></tr></table></figure><script>    let imgs = document.getElementsByTagName('img');    for (let img of imgs) {        img.setAttribute('class', 'fancybox');    }</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.6.0/katex.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;%E4%B8%80.%20%E5%AE%89%E8%A3%85Logtail&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#%E4%B8%80.%20%E5%AE%89%E8%A3%85Logtail&quot;&gt;¶&lt;/a&gt; 一. 安装Logtail&lt;/</summary>
      
    
    
    
    <category term="阿里云" scheme="http://lampkins.gitee.io/categories/%E9%98%BF%E9%87%8C%E4%BA%91/"/>
    
    
    <category term="日志采集" scheme="http://lampkins.gitee.io/tags/%E6%97%A5%E5%BF%97%E9%87%87%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>MySQL索引背后的数据结构及算法原理</title>
    <link href="http://lampkins.gitee.io/2020/11/05/MySQL%E7%B4%A2%E5%BC%95%E8%83%8C%E5%90%8E%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/"/>
    <id>http://lampkins.gitee.io/2020/11/05/MySQL%E7%B4%A2%E5%BC%95%E8%83%8C%E5%90%8E%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/</id>
    <published>2020-11-05T10:46:00.000Z</published>
    <updated>2020-11-14T08:49:00.056Z</updated>
    
    <content type="html"><![CDATA[<h1 id="%E6%91%98%E8%A6%81"><a class="header-anchor" href="#%E6%91%98%E8%A6%81">¶</a> 摘要</h1><p>本文以MySQL数据库为研究对象，讨论与数据库索引相关的一些话题。特别需要说明的是，MySQL支持诸多存储引擎，而各种存储引擎对索引的支持也各不相同，因此MySQL数据库支持多种索引类型，如BTree索引，哈希索引，全文索引等等。为了避免混乱，本文将只关注于BTree索引，因为这是平常使用MySQL时主要打交道的索引，至于哈希索引和全文索引本文暂不讨论。</p><p>文章主要内容分为三个部分。</p><p>第一部分主要从数据结构及算法理论层面讨论MySQL数据库索引的数理基础。</p><p>第二部分结合MySQL数据库中MyISAM和InnoDB数据存储引擎中索引的架构实现讨论聚集索引、非聚集索引及覆盖索引等话题。</p><p>第三部分根据上面的理论基础，讨论MySQL中高性能使用索引的策略。</p><h1 id="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80"><a class="header-anchor" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80">¶</a> 数据结构及算法基础</h1><h2 id="%E7%B4%A2%E5%BC%95%E7%9A%84%E6%9C%AC%E8%B4%A8"><a class="header-anchor" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E6%9C%AC%E8%B4%A8">¶</a> 索引的本质</h2><p>MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。提取句子主干，就可以得到索引的本质：索引是数据结构。</p><p>我们知道，数据库查询是数据库的最主要功能之一。我们都希望查询数据的速度能尽可能的快，因此数据库系统的设计者会从查询算法的角度进行优化。最基本的查询算法当然是<a href="http://en.wikipedia.org/wiki/Linear_search">顺序查找</a>（linear search），这种复杂度为O(n)的算法在数据量很大时显然是糟糕的，好在计算机科学的发展提供了很多更优秀的查找算法，例如<a href="http://en.wikipedia.org/wiki/Binary_search_algorithm">二分查找</a>（binary search）、<a href="http://en.wikipedia.org/wiki/Binary_search_tree">二叉树查找</a>（binary tree search）等。如果稍微分析一下会发现，每种查找算法都只能应用于特定的数据结构之上，例如二分查找要求被检索数据有序，而二叉树查找只能应用于<a href="http://en.wikipedia.org/wiki/Binary_search_tree">二叉查找树</a>上，但是数据本身的组织结构不可能完全满足各种数据结构（例如，理论上不可能同时将两列都按顺序进行组织），所以，在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。</p><p>看一个例子：</p><p><img src="/2020/11/05/MySQL%E7%B4%A2%E5%BC%95%E8%83%8C%E5%90%8E%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/1.png" alt="img"></p><p align="center">图1</p><p>图1展示了一种可能的索引方式。左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是一定物理相邻的）。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在O(log2n)O(log2n)的复杂度内获取到相应数据。</p><p>虽然这是一个货真价实的索引，但是实际的数据库系统几乎没有使用二叉查找树或其进化品种<a href="http://en.wikipedia.org/wiki/Red-black_tree">红黑树</a>（red-black tree）实现的，原因会在下文介绍。</p><h2 id="B-Tree%E5%92%8CB%2BTree"><a class="header-anchor" href="#B-Tree%E5%92%8CB%2BTree">¶</a> B-Tree和B+Tree</h2><p>目前大部分数据库系统及文件系统都采用B-Tree或其变种B+Tree作为索引结构，在本文的下一节会结合存储器原理及计算机存取原理讨论为什么B-Tree和B+Tree在被如此广泛用于索引，这一节先单纯从数据结构角度描述它们。</p><h3 id="B-Tree"><a class="header-anchor" href="#B-Tree">¶</a> B-Tree</h3><p>为了描述B-Tree，首先定义一条数据记录为一个二元组[key, data]，key为记录的键值，对于不同数据记录，key是互不相同的；data为数据记录除key外的数据。那么B-Tree是满足下列条件的数据结构：</p><p>d为大于1的一个正整数，称为B-Tree的度。</p><p>h为一个正整数，称为B-Tree的高度。</p><p>每个非叶子节点由n-1个key和n个指针组成，其中d&lt;=n&lt;=2d。</p><p>每个叶子节点最少包含一个key和两个指针，最多包含2d-1个key和2d个指针，叶节点的指针均为null 。</p><p>所有叶节点具有相同的深度，等于树高h。</p><p>key和指针互相间隔，节点两端是指针。</p><p>一个节点中的key从左到右非递减排列。</p><p>所有节点组成树结构。</p><p>每个指针要么为null，要么指向另外一个节点。</p><p>如果某个指针在节点node最左边且不为null，则其指向节点的所有key小于v(key1)v(key1)，其中v(key1)v(key1)为node的第一个key的值。</p><p>如果某个指针在节点node最右边且不为null，则其指向节点的所有key大于v(keym)v(keym)，其中v(keym)v(keym)为node的最后一个key的值。</p><p>如果某个指针在节点node的左右相邻key分别是keyikeyi和keyi+1keyi+1且不为null，则其指向节点的所有key小于v(keyi+1)v(keyi+1)且大于v(keyi)v(keyi)。</p><p>图2是一个d=2的B-Tree示意图。</p><p><img src="/2020/11/05/MySQL%E7%B4%A2%E5%BC%95%E8%83%8C%E5%90%8E%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/2.png" alt="img"></p><p align="center">图2</p><p>由于B-Tree的特性，在B-Tree中按key检索数据的算法非常直观：首先从根节点进行二分查找，如果找到则返回对应节点的data，否则对相应区间的指针指向的节点递归进行查找，直到找到节点或找到null指针，前者查找成功，后者查找失败。B-Tree上查找算法的伪代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">BTree_Search(node, key) &#123;</span><br><span class="line">    <span class="keyword">if</span>(node == null)</span><br><span class="line">        <span class="keyword">return</span> null;</span><br><span class="line">    foreach(node.key)    &#123;</span><br><span class="line">        <span class="keyword">if</span>(node.key[i] == key)</span><br><span class="line">            <span class="keyword">return</span> node.data[i];</span><br><span class="line">        <span class="keyword">if</span>(node.key[i] &gt; key)</span><br><span class="line">            <span class="keyword">return</span> BTree_Search(point[i]-&gt;node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> BTree_Search(point[i+<span class="number">1</span>]-&gt;node);</span><br><span class="line">&#125;</span><br><span class="line">data = BTree_Search(root, my_key);</span><br></pre></td></tr></table></figure><p>关于B-Tree有一系列有趣的性质，例如一个度为d的B-Tree，设其索引N个key，则其树高h的上限为logd((N+1)/2)logd((N+1)/2)，检索一个key，其查找节点个数的渐进复杂度为O(logdN)O(logdN)。从这点可以看出，B-Tree是一个非常有效率的索引数据结构。</p><p>另外，由于插入删除新的数据记录会破坏B-Tree的性质，因此在插入删除时，需要对树进行一个分裂、合并、转移等操作以保持B-Tree性质，本文不打算完整讨论B-Tree这些内容，因为已经有许多资料详细说明了B-Tree的数学性质及插入删除算法，有兴趣的朋友可以在本文末的参考文献一栏找到相应的资料进行阅读。</p><h3 id="B%2BTree"><a class="header-anchor" href="#B%2BTree">¶</a> B+Tree</h3><p>B-Tree有许多变种，其中最常见的是B+Tree，例如MySQL就普遍使用B+Tree实现其索引结构。</p><p>与B-Tree相比，B+Tree有以下不同点：</p><p>每个节点的指针上限为2d而不是2d+1。</p><p>内节点不存储data，只存储key；叶子节点不存储指针。</p><p>图3是一个简单的B+Tree示意。</p><p><img src="/2020/11/05/MySQL%E7%B4%A2%E5%BC%95%E8%83%8C%E5%90%8E%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/3.png" alt="img"></p><p align="center">图3</p><p>由于并不是所有节点都具有相同的域，因此B+Tree中叶节点和内节点一般大小不同。这点与B-Tree不同，虽然B-Tree中不同节点存放的key和指针可能数量不一致，但是每个节点的域和上限是一致的，所以在实现中B-Tree往往对每个节点申请同等大小的空间。</p><p>一般来说，B+Tree比B-Tree更适合实现外存储索引结构，具体原因与外存储器原理及计算机存取原理有关，将在下面讨论。</p><h3 id="%E5%B8%A6%E6%9C%89%E9%A1%BA%E5%BA%8F%E8%AE%BF%E9%97%AE%E6%8C%87%E9%92%88%E7%9A%84B%2BTree"><a class="header-anchor" href="#%E5%B8%A6%E6%9C%89%E9%A1%BA%E5%BA%8F%E8%AE%BF%E9%97%AE%E6%8C%87%E9%92%88%E7%9A%84B%2BTree">¶</a> 带有顺序访问指针的B+Tree</h3><p>一般在数据库系统或文件系统中使用的B+Tree结构都在经典B+Tree的基础上进行了优化，增加了顺序访问指针。</p><p><img src="/2020/11/05/MySQL%E7%B4%A2%E5%BC%95%E8%83%8C%E5%90%8E%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/4.png" alt="img"></p><p align="center">图4</p><p>如图4所示，在B+Tree的每个叶子节点增加一个指向相邻叶子节点的指针，就形成了带有顺序访问指针的B+Tree。做这个优化的目的是为了提高区间访问的性能，例如图4中如果要查询key为从18到49的所有数据记录，当找到18后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提到了区间查询效率。</p><p>这一节对B-Tree和B+Tree进行了一个简单的介绍，下一节结合存储器存取原理介绍为什么目前B+Tree是数据库系统实现索引的首选数据结构。</p><h2 id="%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8B-Tree%EF%BC%88B%2BTree%EF%BC%89"><a class="header-anchor" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8B-Tree%EF%BC%88B%2BTree%EF%BC%89">¶</a> 为什么使用B-Tree（B+Tree）</h2><p>上文说过，红黑树等数据结构也可以用来实现索引，但是文件系统及数据库系统普遍采用B-/+Tree作为索引结构，这一节将结合计算机组成原理相关知识讨论B-/+Tree作为索引的理论基础。</p><p>一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数。下面先介绍内存和磁盘存取原理，然后再结合这些原理分析B-/+Tree作为索引的效率。</p><h3 id="%E4%B8%BB%E5%AD%98%E5%AD%98%E5%8F%96%E5%8E%9F%E7%90%86"><a class="header-anchor" href="#%E4%B8%BB%E5%AD%98%E5%AD%98%E5%8F%96%E5%8E%9F%E7%90%86">¶</a> 主存存取原理</h3><p>目前计算机使用的主存基本都是随机读写存储器（RAM），现代RAM的结构和存取原理比较复杂，这里本文抛却具体差别，抽象出一个十分简单的存取模型来说明RAM的工作原理。</p><p><img src="/2020/11/05/MySQL%E7%B4%A2%E5%BC%95%E8%83%8C%E5%90%8E%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/5.png" alt="img"></p><p align="center">图5</p><p>从抽象角度看，主存是一系列的存储单元组成的矩阵，每个存储单元存储固定大小的数据。每个存储单元有唯一的地址，现代主存的编址规则比较复杂，这里将其简化成一个二维地址：通过一个行地址和一个列地址可以唯一定位到一个存储单元。图5展示了一个4 x 4的主存模型。</p><p>主存的存取过程如下：</p><p>当系统需要读取主存时，则将地址信号放到地址总线上传给主存，主存读到地址信号后，解析信号并定位到指定存储单元，然后将此存储单元数据放到数据总线上，供其它部件读取。</p><p>写主存的过程类似，系统将要写入单元地址和数据分别放在地址总线和数据总线上，主存读取两个总线的内容，做相应的写操作。</p><p>这里可以看出，主存存取的时间仅与存取次数呈线性关系，因为不存在机械操作，两次存取的数据的“距离”不会对时间有任何影响，例如，先取A0再取A1和先取A0再取D3的时间消耗是一样的。</p><h3 id="%E7%A3%81%E7%9B%98%E5%AD%98%E5%8F%96%E5%8E%9F%E7%90%86"><a class="header-anchor" href="#%E7%A3%81%E7%9B%98%E5%AD%98%E5%8F%96%E5%8E%9F%E7%90%86">¶</a> 磁盘存取原理</h3><p>上文说过，索引一般以文件形式存储在磁盘上，索引检索需要磁盘I/O操作。与主存不同，磁盘I/O存在机械运动耗费，因此磁盘I/O的时间消耗是巨大的。</p><p>图6是磁盘的整体结构示意图。</p><p><img src="/2020/11/05/MySQL%E7%B4%A2%E5%BC%95%E8%83%8C%E5%90%8E%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/6.png" alt="img"></p><p align="center">图6</p><p>一个磁盘由大小相同且同轴的圆形盘片组成，磁盘可以转动（各个磁盘必须同步转动）。在磁盘的一侧有磁头支架，磁头支架固定了一组磁头，每个磁头负责存取一个磁盘的内容。磁头不能转动，但是可以沿磁盘半径方向运动（实际是斜切向运动），每个磁头同一时刻也必须是同轴的，即从正上方向下看，所有磁头任何时候都是重叠的（不过目前已经有多磁头独立技术，可不受此限制）。</p><p>图7是磁盘结构的示意图。</p><p><img src="/2020/11/05/MySQL%E7%B4%A2%E5%BC%95%E8%83%8C%E5%90%8E%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/7.png" alt="img"></p><p align="center">图7</p><p>盘片被划分成一系列同心环，圆心是盘片中心，每个同心环叫做一个磁道，所有半径相同的磁道组成一个柱面。磁道被沿半径线划分成一个个小的段，每个段叫做一个扇区，每个扇区是磁盘的最小存储单元。为了简单起见，我们下面假设磁盘只有一个盘片和一个磁头。</p><p>当需要从磁盘读取数据时，系统会将数据逻辑地址传给磁盘，磁盘的控制电路按照寻址逻辑将逻辑地址翻译成物理地址，即确定要读的数据在哪个磁道，哪个扇区。为了读取这个扇区的数据，需要将磁头放到这个扇区上方，为了实现这一点，磁头需要移动对准相应磁道，这个过程叫做寻道，所耗费时间叫做寻道时间，然后磁盘旋转将目标扇区旋转到磁头下，这个过程耗费的时间叫做旋转时间。</p><h3 id="%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86%E4%B8%8E%E7%A3%81%E7%9B%98%E9%A2%84%E8%AF%BB"><a class="header-anchor" href="#%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86%E4%B8%8E%E7%A3%81%E7%9B%98%E9%A2%84%E8%AF%BB">¶</a> 局部性原理与磁盘预读</h3><p>由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理：</p><p>当一个数据被用到时，其附近的数据也通常会马上被使用。</p><p>程序运行期间所需要的数据通常比较集中。</p><p>由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。</p><p>预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。</p><h3 id="B-%2F%2BTree%E7%B4%A2%E5%BC%95%E7%9A%84%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><a class="header-anchor" href="#B-%2F%2BTree%E7%B4%A2%E5%BC%95%E7%9A%84%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90">¶</a> B-/+Tree索引的性能分析</h3><p>到这里终于可以分析B-/+Tree索引的性能了。</p><p>上文说过一般使用磁盘I/O次数评价索引结构的优劣。先从B-Tree分析，根据B-Tree的定义，可知检索一次最多需要访问h个节点。数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：</p><p>每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。</p><p>B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为O(h)=O(logdN)O(h)=O(logdN)。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。</p><p>综上所述，用B-Tree作为索引结构效率是非常高的。</p><p>而红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多。</p><p>上文还说过，B+Tree更适合外存索引，原因和内节点出度d有关。从上面分析可以看到，d越大索引的性能越好，而出度的上限取决于节点内key和data的大小：</p><p>dmax=floor(pagesize/(keysize+datasize+pointsize))dmax=floor(pagesize/(keysize+datasize+pointsize))</p><p>floor表示向下取整。由于B+Tree内节点去掉了data域，因此可以拥有更大的出度，拥有更好的性能。</p><p>这一章从理论角度讨论了与索引相关的数据结构与算法问题，下一章将讨论B+Tree是如何具体实现为MySQL中索引，同时将结合MyISAM和InnDB存储引擎介绍非聚集索引和聚集索引两种不同的索引实现形式。</p><h1 id="MySQL%E7%B4%A2%E5%BC%95%E5%AE%9E%E7%8E%B0"><a class="header-anchor" href="#MySQL%E7%B4%A2%E5%BC%95%E5%AE%9E%E7%8E%B0">¶</a> MySQL索引实现</h1><p>在MySQL中，索引属于存储引擎级别的概念，不同存储引擎对索引的实现方式是不同的，本文主要讨论MyISAM和InnoDB两个存储引擎的索引实现方式。</p><h2 id="MyISAM%E7%B4%A2%E5%BC%95%E5%AE%9E%E7%8E%B0"><a class="header-anchor" href="#MyISAM%E7%B4%A2%E5%BC%95%E5%AE%9E%E7%8E%B0">¶</a> MyISAM索引实现</h2><p>MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。下图是MyISAM索引的原理图：</p><p><img src="/2020/11/05/MySQL%E7%B4%A2%E5%BC%95%E8%83%8C%E5%90%8E%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/8.png" alt="img"></p><p align="center">图8</p><p>这里设表一共有三列，假设我们以Col1为主键，则图8是一个MyISAM表的主索引（Primary key）示意。可以看出MyISAM的索引文件仅仅保存数据记录的地址。在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。如果我们在Col2上建立一个辅助索引，则此索引的结构如下图所示：</p><p><img src="/2020/11/05/MySQL%E7%B4%A2%E5%BC%95%E8%83%8C%E5%90%8E%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/9.png" alt="img"></p><p align="center">图9</p><p>同样也是一颗B+Tree，data域保存数据记录的地址。因此，MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。</p><p>MyISAM的索引方式也叫做“非聚集”的，之所以这么称呼是为了与InnoDB的聚集索引区分。</p><h2 id="InnoDB%E7%B4%A2%E5%BC%95%E5%AE%9E%E7%8E%B0"><a class="header-anchor" href="#InnoDB%E7%B4%A2%E5%BC%95%E5%AE%9E%E7%8E%B0">¶</a> InnoDB索引实现</h2><p>虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。</p><p>第一个重大区别是InnoDB的数据文件本身就是索引文件。从上文知道，MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。</p><p><img src="/2020/11/05/MySQL%E7%B4%A2%E5%BC%95%E8%83%8C%E5%90%8E%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/10.png" alt="img"></p><p align="center">图10</p><p>图10是InnoDB主索引（同时也是数据文件）的示意图，可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。</p><p>第二个与MyISAM索引的不同是InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。例如，图11为定义在Col3上的一个辅助索引：</p><p><img src="/2020/11/05/MySQL%E7%B4%A2%E5%BC%95%E8%83%8C%E5%90%8E%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/11.png" alt="img"></p><p align="center">图11</p><p>这里以英文字符的ASCII码作为比较准则。聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。</p><p>了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助，例如知道了InnoDB的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。再例如，用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。</p><p>下一章将具体讨论这些与索引有关的优化策略。</p><h1 id="%E7%B4%A2%E5%BC%95%E4%BD%BF%E7%94%A8%E7%AD%96%E7%95%A5%E5%8F%8A%E4%BC%98%E5%8C%96"><a class="header-anchor" href="#%E7%B4%A2%E5%BC%95%E4%BD%BF%E7%94%A8%E7%AD%96%E7%95%A5%E5%8F%8A%E4%BC%98%E5%8C%96">¶</a> 索引使用策略及优化</h1><p>MySQL的优化主要分为结构优化（Scheme optimization）和查询优化（Query optimization）。本章讨论的高性能索引策略主要属于结构优化范畴。本章的内容完全基于上文的理论基础，实际上一旦理解了索引背后的机制，那么选择高性能的策略就变成了纯粹的推理，并且可以理解这些策略背后的逻辑。</p><h2 id="%E7%A4%BA%E4%BE%8B%E6%95%B0%E6%8D%AE%E5%BA%93"><a class="header-anchor" href="#%E7%A4%BA%E4%BE%8B%E6%95%B0%E6%8D%AE%E5%BA%93">¶</a> 示例数据库</h2><p>为了讨论索引策略，需要一个数据量不算小的数据库作为示例。本文选用MySQL官方文档中提供的示例数据库之一：employees。这个数据库关系复杂度适中，且数据量较大。下图是这个数据库的E-R关系图（引用自MySQL官方手册）：</p><p><img src="/2020/11/05/MySQL%E7%B4%A2%E5%BC%95%E8%83%8C%E5%90%8E%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/12.png" alt="img"></p><p align="center">图12</p><p>MySQL官方文档中关于此数据库的页面为http://dev.mysql.com/doc/employee/en/employee.html。里面详细介绍了此数据库，并提供了下载地址和导入方法，如果有兴趣导入此数据库到自己的MySQL可以参考文中内容。</p><h2 id="%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8E%9F%E7%90%86%E4%B8%8E%E7%9B%B8%E5%85%B3%E4%BC%98%E5%8C%96"><a class="header-anchor" href="#%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8E%9F%E7%90%86%E4%B8%8E%E7%9B%B8%E5%85%B3%E4%BC%98%E5%8C%96">¶</a> 最左前缀原理与相关优化</h2><p>高效使用索引的首要条件是知道什么样的查询会使用到索引，这个问题和B+Tree中的“最左前缀原理”有关，下面通过例子说明最左前缀原理。</p><p>这里先说一下联合索引的概念。在上文中，我们都是假设索引只引用了单个的列，实际上，MySQL中的索引可以以一定顺序引用多个列，这种索引叫做联合索引，一般的，一个联合索引是一个有序元组&lt;a1, a2, …, an&gt;，其中各个元素均为数据表的一列，实际上要严格定义索引需要用到关系代数，但是这里我不想讨论太多关系代数的话题，因为那样会显得很枯燥，所以这里就不再做严格定义。另外，单列索引可以看成联合索引元素数为1的特例。</p><p>以employees.titles表为例，下面先查看其上都有哪些索引：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW INDEX FROM employees.titles;+--------+------------+----------+--------------+-------------+-----------+-------------+------+------------+| Table  | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Null | Index_type |+--------+------------+----------+--------------+-------------+-----------+-------------+------+------------+| titles |          0 | PRIMARY  |            1 | emp_no      | A         |        NULL |      | BTREE      || titles |          0 | PRIMARY  |            2 | title       | A         |        NULL |      | BTREE      || titles |          0 | PRIMARY  |            3 | from_date   | A         |      443308 |      | BTREE      || titles |          1 | emp_no   |            1 | emp_no      | A         |      443308 |      | BTREE      |+--------+------------+----------+--------------+-------------+-----------+-------------+------+------------+</span><br></pre></td></tr></table></figure><p>从结果中可以到titles表的主索引为&lt;emp_no, title, from_date&gt;，还有一个辅助索引&lt;emp_no&gt;。为了避免多个索引使事情变复杂（MySQL的SQL优化器在多索引时行为比较复杂），这里我们将辅助索引drop掉：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE employees.titles DROP INDEX emp_no;</span><br></pre></td></tr></table></figure><p>这样就可以专心分析索引PRIMARY的行为了。</p><h3 id="%E6%83%85%E5%86%B5%E4%B8%80%EF%BC%9A%E5%85%A8%E5%88%97%E5%8C%B9%E9%85%8D%E3%80%82"><a class="header-anchor" href="#%E6%83%85%E5%86%B5%E4%B8%80%EF%BC%9A%E5%85%A8%E5%88%97%E5%8C%B9%E9%85%8D%E3%80%82">¶</a> 情况一：全列匹配。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM employees.titles WHERE emp_no&#x3D;&#39;10001&#39; AND title&#x3D;&#39;Senior Engineer&#39; AND from_date&#x3D;&#39;1986-06-26&#39;;+----+-------------+--------+-------+---------------+---------+---------+-------------------+------+-------+| id | select_type | table  | type  | possible_keys | key     | key_len | ref               | rows | Extra |+----+-------------+--------+-------+---------------+---------+---------+-------------------+------+-------+|  1 | SIMPLE      | titles | const | PRIMARY       | PRIMARY | 59      | const,const,const |    1 |       |+----+-------------+--------+-------+---------------+---------+---------+-------------------+------+-------+</span><br></pre></td></tr></table></figure><p>很明显，当按照索引中所有列进行精确匹配（这里精确匹配指“=”或“IN”匹配）时，索引可以被用到。这里有一点需要注意，理论上索引对顺序是敏感的，但是由于MySQL的查询优化器会自动调整where子句的条件顺序以使用适合的索引，例如我们将where中的条件顺序颠倒：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM employees.titles WHERE from_date&#x3D;&#39;1986-06-26&#39; AND emp_no&#x3D;&#39;10001&#39; AND title&#x3D;&#39;Senior Engineer&#39;;+----+-------------+--------+-------+---------------+---------+---------+-------------------+------+-------+| id | select_type | table  | type  | possible_keys | key     | key_len | ref               | rows | Extra |+----+-------------+--------+-------+---------------+---------+---------+-------------------+------+-------+|  1 | SIMPLE      | titles | const | PRIMARY       | PRIMARY | 59      | const,const,const |    1 |       |+----+-------------+--------+-------+---------------+---------+---------+-------------------+------+-------+</span><br></pre></td></tr></table></figure><p>效果是一样的。</p><h3 id="%E6%83%85%E5%86%B5%E4%BA%8C%EF%BC%9A%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8C%B9%E9%85%8D%E3%80%82"><a class="header-anchor" href="#%E6%83%85%E5%86%B5%E4%BA%8C%EF%BC%9A%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8C%B9%E9%85%8D%E3%80%82">¶</a> 情况二：最左前缀匹配。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM employees.titles WHERE emp_no&#x3D;&#39;10001&#39;;+----+-------------+--------+------+---------------+---------+---------+-------+------+-------+| id | select_type | table  | type | possible_keys | key     | key_len | ref   | rows | Extra |+----+-------------+--------+------+---------------+---------+---------+-------+------+-------+|  1 | SIMPLE      | titles | ref  | PRIMARY       | PRIMARY | 4       | const |    1 |       |+----+-------------+--------+------+---------------+---------+---------+-------+------+-------+</span><br></pre></td></tr></table></figure><p>当查询条件精确匹配索引的左边连续一个或几个列时，如&lt;emp_no&gt;或&lt;emp_no, title&gt;，所以可以被用到，但是只能用到一部分，即条件所组成的最左前缀。上面的查询从分析结果看用到了PRIMARY索引，但是key_len为4，说明只用到了索引的第一列前缀。</p><h3 id="%E6%83%85%E5%86%B5%E4%B8%89%EF%BC%9A%E6%9F%A5%E8%AF%A2%E6%9D%A1%E4%BB%B6%E7%94%A8%E5%88%B0%E4%BA%86%E7%B4%A2%E5%BC%95%E4%B8%AD%E5%88%97%E7%9A%84%E7%B2%BE%E7%A1%AE%E5%8C%B9%E9%85%8D%EF%BC%8C%E4%BD%86%E6%98%AF%E4%B8%AD%E9%97%B4%E6%9F%90%E4%B8%AA%E6%9D%A1%E4%BB%B6%E6%9C%AA%E6%8F%90%E4%BE%9B%E3%80%82"><a class="header-anchor" href="#%E6%83%85%E5%86%B5%E4%B8%89%EF%BC%9A%E6%9F%A5%E8%AF%A2%E6%9D%A1%E4%BB%B6%E7%94%A8%E5%88%B0%E4%BA%86%E7%B4%A2%E5%BC%95%E4%B8%AD%E5%88%97%E7%9A%84%E7%B2%BE%E7%A1%AE%E5%8C%B9%E9%85%8D%EF%BC%8C%E4%BD%86%E6%98%AF%E4%B8%AD%E9%97%B4%E6%9F%90%E4%B8%AA%E6%9D%A1%E4%BB%B6%E6%9C%AA%E6%8F%90%E4%BE%9B%E3%80%82">¶</a> 情况三：查询条件用到了索引中列的精确匹配，但是中间某个条件未提供。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM employees.titles WHERE emp_no&#x3D;&#39;10001&#39; AND from_date&#x3D;&#39;1986-06-26&#39;;+----+-------------+--------+------+---------------+---------+---------+-------+------+-------------+| id | select_type | table  | type | possible_keys | key     | key_len | ref   | rows | Extra       |+----+-------------+--------+------+---------------+---------+---------+-------+------+-------------+|  1 | SIMPLE      | titles | ref  | PRIMARY       | PRIMARY | 4       | const |    1 | Using where |+----+-------------+--------+------+---------------+---------+---------+-------+------+-------------+</span><br></pre></td></tr></table></figure><p>此时索引使用情况和情况二相同，因为title未提供，所以查询只用到了索引的第一列，而后面的from_date虽然也在索引中，但是由于title不存在而无法和左前缀连接，因此需要对结果进行扫描过滤from_date（这里由于emp_no唯一，所以不存在扫描）。如果想让from_date也使用索引而不是where过滤，可以增加一个辅助索引&lt;emp_no, from_date&gt;，此时上面的查询会使用这个索引。除此之外，还可以使用一种称之为“隔离列”的优化方法，将emp_no与from_date之间的“坑”填上。</p><p>首先我们看下title一共有几种不同的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT(title) FROM employees.titles;+--------------------+| title              |+--------------------+| Senior Engineer    || Staff              || Engineer           || Senior Staff       || Assistant Engineer || Technique Leader   || Manager            |+--------------------+</span><br></pre></td></tr></table></figure><p>只有7种。在这种成为“坑”的列值比较少的情况下，可以考虑用“IN”来填补这个“坑”从而形成最左前缀：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM employees.titlesWHERE emp_no&#x3D;&#39;10001&#39;AND title IN (&#39;Senior Engineer&#39;, &#39;Staff&#39;, &#39;Engineer&#39;, &#39;Senior Staff&#39;, &#39;Assistant Engineer&#39;, &#39;Technique Leader&#39;, &#39;Manager&#39;)AND from_date&#x3D;&#39;1986-06-26&#39;;+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+| id | select_type | table  | type  | possible_keys | key     | key_len | ref  | rows | Extra       |+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+|  1 | SIMPLE      | titles | range | PRIMARY       | PRIMARY | 59      | NULL |    7 | Using where |+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+</span><br></pre></td></tr></table></figure><p>这次key_len为59，说明索引被用全了，但是从type和rows看出IN实际上执行了一个range查询，这里检查了7个key。看下两种查询的性能比较：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW PROFILES;+----------+------------+-------------------------------------------------------------------------------+| Query_ID | Duration   | Query                                                                         |+----------+------------+-------------------------------------------------------------------------------+|       10 | 0.00058000 | SELECT * FROM employees.titles WHERE emp_no&#x3D;&#39;10001&#39; AND from_date&#x3D;&#39;1986-06-26&#39;||       11 | 0.00052500 | SELECT * FROM employees.titles WHERE emp_no&#x3D;&#39;10001&#39; AND title IN ...          |+----------+------------+-------------------------------------------------------------------------------+</span><br></pre></td></tr></table></figure><p>“填坑”后性能提升了一点。如果经过emp_no筛选后余下很多数据，则后者性能优势会更加明显。当然，如果title的值很多，用填坑就不合适了，必须建立辅助索引。</p><h3 id="%E6%83%85%E5%86%B5%E5%9B%9B%EF%BC%9A%E6%9F%A5%E8%AF%A2%E6%9D%A1%E4%BB%B6%E6%B2%A1%E6%9C%89%E6%8C%87%E5%AE%9A%E7%B4%A2%E5%BC%95%E7%AC%AC%E4%B8%80%E5%88%97%E3%80%82"><a class="header-anchor" href="#%E6%83%85%E5%86%B5%E5%9B%9B%EF%BC%9A%E6%9F%A5%E8%AF%A2%E6%9D%A1%E4%BB%B6%E6%B2%A1%E6%9C%89%E6%8C%87%E5%AE%9A%E7%B4%A2%E5%BC%95%E7%AC%AC%E4%B8%80%E5%88%97%E3%80%82">¶</a> 情况四：查询条件没有指定索引第一列。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM employees.titles WHERE from_date&#x3D;&#39;1986-06-26&#39;;+----+-------------+--------+------+---------------+------+---------+------+--------+-------------+| id | select_type | table  | type | possible_keys | key  | key_len | ref  | rows   | Extra       |+----+-------------+--------+------+---------------+------+---------+------+--------+-------------+|  1 | SIMPLE      | titles | ALL  | NULL          | NULL | NULL    | NULL | 443308 | Using where |+----+-------------+--------+------+---------------+------+---------+------+--------+-------------+</span><br></pre></td></tr></table></figure><p>由于不是最左前缀，索引这样的查询显然用不到索引。</p><h3 id="%E6%83%85%E5%86%B5%E4%BA%94%EF%BC%9A%E5%8C%B9%E9%85%8D%E6%9F%90%E5%88%97%E7%9A%84%E5%89%8D%E7%BC%80%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%82"><a class="header-anchor" href="#%E6%83%85%E5%86%B5%E4%BA%94%EF%BC%9A%E5%8C%B9%E9%85%8D%E6%9F%90%E5%88%97%E7%9A%84%E5%89%8D%E7%BC%80%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%82">¶</a> 情况五：匹配某列的前缀字符串。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM employees.titles WHERE emp_no&#x3D;&#39;10001&#39; AND title LIKE &#39;Senior%&#39;;+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+| id | select_type | table  | type  | possible_keys | key     | key_len | ref  | rows | Extra       |+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+|  1 | SIMPLE      | titles | range | PRIMARY       | PRIMARY | 56      | NULL |    1 | Using where |+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+</span><br></pre></td></tr></table></figure><p>此时可以用到索引，<s>但是如果通配符不是只出现在末尾，则无法使用索引。</s>（原文表述有误，如果通配符%不出现在开头，则可以用到索引，但根据具体情况不同可能只会用其中一个前缀）</p><h3 id="%E6%83%85%E5%86%B5%E5%85%AD%EF%BC%9A%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2%E3%80%82"><a class="header-anchor" href="#%E6%83%85%E5%86%B5%E5%85%AD%EF%BC%9A%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2%E3%80%82">¶</a> 情况六：范围查询。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM employees.titles WHERE emp_no &lt; &#39;10010&#39; and title&#x3D;&#39;Senior Engineer&#39;;+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+| id | select_type | table  | type  | possible_keys | key     | key_len | ref  | rows | Extra       |+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+|  1 | SIMPLE      | titles | range | PRIMARY       | PRIMARY | 4       | NULL |   16 | Using where |+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+</span><br></pre></td></tr></table></figure><p>范围列可以用到索引（必须是最左前缀），但是范围列后面的列无法用到索引。同时，索引最多用于一个范围列，因此如果查询条件中有两个范围列则无法全用到索引。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM employees.titlesWHERE emp_no &lt; &#39;10010&#39;AND title&#x3D;&#39;Senior Engineer&#39;AND from_date BETWEEN &#39;1986-01-01&#39; AND &#39;1986-12-31&#39;;+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+| id | select_type | table  | type  | possible_keys | key     | key_len | ref  | rows | Extra       |+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+|  1 | SIMPLE      | titles | range | PRIMARY       | PRIMARY | 4       | NULL |   16 | Using where |+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+</span><br></pre></td></tr></table></figure><p>可以看到索引对第二个范围索引无能为力。这里特别要说明MySQL一个有意思的地方，那就是仅用explain可能无法区分范围索引和多值匹配，因为在type中这两者都显示为range。同时，用了“between”并不意味着就是范围查询，例如下面的查询：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM employees.titlesWHERE emp_no BETWEEN &#39;10001&#39; AND &#39;10010&#39;AND title&#x3D;&#39;Senior Engineer&#39;AND from_date BETWEEN &#39;1986-01-01&#39; AND &#39;1986-12-31&#39;;+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+| id | select_type | table  | type  | possible_keys | key     | key_len | ref  | rows | Extra       |+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+|  1 | SIMPLE      | titles | range | PRIMARY       | PRIMARY | 59      | NULL |   16 | Using where |+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+</span><br></pre></td></tr></table></figure><p>看起来是用了两个范围查询，但作用于emp_no上的“BETWEEN”实际上相当于“IN”，也就是说emp_no实际是多值精确匹配。可以看到这个查询用到了索引全部三个列。因此在MySQL中要谨慎地区分多值匹配和范围匹配，否则会对MySQL的行为产生困惑。</p><h3 id="%E6%83%85%E5%86%B5%E4%B8%83%EF%BC%9A%E6%9F%A5%E8%AF%A2%E6%9D%A1%E4%BB%B6%E4%B8%AD%E5%90%AB%E6%9C%89%E5%87%BD%E6%95%B0%E6%88%96%E8%A1%A8%E8%BE%BE%E5%BC%8F%E3%80%82"><a class="header-anchor" href="#%E6%83%85%E5%86%B5%E4%B8%83%EF%BC%9A%E6%9F%A5%E8%AF%A2%E6%9D%A1%E4%BB%B6%E4%B8%AD%E5%90%AB%E6%9C%89%E5%87%BD%E6%95%B0%E6%88%96%E8%A1%A8%E8%BE%BE%E5%BC%8F%E3%80%82">¶</a> 情况七：查询条件中含有函数或表达式。</h3><p>很不幸，如果查询条件中含有函数或表达式，则MySQL不会为这列使用索引（虽然某些在数学意义上可以使用）。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM employees.titles WHERE emp_no&#x3D;&#39;10001&#39; AND left(title, 6)&#x3D;&#39;Senior&#39;;+----+-------------+--------+------+---------------+---------+---------+-------+------+-------------+| id | select_type | table  | type | possible_keys | key     | key_len | ref   | rows | Extra       |+----+-------------+--------+------+---------------+---------+---------+-------+------+-------------+|  1 | SIMPLE      | titles | ref  | PRIMARY       | PRIMARY | 4       | const |    1 | Using where |+----+-------------+--------+------+---------------+---------+---------+-------+------+-------------+</span><br></pre></td></tr></table></figure><p>虽然这个查询和情况五中功能相同，但是由于使用了函数left，则无法为title列应用索引，而情况五中用LIKE则可以。再如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM employees.titles WHERE emp_no - 1&#x3D;&#39;10000&#39;;+----+-------------+--------+------+---------------+------+---------+------+--------+-------------+| id | select_type | table  | type | possible_keys | key  | key_len | ref  | rows   | Extra       |+----+-------------+--------+------+---------------+------+---------+------+--------+-------------+|  1 | SIMPLE      | titles | ALL  | NULL          | NULL | NULL    | NULL | 443308 | Using where |+----+-------------+--------+------+---------------+------+---------+------+--------+-------------+</span><br></pre></td></tr></table></figure><p>显然这个查询等价于查询emp_no为10001的函数，但是由于查询条件是一个表达式，MySQL无法为其使用索引。看来MySQL还没有智能到自动优化常量表达式的程度，因此在写查询语句时尽量避免表达式出现在查询中，而是先手工私下代数运算，转换为无表达式的查询语句。</p><h2 id="%E7%B4%A2%E5%BC%95%E9%80%89%E6%8B%A9%E6%80%A7%E4%B8%8E%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95"><a class="header-anchor" href="#%E7%B4%A2%E5%BC%95%E9%80%89%E6%8B%A9%E6%80%A7%E4%B8%8E%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95">¶</a> 索引选择性与前缀索引</h2><p>既然索引可以加快查询速度，那么是不是只要是查询语句需要，就建上索引？答案是否定的。因为索引虽然加快了查询速度，但索引也是有代价的：索引文件本身要消耗存储空间，同时索引会加重插入、删除和修改记录时的负担，另外，MySQL在运行时也要消耗资源维护索引，因此索引并不是越多越好。一般两种情况下不建议建索引。</p><p>第一种情况是表记录比较少，例如一两千条甚至只有几百条记录的表，没必要建索引，让查询做全表扫描就好了。至于多少条记录才算多，这个个人有个人的看法，我个人的经验是以2000作为分界线，记录数不超过 2000可以考虑不建索引，超过2000条可以酌情考虑索引。</p><p>另一种不建议建索引的情况是索引的选择性较低。所谓索引的选择性（Selectivity），是指不重复的索引值（也叫基数，Cardinality）与表记录数（#T）的比值：</p><p>Index Selectivity = Cardinality / #T</p><p>显然选择性的取值范围为(0, 1]，选择性越高的索引价值越大，这是由B+Tree的性质决定的。例如，上文用到的employees.titles表，如果title字段经常被单独查询，是否需要建索引，我们看一下它的选择性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT count(DISTINCT(title))&#x2F;count(*) AS Selectivity FROM employees.titles;+-------------+| Selectivity |+-------------+|      0.0000 |+-------------+</span><br></pre></td></tr></table></figure><p>title的选择性不足0.0001（精确值为0.00001579），所以实在没有什么必要为其单独建索引。</p><p>有一种与索引选择性有关的索引优化策略叫做前缀索引，就是用列的前缀代替整个列作为索引key，当前缀长度合适时，可以做到既使得前缀索引的选择性接近全列索引，同时因为索引key变短而减少了索引文件的大小和维护开销。下面以employees.employees表为例介绍前缀索引的选择和使用。</p><p>从图12可以看到employees表只有一个索引&lt;emp_no&gt;，那么如果我们想按名字搜索一个人，就只能全表扫描了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM employees.employees WHERE first_name&#x3D;&#39;Eric&#39; AND last_name&#x3D;&#39;Anido&#39;;+----+-------------+-----------+------+---------------+------+---------+------+--------+-------------+| id | select_type | table     | type | possible_keys | key  | key_len | ref  | rows   | Extra       |+----+-------------+-----------+------+---------------+------+---------+------+--------+-------------+|  1 | SIMPLE      | employees | ALL  | NULL          | NULL | NULL    | NULL | 300024 | Using where |+----+-------------+-----------+------+---------------+------+---------+------+--------+-------------+</span><br></pre></td></tr></table></figure><p>如果频繁按名字搜索员工，这样显然效率很低，因此我们可以考虑建索引。有两种选择，建&lt;first_name&gt;或&lt;first_name, last_name&gt;，看下两个索引的选择性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT count(DISTINCT(first_name))&#x2F;count(*) AS Selectivity FROM employees.employees;+-------------+| Selectivity |+-------------+|      0.0042 |+-------------+SELECT count(DISTINCT(concat(first_name, last_name)))&#x2F;count(*) AS Selectivity FROM employees.employees;+-------------+| Selectivity |+-------------+|      0.9313 |+-------------+</span><br></pre></td></tr></table></figure><p>&lt;first_name&gt;显然选择性太低，&lt;first_name, last_name&gt;选择性很好，但是first_name和last_name加起来长度为30，有没有兼顾长度和选择性的办法？可以考虑用first_name和last_name的前几个字符建立索引，例如&lt;first_name, left(last_name, 3)&gt;，看看其选择性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT count(DISTINCT(concat(first_name, left(last_name, 3))))&#x2F;count(*) AS Selectivity FROM employees.employees;+-------------+| Selectivity |+-------------+|      0.7879 |+-------------+</span><br></pre></td></tr></table></figure><p>选择性还不错，但离0.9313还是有点距离，那么把last_name前缀加到4：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT count(DISTINCT(concat(first_name, left(last_name, 4))))&#x2F;count(*) AS Selectivity FROM employees.employees;+-------------+| Selectivity |+-------------+|      0.9007 |+-------------+</span><br></pre></td></tr></table></figure><p>这时选择性已经很理想了，而这个索引的长度只有18，比&lt;first_name, last_name&gt;短了接近一半，我们把这个前缀索引 建上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE employees.employeesADD INDEX &#96;first_name_last_name4&#96; (first_name, last_name(4));</span><br></pre></td></tr></table></figure><p>此时再执行一遍按名字查询，比较分析一下与建索引前的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW PROFILES;+----------+------------+---------------------------------------------------------------------------------+| Query_ID | Duration   | Query                                                                           |+----------+------------+---------------------------------------------------------------------------------+|       87 | 0.11941700 | SELECT * FROM employees.employees WHERE first_name&#x3D;&#39;Eric&#39; AND last_name&#x3D;&#39;Anido&#39; ||       90 | 0.00092400 | SELECT * FROM employees.employees WHERE first_name&#x3D;&#39;Eric&#39; AND last_name&#x3D;&#39;Anido&#39; |+----------+------------+---------------------------------------------------------------------------------+</span><br></pre></td></tr></table></figure><p>性能的提升是显著的，查询速度提高了120多倍。</p><p>前缀索引兼顾索引大小和查询速度，但是其缺点是不能用于ORDER BY和GROUP BY操作，也不能用于Covering index（即当索引本身包含查询所需全部数据时，不再访问数据文件本身）。</p><h2 id="InnoDB%E7%9A%84%E4%B8%BB%E9%94%AE%E9%80%89%E6%8B%A9%E4%B8%8E%E6%8F%92%E5%85%A5%E4%BC%98%E5%8C%96"><a class="header-anchor" href="#InnoDB%E7%9A%84%E4%B8%BB%E9%94%AE%E9%80%89%E6%8B%A9%E4%B8%8E%E6%8F%92%E5%85%A5%E4%BC%98%E5%8C%96">¶</a> InnoDB的主键选择与插入优化</h2><p>在使用InnoDB存储引擎时，如果没有特别的需要，请永远使用一个与业务无关的自增字段作为主键。</p><p>经常看到有帖子或博客讨论主键选择问题，有人建议使用业务无关的自增主键，有人觉得没有必要，完全可以使用如学号或身份证号这种唯一字段作为主键。不论支持哪种论点，大多数论据都是业务层面的。如果从数据库索引优化角度看，使用InnoDB引擎而不使用自增主键绝对是一个糟糕的主意。</p><p>上文讨论过InnoDB的索引实现，InnoDB使用聚集索引，数据记录本身被存于主索引（一颗B+Tree）的叶子节点上。这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放，因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB默认为15/16），则开辟一个新的页（节点）。</p><p>如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。如下图所示：</p><p><img src="/2020/11/05/MySQL%E7%B4%A2%E5%BC%95%E8%83%8C%E5%90%8E%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/13.png" alt="img"></p><p align="center">图13</p><p>这样就会形成一个紧凑的索引结构，近似顺序填满。由于每次插入时也不需要移动已有数据，因此效率很高，也不会增加很多开销在维护索引上。</p><p>如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置：</p><p><img src="/2020/11/05/MySQL%E7%B4%A2%E5%BC%95%E8%83%8C%E5%90%8E%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/14.png" alt="img"></p><p align="center">图14</p><p>此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。</p><p>因此，只要可以，请尽量在InnoDB上采用自增字段做主键。</p><h1 id="%E5%90%8E%E8%AE%B0"><a class="header-anchor" href="#%E5%90%8E%E8%AE%B0">¶</a> 后记</h1><p>这篇文章断断续续写了半个月，主要内容就是上面这些了。不可否认，这篇文章在一定程度上有纸上谈兵之嫌，因为我本人对MySQL的使用属于菜鸟级别，更没有太多数据库调优的经验，在这里大谈数据库索引调优有点大言不惭。就当是我个人的一篇学习笔记了。</p><p>其实数据库索引调优是一项技术活，不能仅仅靠理论，因为实际情况千变万化，而且MySQL本身存在很复杂的机制，如查询优化策略和各种引擎的实现差异等都会使情况变得更加复杂。但同时这些理论是索引调优的基础，只有在明白理论的基础上，才能对调优策略进行合理推断并了解其背后的机制，然后结合实践中不断的实验和摸索，从而真正达到高效使用MySQL索引的目的。</p><p>另外，MySQL索引及其优化涵盖范围非常广，本文只是涉及到其中一部分。如与排序（ORDER BY）相关的索引优化及覆盖索引（Covering index）的话题本文并未涉及，同时除B-Tree索引外MySQL还根据不同引擎支持的哈希索引、全文索引等等本文也并未涉及。如果有机会，希望再对本文未涉及的部分进行补充吧。</p><h1 id="%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE"><a class="header-anchor" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE">¶</a> 参考文献</h1><p>[1] Baron Scbwartz等 著，王小东等 译；高性能MySQL（High Performance MySQL）；电子工业出版社，2010</p><p>[2] Michael Kofler 著，杨晓云等 译；MySQL5权威指南（The Definitive Guide to MySQL5）；人民邮电出版社，2006</p><p>[3] 姜承尧 著；MySQL技术内幕-InnoDB存储引擎；机械工业出版社，2011</p><p>[4] D Comer, Ubiquitous B-tree; ACM Computing Surveys (CSUR), 1979</p><p>[5] Codd, E. F. (1970). “A relational model of data for large shared data banks”. Communications of the ACM, , Vol. 13, No. 6, pp. 377-387</p><p>[6] MySQL5.1参考手册 - <a href="http://dev.mysql.com/doc/refman/5.1/zh/index.html">http://dev.mysql.com/doc/refman/5.1/zh/index.html</a></p><blockquote><p>原文链接：<a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">http://blog.codinglabs.org/articles/theory-of-mysql-index.html</a></p><p>作者：张洋</p></blockquote><script>    let imgs = document.getElementsByTagName('img');    for (let img of imgs) {        img.setAttribute('class', 'fancybox center-block');    }</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.6.0/katex.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;%E6%91%98%E8%A6%81&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#%E6%91%98%E8%A6%81&quot;&gt;¶&lt;/a&gt; 摘要&lt;/h1&gt;
&lt;p&gt;本文以MySQL数据库为研究对象，讨论与数据库索引相关的一些话题。特别需要说明的是，M</summary>
      
    
    
    
    <category term="数据库" scheme="http://lampkins.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="MySQL性能优化" scheme="http://lampkins.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
    <category term="MySQL" scheme="http://lampkins.gitee.io/tags/MySQL/"/>
    
    <category term="索引" scheme="http://lampkins.gitee.io/tags/%E7%B4%A2%E5%BC%95/"/>
    
    <category term="B树" scheme="http://lampkins.gitee.io/tags/B%E6%A0%91/"/>
    
    <category term="B+树" scheme="http://lampkins.gitee.io/tags/B-%E6%A0%91/"/>
    
    <category term="优化" scheme="http://lampkins.gitee.io/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Java锁机制</title>
    <link href="http://lampkins.gitee.io/2020/11/05/Java%E9%94%81%E6%9C%BA%E5%88%B6/"/>
    <id>http://lampkins.gitee.io/2020/11/05/Java%E9%94%81%E6%9C%BA%E5%88%B6/</id>
    <published>2020-11-05T03:14:56.000Z</published>
    <updated>2020-11-05T03:38:51.516Z</updated>
    
    <content type="html"><![CDATA[<p>对程序员来说并发编程是一个编程难点，Java的锁机制也尤为重要。</p><hr><h2 id="%E4%BB%80%E4%B9%88%E6%98%AF%E9%94%81%EF%BC%9F"><a class="header-anchor" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%94%81%EF%BC%9F">¶</a> 什么是锁？</h2><p>​在并发环境下，多个线程会对同一个资源进行争夺，这就可能导致数据不一致的问题，由此，很多编程语言引入了锁机制，用于<strong>保证业务执行过程中数据被锁住不会被外界修改</strong>。</p><p><img src="/2020/11/05/Java%E9%94%81%E6%9C%BA%E5%88%B6/image-20201104114411967-1604547521437.png" alt="image-20201104114411967"></p><h2 id="Java%E9%94%81%E6%9C%BA%E5%88%B6"><a class="header-anchor" href="#Java%E9%94%81%E6%9C%BA%E5%88%B6">¶</a> Java锁机制</h2><p>Java虚拟机运行时内存结构</p><p><img src="/2020/11/05/Java%E9%94%81%E6%9C%BA%E5%88%B6/image-20201104172515315-1604547521437.png" alt="image-20201104172515315"></p><h3 id="Object%E5%AF%B9%E8%B1%A1"><a class="header-anchor" href="#Object%E5%AF%B9%E8%B1%A1">¶</a> Object对象</h3><p>​每个Object，也就是每个对象都拥有一把锁，其存放在对象头中，锁中记录了当前对象被那个线程锁占用，对象大致结构如下：</p><p><img src="/2020/11/05/Java%E9%94%81%E6%9C%BA%E5%88%B6/image-20201104174242572-1604547521438.png" alt="image-20201104174242572"></p><ul><li>Class Point：指向当前对象类型所在方法区的类型数据</li><li>Mark Word: 存储和当前对象运行状态相关的数据，主要用来<strong>表示对象的线程锁状态</strong>，也可用于配合GC、存放对象的hashcode</li></ul><p><img src="/2020/11/05/Java%E9%94%81%E6%9C%BA%E5%88%B6/image-20201104174207757-1604547521438.png" alt="image-20201104174207757"></p><h3 id="%E5%9B%9B%E7%A7%8D%E9%94%81%E7%8A%B6%E6%80%81"><a class="header-anchor" href="#%E5%9B%9B%E7%A7%8D%E9%94%81%E7%8A%B6%E6%80%81">¶</a> 四种锁状态</h3><p><strong>无锁 --&gt; 偏向锁 --&gt; 轻量级锁 --&gt; 重量级锁，<mark>只能升级不能降级</mark></strong></p><h3 id="%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81"><a class="header-anchor" href="#%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81">¶</a> 重量级锁</h3><p><strong>synchronized</strong></p><p>​<mark>同步线程</mark>，其被编译后，会生成<code>monitorenter</code>和<code>monitorexit</code></p><p>​性能问题：mutex lock，Java线程实际是对操作系统线程的映射，因此每次挂起或唤醒一个线程时都要切换操作系统内核态，过于重量级</p><p>在Java 6 中对synchronized进行了优化，引入了轻量级锁和偏向锁</p><h3 id="%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81"><a class="header-anchor" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81">¶</a> 轻量级锁</h3><p>​当线程检查到对象的锁为轻量级锁时，其会在自己的虚拟机栈中开辟一块<strong>Lock Record</strong>的空间，用于<strong>存放MarkWord的副本和owner指针</strong>。</p><p>​<strong>线程和对象锁绑定：</strong> 当线程通过CAS操作获取到对象的锁后，会把对象头中的Markword复制到开辟的LockRecord空间中，并把owner指针指向该对象，而对象头中的前30bit也将生成一个指针指向该LockRecord，这便完成了绑定。</p><p><img src="/2020/11/05/Java%E9%94%81%E6%9C%BA%E5%88%B6/image-20201104232841593-1604547521438.png" alt="image-20201104232841593"></p><h4 id="%E8%87%AA%E6%97%8B%E9%94%81"><a class="header-anchor" href="#%E8%87%AA%E6%97%8B%E9%94%81">¶</a> 自旋锁</h4><p>​如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要<strong>自旋等待</strong>， 等持有锁的线程释放锁后即可立即获取锁，这样就<mark>避免用户线程和内核的切换的消耗</mark>。当自旋线程过多或自旋次数(<code>-XX:PreBlockSpin</code>)过多，则会升级为重量级锁。</p><h4 id="%E9%80%82%E5%BA%94%E6%80%A7%E8%87%AA%E6%97%8B%E9%94%81"><a class="header-anchor" href="#%E9%80%82%E5%BA%94%E6%80%A7%E8%87%AA%E6%97%8B%E9%94%81">¶</a> 适应性自旋锁</h4><p>​如果某个线程最近获取过锁，那么它的自旋次数则可以更多，反之，若其很少能够自旋成功，则其自旋次数会大大减少甚至去除自旋过程，以避免资源浪费。</p><h3 id="%E5%81%8F%E5%90%91%E9%94%81"><a class="header-anchor" href="#%E5%81%8F%E5%90%91%E9%94%81">¶</a> 偏向锁</h3><p>​大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次获得。因此，在线程无竞争时，偏向锁会偏向于第一个访问它的线程，<mark>消除该线程重入(CAS置换ThreadID)的开销</mark>，当后一个线程进入如果获取不到锁，则会在前一个线程的安全点暂停，然后后个线程将锁升级为轻量级锁。</p><p>​作用：提高单线程访问同步资源的性能，如果一直是多线程访问的，那么升级偏向锁也是额外开销，可通过<code>-XX:-UseBiasedLocking</code>关闭偏向锁。</p><blockquote><p><a href="https://blog.csdn.net/weixin_42213903/article/details/97044043">Java偏向锁</a></p></blockquote><h3 id="%E6%97%A0%E9%94%81"><a class="header-anchor" href="#%E6%97%A0%E9%94%81">¶</a> 无锁</h3><p>所有线程都可访问共享资源</p><p>场景：</p><ul><li><p>不在多线程环境，或多线程无竞争</p></li><li><p>存在竞争，用无锁方式同步线程</p><ul><li><p>CAS (Compare and Swap)</p><p>CAS在操作系统通过一条指令实现，是保证原子性的。</p><p>CAS算法大致过程：三个参数，CAS(V, E, N)，V：要更新的变量(内存地址)，E：旧的预期值，N：新值。当且仅当V值等于E值时，才会将V的值设为N，如果不同，则什么也不做</p><p>缺点：循环时间CPU开销大，只能保证单个变量的原子性，ABA问题</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CASTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicBoolean value = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CASTest casTest = <span class="keyword">new</span> CASTest();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(casTest);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(casTest);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value.compareAndSet(<span class="keyword">true</span>, <span class="keyword">false</span>)) &#123;</span><br><span class="line">            System.out.print(Thread.currentThread().getName()+<span class="string">&quot;, &quot;</span>+value.get());</span><br><span class="line">            i++;</span><br><span class="line">            System.out.println(<span class="string">&quot;; i: &quot;</span> + i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            value.set(<span class="keyword">true</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;500ms后重试:&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">--------------------------</span><br><span class="line">Thread-<span class="number">0</span>, <span class="keyword">false</span>; i: <span class="number">1</span></span><br><span class="line"><span class="number">500</span>ms后重试:Thread-<span class="number">1</span></span><br><span class="line"><span class="number">500</span>ms后重试:Thread-<span class="number">1</span></span><br><span class="line"><span class="number">500</span>ms后重试:Thread-<span class="number">1</span></span><br><span class="line"><span class="number">500</span>ms后重试:Thread-<span class="number">1</span></span><br><span class="line"><span class="number">500</span>ms后重试:Thread-<span class="number">1</span></span><br><span class="line"><span class="number">500</span>ms后重试:Thread-<span class="number">1</span></span><br><span class="line"><span class="number">500</span>ms后重试:Thread-<span class="number">1</span></span><br><span class="line"><span class="number">500</span>ms后重试:Thread-<span class="number">1</span></span><br><span class="line"><span class="number">500</span>ms后重试:Thread-<span class="number">1</span></span><br><span class="line"><span class="number">500</span>ms后重试:Thread-<span class="number">1</span></span><br><span class="line">Thread-<span class="number">1</span>, <span class="keyword">false</span>; i: <span class="number">2</span></span><br></pre></td></tr></table></figure><script>    let imgs = document.getElementsByTagName('img');    for (let img of imgs) {        img.setAttribute('class', 'fancybox');    }</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.6.0/katex.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;对程序员来说并发编程是一个编程难点，Java的锁机制也尤为重要。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;%E4%BB%80%E4%B9%88%E6%98%AF%E9%94%81%EF%BC%9F&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#%E4%BB%8</summary>
      
    
    
    
    <category term="Java" scheme="http://lampkins.gitee.io/categories/Java/"/>
    
    
    <category term="Java锁" scheme="http://lampkins.gitee.io/tags/Java%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>MySQL性能优化07：性能优化篇</title>
    <link href="http://lampkins.gitee.io/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9607/"/>
    <id>http://lampkins.gitee.io/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9607/</id>
    <published>2020-10-26T12:57:54.000Z</published>
    <updated>2020-11-05T11:41:08.594Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL 性能优化手段</p><hr><h1 id="MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%AF%87"><a class="header-anchor" href="#MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%AF%87">¶</a> MySQL性能优化篇</h1><h2 id="%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B1%82%E9%9D%A2%E4%BC%98%E5%8C%96"><a class="header-anchor" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B1%82%E9%9D%A2%E4%BC%98%E5%8C%96">¶</a> 服务器层面优化</h2><h3 id="%E5%B0%86%E6%95%B0%E6%8D%AE%E4%BF%9D%E5%AD%98%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%EF%BC%8C%E4%BF%9D%E8%AF%81%E4%BB%8E%E5%86%85%E5%AD%98%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE"><a class="header-anchor" href="#%E5%B0%86%E6%95%B0%E6%8D%AE%E4%BF%9D%E5%AD%98%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%EF%BC%8C%E4%BF%9D%E8%AF%81%E4%BB%8E%E5%86%85%E5%AD%98%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE">¶</a> 将数据保存在内存中，保证从内存读取数据</h3><ul><li><p>设置足够大的 <code>innodb_buffer_pool_size</code> ，将数据读取到内存中。</p><p><mark>建议<code>innodb_buffer_pool_size</code>设置为总内存大小的3/4或者4/5.</mark></p></li><li><p>怎样确定 <code>innodb_buffer_pool_size</code> 足够大。数据是从内存读取而不是硬盘？</p></li></ul><p><img src="/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9607/image-20201030182222685.png" alt="image-20201030182222685"></p><h3 id="%E5%86%85%E5%AD%98%E9%A2%84%E7%83%AD"><a class="header-anchor" href="#%E5%86%85%E5%AD%98%E9%A2%84%E7%83%AD">¶</a> 内存预热</h3><p>将磁盘数据在MySQL Server启动的时候就读取到内存中</p><h3 id="%E9%99%8D%E4%BD%8E%E7%A3%81%E7%9B%98%E5%86%99%E5%85%A5%E6%AC%A1%E6%95%B0"><a class="header-anchor" href="#%E9%99%8D%E4%BD%8E%E7%A3%81%E7%9B%98%E5%86%99%E5%85%A5%E6%AC%A1%E6%95%B0">¶</a> 降低磁盘写入次数</h3><ul><li><p>对于生产环境来说，很多日志是不需要开启的，比如：<strong>通用查询日志、慢查询日志、错误日志</strong></p></li><li><p>使用足够大的写入缓存 <strong><code>innodb_log_file_size</code></strong></p><p><mark>推荐 innodb_log_file_size 设置为 0.25 * innodb_buffer_pool_size</mark></p></li><li><p>设置合适的**<code>innodb_flush_log_at_trx_commit</code>**，和日志落盘有关系。</p></li></ul><h3 id="%E6%8F%90%E9%AB%98%E7%A3%81%E7%9B%98%E8%AF%BB%E5%86%99"><a class="header-anchor" href="#%E6%8F%90%E9%AB%98%E7%A3%81%E7%9B%98%E8%AF%BB%E5%86%99">¶</a> 提高磁盘读写</h3><ul><li>可以考虑使用SSD硬盘，不过得考虑成本是否合适。</li></ul><h2 id="SQL%E8%AE%BE%E8%AE%A1%E5%B1%82%E9%9D%A2%E4%BC%98%E5%8C%96"><a class="header-anchor" href="#SQL%E8%AE%BE%E8%AE%A1%E5%B1%82%E9%9D%A2%E4%BC%98%E5%8C%96">¶</a> SQL设计层面优化</h2><p><strong>面对人群：</strong> 懂技术并且了解需求的程序员。</p><p><strong>具体优化方案如下：</strong></p><ul><li><p><strong>设计中间表</strong>，一般针对于<strong>统计分析</strong>功能，或者实时性不高的需求（OLTP、OLAP）</p></li><li><p>为减少关联查询，创建合理的<strong>冗余字段</strong>（考虑数据库的三范式和查询性能的取舍，创建冗余字段还需要注意<strong>数据一致性问题</strong>）</p></li><li><p>对于字段太多的大表，考虑<strong>垂直拆表</strong>（比如一个表有100多个字段）</p></li><li><p>对于表中经常不被使用的字段或者存储数据比较多的字段，考虑拆表（比如商品表中会存储商品介绍，此时可 以将商品介绍字段单独拆解到另一个表中，使用商品ID关联）</p></li><li><p>每张表建议都要有一个主键（<strong>主键索引</strong>），而且主键类型最好是<strong>int类型</strong>，建议自增主键（<strong>不考虑分布式系统 的情况下</strong>）。</p></li><li><p><strong>分库分表</strong></p><p>数据库分表可以解决单表海量数据的查询性能问题，分库可以解决单台数据库的并发访问压力问题。</p><p>一种常见的路由策略如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">中间变量　＝ user_id%（库数量*每个库的表数量）;</span><br><span class="line">库序号　＝　取整（中间变量／每个库的表数量）;</span><br><span class="line">表序号　＝　中间变量％每个库的表数量;</span><br></pre></td></tr></table></figure><p>例子：数据库有256 个，每一个库中有1024个数据表，用户的user_id＝262145，按照上述的路由策略，则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">中间变量　＝ 262145%（256*1024）&#x3D; 1;</span><br><span class="line">库序号　＝　取整（1／1024）&#x3D; 0;</span><br><span class="line">表序号　＝　1％1024 &#x3D; 1;</span><br></pre></td></tr></table></figure><p>对于user_id＝262145，其将被路由到第０个数据库的第１个表中。</p></li></ul><h2 id="SQL%E8%AF%AD%E5%8F%A5%E4%BC%98%E5%8C%96%EF%BC%88%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%EF%BC%89"><a class="header-anchor" href="#SQL%E8%AF%AD%E5%8F%A5%E4%BC%98%E5%8C%96%EF%BC%88%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%EF%BC%89">¶</a> SQL语句优化（开发人员）</h2><h3 id="%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96"><a class="header-anchor" href="#%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96">¶</a> 索引优化</h3><ul><li><p>为搜索字段（<strong>where中的条件</strong>）、排序字段、select查询列，创建合适的索引，不过要考虑数据的业务场景： 查询多还是增删多？</p></li><li><p>尽量建立<strong>组合索引</strong>并注意组合索引的创建顺序，按照顺序组织查询条件、尽量将筛选粒度大的查询条件放到最 左边。</p></li><li><p><strong>尽量使用覆盖索引</strong>，SELECT语句中尽量不要使用*。</p></li><li><p>order by、group by语句要尽量使用到索引</p></li></ul><h3 id="%E5%85%B6%E4%BB%96%E4%BC%98%E5%8C%96"><a class="header-anchor" href="#%E5%85%B6%E4%BB%96%E4%BC%98%E5%8C%96">¶</a> 其他优化</h3><ul><li><p>尽量不使用count(*)、尽量使用count（主键）</p><ul><li><p><strong>COUNT(*) ：</strong> 查询行数，是会遍历所有的行、所有的列。</p></li><li><p><strong>COUNT(列)：</strong> 查询指定列不为null的行数（过滤null），如果列可以为空，则COUNT(*)不等于 COUNT(列)，除非指定的列是非空的列才会让COUNT(*)等于COUNT(列)</p></li><li><p><strong>COUNT(伪列)：</strong> 比如COUNT(1)</p></li></ul></li><li><p>JOIN两张表的关联字段最好都建立索引，而且最好字段类型是一样的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM orders o LEFT JOIN user u on o.user_id &#x3D; u.id</span><br><span class="line">-- orders表中的user_id和user表中的id，类型要一致</span><br></pre></td></tr></table></figure></li><li><p>WHERE条件中尽量不要使用1=1、not in语句（建议使用not exists）</p></li><li><p>不用 MYSQL 内置的函数，因为内置函数不会建立查询缓存。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- SQL查询语句和查询结果都会在第一次查询只会存储到MySQL的查询缓存中，如果需要获取到查询缓存中的查询结果，查询的SQL语句必须和第一次的查询SQL语句一致。</span><br><span class="line">SELECT * FROM user where birthday &#x3D; now();</span><br></pre></td></tr></table></figure></li><li><p>合理利用慢查询日志、explain执行计划查询、show profile查看SQL执行时的资源使用情况。</p></li></ul><hr><blockquote><p><a href="http://lampkins.gitee.io/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9601/">MySQL性能优化01：主题和目标</a></p><p><a href="http://lampkins.gitee.io/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9602/">MySQL性能优化02：MySQL架构篇</a></p><p><a href="http://lampkins.gitee.io/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9603/">MySQL性能优化03：MySQL性能分析篇</a></p><p><a href="http://lampkins.gitee.io/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9604/">MySQL性能优化04：MySQL索引篇01索引讲解</a></p><p><a href="http://lampkins.gitee.io/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9605/">MySQL性能优化05：MySQL索引篇02查看执行计划</a></p><p><a href="http://lampkins.gitee.io/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9606/">MySQL性能优化06：MySQL索引篇03索引失效分析</a></p><p><a href="http://lampkins.gitee.io/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9607/">MySQL性能优化07：性能优化篇</a></p></blockquote><script>    let imgs = document.getElementsByTagName('img');    for (let img of imgs) {        img.setAttribute('class', 'fancybox');    }</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.6.0/katex.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;MySQL 性能优化手段&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%AF%87&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#MySQL%E6%80%A7%E8%83%BD</summary>
      
    
    
    
    <category term="数据库" scheme="http://lampkins.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="MySQL性能优化" scheme="http://lampkins.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
    <category term="MySQL" scheme="http://lampkins.gitee.io/tags/MySQL/"/>
    
    <category term="索引" scheme="http://lampkins.gitee.io/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>MySQL性能优化06：MySQL索引篇03</title>
    <link href="http://lampkins.gitee.io/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9606/"/>
    <id>http://lampkins.gitee.io/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9606/</id>
    <published>2020-10-26T12:57:44.000Z</published>
    <updated>2020-10-30T13:49:23.764Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL 索引失效分析</p><hr><h1 id="MySQL%E7%B4%A2%E5%BC%95%E7%AF%87"><a class="header-anchor" href="#MySQL%E7%B4%A2%E5%BC%95%E7%AF%87">¶</a> MySQL索引篇</h1><h2 id="%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E5%88%86%E6%9E%90"><a class="header-anchor" href="#%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E5%88%86%E6%9E%90">¶</a> 索引失效分析</h2><h3 id="%E6%A1%88%E5%88%97%E7%8E%AF%E5%A2%83"><a class="header-anchor" href="#%E6%A1%88%E5%88%97%E7%8E%AF%E5%A2%83">¶</a> 案列环境</h3><p><img src="/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9606/image-20201030162050575.png" alt="image-20201030162050575"></p><h3 id="%E6%A1%88%E5%88%97%E6%BC%94%E7%A4%BA"><a class="header-anchor" href="#%E6%A1%88%E5%88%97%E6%BC%94%E7%A4%BA">¶</a> 案列演示</h3><h4 id="1.%20%E5%85%A8%E5%80%BC%E5%8C%B9%E9%85%8D%E6%88%91%E6%9C%80%E7%88%B1"><a class="header-anchor" href="#1.%20%E5%85%A8%E5%80%BC%E5%8C%B9%E9%85%8D%E6%88%91%E6%9C%80%E7%88%B1">¶</a> 1. 全值匹配我最爱</h4><p><img src="/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9606/image-20201030162437803.png" alt="image-20201030162437803"></p><h4 id="2.%20%E6%9C%80%E4%BD%B3%E5%B7%A6%E5%89%8D%E7%BC%80%E6%B3%95%E5%88%99"><a class="header-anchor" href="#2.%20%E6%9C%80%E4%BD%B3%E5%B7%A6%E5%89%8D%E7%BC%80%E6%B3%95%E5%88%99">¶</a> 2. 最佳左前缀法则</h4><p><mark>带头索引不能死，中间索引不能断</mark></p><p>如果索引包含了多个列，要遵守最佳左前缀法则。指的是查询从索引的最左前列开始并且不跳过索引中的列。 正确的示例参考上图。</p><p><strong>错误的示例：</strong></p><p>带头索引死：</p><p><img src="/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9606/image-20201030162614385.png" alt="image-20201030162614385"></p><p>中间索引断（带头索引生效，其他索引失效）：</p><p><img src="/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9606/image-20201030162625737.png" alt="image-20201030162625737"></p><h4 id="3.%20%E4%B8%8D%E8%A6%81%E5%9C%A8%E7%B4%A2%E5%BC%95%E4%B8%8A%E5%81%9A%E8%AE%A1%E7%AE%97"><a class="header-anchor" href="#3.%20%E4%B8%8D%E8%A6%81%E5%9C%A8%E7%B4%A2%E5%BC%95%E4%B8%8A%E5%81%9A%E8%AE%A1%E7%AE%97">¶</a> 3. 不要在索引上做计算</h4><p>不要进行这些操作：计算、函数、自动/手动类型转换，不然会导致索引失效而转向全表扫描。</p><p><img src="/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9606/image-20201030162823627.png" alt="image-20201030162823627"></p><h4 id="4.%20%E8%8C%83%E5%9B%B4%E6%9D%A1%E4%BB%B6%E5%8F%B3%E8%BE%B9%E7%9A%84%E5%88%97%E5%A4%B1%E6%95%88"><a class="header-anchor" href="#4.%20%E8%8C%83%E5%9B%B4%E6%9D%A1%E4%BB%B6%E5%8F%B3%E8%BE%B9%E7%9A%84%E5%88%97%E5%A4%B1%E6%95%88">¶</a> 4. 范围条件右边的列失效</h4><p>不能继续使用索引中范围条件（bettween、&lt;、&gt;、in等）右边的列。</p><p><img src="/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9606/image-20201030162912901.png" alt="image-20201030162912901"></p><h4 id="5.%20%E5%B0%BD%E9%87%8F%E4%BD%BF%E7%94%A8%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95"><a class="header-anchor" href="#5.%20%E5%B0%BD%E9%87%8F%E4%BD%BF%E7%94%A8%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95">¶</a> 5. 尽量使用覆盖索引</h4><p>尽量使用覆盖索引，只访问索引的查询，也就是索引列和查询列一致，减少select *。</p><p><img src="/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9606/image-20201030163100423.png" alt="image-20201030163100423"></p><h4 id="6.%20%E7%B4%A2%E5%BC%95%E5%AD%97%E6%AE%B5%E4%B8%8A%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8%E4%B8%8D%E7%AD%89"><a class="header-anchor" href="#6.%20%E7%B4%A2%E5%BC%95%E5%AD%97%E6%AE%B5%E4%B8%8A%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8%E4%B8%8D%E7%AD%89">¶</a> 6. 索引字段上不要使用不等</h4><p>MySQL在索引字段上使用（！= 或者 &lt; &gt;）判断时，会导致索引失效而转向全表扫描。</p><p><img src="/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9606/image-20201030163154310.png" alt="image-20201030163154310"></p><h4 id="7.%20%E7%B4%A2%E5%BC%95%E5%AD%97%E6%AE%B5%E4%B8%8A%E4%B8%8D%E8%A6%81%E5%88%A4%E6%96%ADnull"><a class="header-anchor" href="#7.%20%E7%B4%A2%E5%BC%95%E5%AD%97%E6%AE%B5%E4%B8%8A%E4%B8%8D%E8%A6%81%E5%88%A4%E6%96%ADnull">¶</a> 7. 索引字段上不要判断null</h4><p>索引字段上使用 is null / is not null 判断时，会导致索引失效而转向全表扫描。</p><p><img src="/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9606/image-20201030163214283.png" alt="image-20201030163214283"></p><h4 id="8.%20%E7%B4%A2%E5%BC%95%E5%AD%97%E6%AE%B5%E4%BD%BF%E7%94%A8like%E4%B8%8D%E4%BB%A5%E9%80%9A%E9%85%8D%E7%AC%A6%E5%BC%80%E5%A4%B4"><a class="header-anchor" href="#8.%20%E7%B4%A2%E5%BC%95%E5%AD%97%E6%AE%B5%E4%BD%BF%E7%94%A8like%E4%B8%8D%E4%BB%A5%E9%80%9A%E9%85%8D%E7%AC%A6%E5%BC%80%E5%A4%B4">¶</a> 8. 索引字段使用like不以通配符开头</h4><p>索引字段使用like以通配符开头（‘%字符串’）时，会导致索引失效而转向全表扫描。</p><p><img src="/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9606/image-20201030163236366.png" alt="image-20201030163236366"></p><p>由结果可知，like以通配符结束相当于范围查找，索引不会失效。与范围条件（bettween、&lt;、&gt;、in等）不同的 是其不会导致右边的索引失效。</p><p>**问题：解决like ‘%字符串%’时，索引失效问题的方法？ **</p><p>使用覆盖索引可以解决。</p><p><img src="/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9606/image-20201030163725512.png" alt="image-20201030163725512"></p><h4 id="9.%20%E7%B4%A2%E5%BC%95%E5%AD%97%E6%AE%B5%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A6%81%E5%8A%A0%E5%8D%95%E5%BC%95%E5%8F%B7"><a class="header-anchor" href="#9.%20%E7%B4%A2%E5%BC%95%E5%AD%97%E6%AE%B5%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A6%81%E5%8A%A0%E5%8D%95%E5%BC%95%E5%8F%B7">¶</a> 9. 索引字段字符串要加单引号</h4><p>索引字段是字符串，但查询时不加单引号，会导致索引失效而转向全表扫描。</p><p><img src="/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9606/image-20201030170720867.png" alt="image-20201030170720867"></p><h4 id="10.%20%E7%B4%A2%E5%BC%95%E5%AD%97%E6%AE%B5%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8or"><a class="header-anchor" href="#10.%20%E7%B4%A2%E5%BC%95%E5%AD%97%E6%AE%B5%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8or">¶</a> 10. 索引字段不要使用or</h4><p>索引字段使用 or 时，会导致索引失效而转向全表扫描。</p><p><img src="/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9606/image-20201030170736156.png" alt="image-20201030170736156"></p><h3 id="%E6%80%BB%E7%BB%93"><a class="header-anchor" href="#%E6%80%BB%E7%BB%93">¶</a> 总结</h3><blockquote><p>假设index(a, b, c)</p></blockquote><table><thead><tr><th style="text-align:left">Where语句</th><th style="text-align:left">索引是否被使用</th></tr></thead><tbody><tr><td style="text-align:left">where a=3</td><td style="text-align:left">Y, 使用到a</td></tr><tr><td style="text-align:left">where a=3 and b=5</td><td style="text-align:left">Y, 使用到a, b</td></tr><tr><td style="text-align:left">where a=3 and b=5 and c=4</td><td style="text-align:left">Y, 使用到a, b, c</td></tr><tr><td style="text-align:left">where b=3 或者<br>where b=3 and c=4 或者<br>where c=4</td><td style="text-align:left">N</td></tr><tr><td style="text-align:left">where a=3 and c=5</td><td style="text-align:left">使用到a，但c不行，因为b中间断了</td></tr><tr><td style="text-align:left">where a=3 and b&gt;4 and c=5</td><td style="text-align:left">使用到a和b，c不能用在范围之后，b断了</td></tr><tr><td style="text-align:left">where a=3 and b like ‘kk%’ and c=4</td><td style="text-align:left">Y, 使用到a, b, c</td></tr><tr><td style="text-align:left">where a=3 and b like ‘%kk’ and c=4</td><td style="text-align:left">Y, 只用到a</td></tr><tr><td style="text-align:left">where a=3 and b like ‘%kk%’ and c=4</td><td style="text-align:left">Y, 只用到a</td></tr><tr><td style="text-align:left">where a=3 and b like ‘k%kk%’ and c=4</td><td style="text-align:left">Y, 使用到a, b, c</td></tr></tbody></table><blockquote><p><strong>口诀</strong></p></blockquote><p><strong>全值匹配我最爱，最左前缀要遵守；</strong><br><strong>带头大哥不能死，中间兄弟不能断；</strong><br><strong>索引列上少计算，范围之后全失效；</strong><br><strong>LIKE百分写最右，覆盖索引不写星；</strong><br><strong>不等空值还有or，索引失效要少用。</strong></p><hr><blockquote><p><a href="http://lampkins.gitee.io/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9601/">MySQL性能优化01：主题和目标</a></p><p><a href="http://lampkins.gitee.io/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9602/">MySQL性能优化02：MySQL架构篇</a></p><p><a href="http://lampkins.gitee.io/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9603/">MySQL性能优化03：MySQL性能分析篇</a></p><p><a href="http://lampkins.gitee.io/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9604/">MySQL性能优化04：MySQL索引篇01索引讲解</a></p><p><a href="http://lampkins.gitee.io/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9605/">MySQL性能优化05：MySQL索引篇02查看执行计划</a></p><p><a href="http://lampkins.gitee.io/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9606/">MySQL性能优化06：MySQL索引篇03索引失效分析</a></p><p><a href="http://lampkins.gitee.io/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9607/">MySQL性能优化07：性能优化篇</a></p></blockquote><script>    let imgs = document.getElementsByTagName('img');    for (let img of imgs) {        img.setAttribute('class', 'fancybox');    }</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.6.0/katex.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;MySQL 索引失效分析&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;MySQL%E7%B4%A2%E5%BC%95%E7%AF%87&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#MySQL%E7%B4%A2%E5%BC%95%E7%AF%87&quot;&gt;¶&lt;/a&gt; M</summary>
      
    
    
    
    <category term="数据库" scheme="http://lampkins.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="MySQL性能优化" scheme="http://lampkins.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
    <category term="MySQL" scheme="http://lampkins.gitee.io/tags/MySQL/"/>
    
    <category term="索引" scheme="http://lampkins.gitee.io/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>MySQL性能优化05：MySQL索引篇02</title>
    <link href="http://lampkins.gitee.io/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9605/"/>
    <id>http://lampkins.gitee.io/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9605/</id>
    <published>2020-10-26T12:57:34.000Z</published>
    <updated>2020-10-30T13:48:43.154Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL Explain查看执行计划</p><hr><h1 id="MySQL%E7%B4%A2%E5%BC%95%E7%AF%87"><a class="header-anchor" href="#MySQL%E7%B4%A2%E5%BC%95%E7%AF%87">¶</a> MySQL索引篇</h1><h2 id="%E6%9F%A5%E7%9C%8B%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92"><a class="header-anchor" href="#%E6%9F%A5%E7%9C%8B%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92">¶</a> 查看执行计划</h2><h3 id="%E5%BB%BA%E8%A1%A8%E8%AF%AD%E5%8F%A5"><a class="header-anchor" href="#%E5%BB%BA%E8%A1%A8%E8%AF%AD%E5%8F%A5">¶</a> 建表语句</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">create table &#96;t_user&#96;(</span><br><span class="line">id int primary key,</span><br><span class="line">    name varchar(100),</span><br><span class="line">    age int,</span><br><span class="line">    sex char(1),</span><br><span class="line">    address varchar(100)</span><br><span class="line">);</span><br><span class="line">create table &#96;t_user_role&#96; (</span><br><span class="line">    uid int,</span><br><span class="line">    rid int</span><br><span class="line">);</span><br><span class="line">alter table &#96;t_user&#96; add index idx_name_age(name(10), age);</span><br><span class="line">alter table &#96;t_user&#96; add index idx_sex(sex);</span><br><span class="line"></span><br><span class="line">insert into &#96;t_user&#96;(id,name,age,sex,address) values(1, &#39;zhangsan&#39;, 20, &#39;0&#39;, &#39;成都&#39;);</span><br><span class="line">insert into &#96;t_user&#96;(id,name,age,sex,address) values(2, &#39;lisi&#39;, 30, &#39;0&#39;, &#39;成都&#39;);</span><br><span class="line">insert into &#96;t_user&#96;(id,name,age,sex,address) values(3, &#39;lihong&#39;, 25, &#39;1&#39;, &#39;成都&#39;);</span><br><span class="line"></span><br><span class="line">insert into &#96;t_user_role&#96;(uid, rid) values(1, 1);</span><br></pre></td></tr></table></figure><p>特别说明：</p><p><mark>name列的长度是varchar(100)，但是创建索引的时候，指定的长度却是10，这是使用了<a href="https://blog.csdn.net/ma2595162349/article/details/79449493"><strong>前缀索引</strong></a>这个概念。</mark></p><h3 id="%E4%BB%8B%E7%BB%8D"><a class="header-anchor" href="#%E4%BB%8B%E7%BB%8D">¶</a> 介绍</h3><p>使用explain这个命令来查看一个这些SQL语句的执行计划，查看该SQL语句有没有使用上了索引，有没有做全表扫描，这都可以通过explain命令来查看。</p><p>EXPLAIN命令用法十分简单，在SELECT语句前加上explain就可以了，例如:</p><h3 id="%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E"><a class="header-anchor" href="#%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E">¶</a> 参数说明</h3><p>EXPLAIN命令的输出内容大致如下：</p><p><img src="/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9605/image-20201026191651069.png" alt="image-20201026191651069"></p><p>各列的含义如下：</p><table><thead><tr><th>Column</th><th style="text-align:center">JSON Name</th><th style="text-align:center">Meaning</th></tr></thead><tbody><tr><td>id</td><td style="text-align:center">select_id</td><td style="text-align:center">SELECT 查询的标识符，每个SELECT都会自动分配一个唯一的标识符</td></tr><tr><td><strong>select_type</strong></td><td style="text-align:center">None</td><td style="text-align:center">SELECT 查询的类型</td></tr><tr><td>table</td><td style="text-align:center">table_name</td><td style="text-align:center">查询的是哪个表</td></tr><tr><td>partitions</td><td style="text-align:center">partitions</td><td style="text-align:center">匹配的分区</td></tr><tr><td><strong>type</strong></td><td style="text-align:center">access_type</td><td style="text-align:center">join类型</td></tr><tr><td>possible_keys</td><td style="text-align:center">possible_keys</td><td style="text-align:center">此次查询中可能选用的索引</td></tr><tr><td>key</td><td style="text-align:center">key</td><td style="text-align:center">此次查询中确切使用到的索引</td></tr><tr><td>key_len</td><td style="text-align:center">key_length</td><td style="text-align:center">用于处理查询的索引长度</td></tr><tr><td>ref</td><td style="text-align:center">ref</td><td style="text-align:center">哪个字段或常数与key一起被使用</td></tr><tr><td>rows</td><td style="text-align:center">rows</td><td style="text-align:center">显示此查询一共扫描了多少行，这个是一个估计值</td></tr><tr><td>filtered</td><td style="text-align:center">filtered</td><td style="text-align:center">表示此查询条件所过滤的数据的百分比</td></tr><tr><td><strong>extra</strong></td><td style="text-align:center">None</td><td style="text-align:center">额外的信息</td></tr></tbody></table><h4 id="1.%20id"><a class="header-anchor" href="#1.%20id">¶</a> 1. id</h4><p>每个单位查询的SELECT语句都会自动分配的一个唯一标识符，表示查询中操作表的顺序，有四种情况：</p><ul><li>id相同：执行顺序由上到下</li><li>id不同：如果是子查询, id号会自增, id越大,优先级越高。</li><li>id相同的不同的同时存在</li><li>id列为null的就表示这是一个结果集,不需要使用它来进行查询。</li></ul><h4 id="2.%20select_type(%E9%87%8D%E8%A6%81)"><a class="header-anchor" href="#2.%20select_type(%E9%87%8D%E8%A6%81)">¶</a> 2. select_type(重要)</h4><p>单位查询的查询类型，比如：普通查询、联合查询(union、union all)、 子查询等复杂查询。</p><table><thead><tr><th>select_type Value</th><th style="text-align:center">Meaning</th></tr></thead><tbody><tr><td>SIMPLE</td><td style="text-align:center">Simple SELECT (not using UNION or subqueries)</td></tr><tr><td>PRIMARY</td><td style="text-align:center">Outermost SELECT</td></tr><tr><td>UNION</td><td style="text-align:center">Second or later SELECT statement in a UNION</td></tr><tr><td>DEPENDENT UNION</td><td style="text-align:center">Second or later SELECT statement in a UNION, dependent on outer query</td></tr><tr><td>UNION RESULT</td><td style="text-align:center">Result of a UNION.</td></tr><tr><td>SUBQUERY</td><td style="text-align:center">First SELECT in subquery</td></tr><tr><td>DEPENDENT SUBQUERY</td><td style="text-align:center">First SELECT in subquery, dependent on outer query</td></tr><tr><td>DERIVED</td><td style="text-align:center">Derived table SELECT (subquery in FROM clause)</td></tr><tr><td>MATERIALIZED</td><td style="text-align:center">Materialized subquery</td></tr><tr><td>UNCACHEABLE SUBQUERY</td><td style="text-align:center">A subquery for which the result cannot be cached and must be re-evaluated for each row of the outer query</td></tr><tr><td>UNCACHEABLE UNION</td><td style="text-align:center">The second or later select in a UNION that belongs to an uncacheable subquery (see UNCACHEABLE SUBQUERY)</td></tr></tbody></table><p><strong>simple</strong></p><p>​表示不需要union操作或者不包含子查询的简单select查询。有连接查询时，外层的查询为simple，且只有一个。</p><p><img src="/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9605/image-20201026213444613.png" alt="image-20201026213444613"></p><p><strong>primary</strong></p><p>​一个需要union操作或者含有子查询的select，位于最外层的单位查询的select_ type即为primary，且只有一个。</p><p><img src="/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9605/image-20201026213859278.png" alt="image-20201026213859278"></p><p><strong>union</strong></p><p>​union连接的两个select查询，第一个查询是dervied派生表，除了第一个表外,第二个及以后的表都是union。</p><p><img src="/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9605/image-20201026215912949.png" alt="image-20201026215912949"></p><p><strong>dependent union</strong></p><p>​与union一样，出现在union或union all语句中，但是这个查询要受到外部查询的影响。</p><p><img src="/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9605/image-20201026220120799.png" alt="image-20201026220120799"></p><p><strong>union result</strong></p><p>​包含union的结果集，在union和union all语句中，因为它不需要参与查询，所以id字段为null。</p><p><strong>subquery</strong></p><p>​除了from字句中包含的子查询外，其他地方出现的子查询都可能是subquery。</p><p><strong>dependent subquery</strong></p><p>​与dependent union类似，表示这个subquery的查询要受到外部表查询的影响。</p><p><img src="/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9605/image-20201026220518282.png" alt="image-20201026220518282"></p><p><strong>derived</strong></p><p>​from字句中出现的子查询，也叫做派生表，其他数据库中可能叫做内联视图或嵌套select。</p><h4 id="3.%20table"><a class="header-anchor" href="#3.%20table">¶</a> 3. table</h4><p>显示的单位查询的表名，有如下几种情况:</p><ul><li>如果查询使用了别名，那么这里显示的是别名</li><li>如果不涉及对数据表的操作，那么这显示为null</li><li>如果显示为尖括号括起来的<code>&lt;derived N&gt;</code>就表示这个是临时表，N就是执行计划中的id，表示结果来自于这个查询产生。</li><li>如果是尖括号括起来的<code>&lt;union M,N&gt;</code>，其也是一个临时表，表示这个结果来自于union查询的id为M, N的结果集。</li><li><code>&lt;subquery N&gt;</code>，表示子查询结果被物化。</li></ul><h4 id="4.type(%E9%87%8D%E8%A6%81)"><a class="header-anchor" href="#4.type(%E9%87%8D%E8%A6%81)">¶</a> 4.type(重要)</h4><p>显示的是单位查询的连接类型或者理解为访问类型,访问性能依次从好到差：</p><p><mark>system、const、eq_ref、ref、fulltext、ref_or_nu11、unique_、subquery、index_ subquery、range、index_merge、index、ALL</mark></p><blockquote><p>注意：</p></blockquote><ul><li>除了all之外，其他的type都可以使用到索引</li><li>除了index_ merge之外，其他的type只可以用到一个索引</li><li>最差要使用到range级别</li></ul><p><strong>system</strong></p><p>​表中只有一行数据或者是空表。</p><p><strong>const (重要)</strong></p><p>​使用唯一索引或者主键，返回记录定是1行记录的等值where条件时 ，通常type是const。其他数据库也叫做唯一。</p><p><img src="/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9605/image-20201026212335944.png" alt="image-20201026212335944"></p><p><strong>eq_ref (重要)</strong></p><p>​<strong>针对唯一性索引</strong>此类型通常出现在多表的join 查询，表示对于前表的每一个结果，都只能匹配到后表的一行结果，并且查询的比较操作通常是<code>=</code>，查询效率较高。</p><p><img src="/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9605/image-20201026223046115.png" alt="image-20201026223046115"></p><p><strong>ref (重要)</strong></p><p>​<strong>针对非唯一性索引</strong>，使用等值( = )查询。或者是使用了最左前缀规则索引的查询。</p><ul><li>组合索引</li></ul><p><img src="/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9605/image-20201026224833233.png" alt="image-20201026224833233"></p><ul><li>非唯一索引</li></ul><p><img src="/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9605/image-20201026225113693.png" alt="image-20201026225113693"></p><p><strong>fulltext</strong></p><p>​全文索引检索，要注意，全文索引的优先级很高，若全文索引和普通索引同时存在时，mysql不管代价，优先选择使用全文索引。</p><p><strong>ref_or_null</strong></p><p>​与ref方法类似，只是增加了null值的比较，实际用的不多。</p><p><strong>unique_ subquery</strong></p><p>​用于where中的in形式子查询，子查询返回不重复值唯一值</p><p><strong>index_ subquery</strong></p><p>​用于in形式子查询使用到了辅助索引或者in常数列表，子查询可能返回重复值，可以使用索引将子查询去重。</p><p><strong>range (重要)</strong></p><p>​<strong>索引范围扫描</strong>，常见于使用&gt;,&lt;,is null, between ,in ,like等运算符的查询中。</p><p><img src="/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9605/image-20201026230102618.png" alt="image-20201026230102618"></p><p><strong>index_ merge</strong></p><p>​表示查询使用了两个以上的索引，最后取交集或者并集，常见and , or的条件使用了不同的索引，官方排序这个在ref_or_null之后,但是实际上由于要读取所个索引，性能可能大部分时间都不如range<br><strong>index (重要)</strong></p><p>​select结果列中使用到了索引，type会显示为index。</p><p>​<strong>索引扫描</strong>，把索引从头到尾扫一遍，常见于使用索引列就可以处理不需要读取数据文件的查询、可以使用索引排序或者分组的查询。<mark>索引覆盖</mark></p><p><img src="/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9605/image-20201026230433113.png" alt="image-20201026230433113"></p><p><strong>all (重要)</strong></p><p>​这个就是全表扫描数据文件，然后再在server层进行过滤返回符合要求的记录。</p><p><img src="/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9605/image-20201026230703647.png" alt="image-20201026230703647"></p><h4 id="5.%20possible_keys"><a class="header-anchor" href="#5.%20possible_keys">¶</a> 5. possible_keys</h4><p>此次查询可能选用的索引，一个或多个</p><h4 id="6.%20key"><a class="header-anchor" href="#6.%20key">¶</a> 6. key</h4><p>查询真正使用到的索引, select_type为index_merge时 ,这里可能出现两个以上的索引，其他的select_type这里只会出现一个。</p><h4 id="7.%20key_len"><a class="header-anchor" href="#7.%20key_len">¶</a> 7. key_len</h4><ul><li>用于处理查询的索引长度，如果是单列索引,那就整个索引长度算进去，如果是多列索引，那么查询不一定都能使用到所有的列，具体使用到了多少个列的索引，这里就会计算进去，没有使用到的列，这里不会计算进去。</li><li>留意下这个列的值，算一下你的多列索引总长度就知道有没有使用到所有的列了。</li><li>另外, key_len只计算where条件用到的索引长度，而排序和分组就算用到了索引，也不会计算到key_len中。</li></ul><h4 id="8.%20ref"><a class="header-anchor" href="#8.%20ref">¶</a> 8. ref</h4><ul><li>如果是使用的常数等值查询,这里会显示const</li><li>如果是连接查询，被驱动表的执行计划这里会显示驱动表的关联字段</li><li>如果是条件使用了表达式或者函数,或者条件列发生了内部隐式转换，这里可能显示为func</li></ul><h4 id="9.%20rows"><a class="header-anchor" href="#9.%20rows">¶</a> 9. rows</h4><p>这里是执行计划中估算的扫描行数,不是精确值（InnoDB不是精确的值，MyISAM是精确的值，主要原因是InnoDB里面使用了MVCC并发机制）。</p><h4 id="10.%20extra(%E9%87%8D%E8%A6%81)"><a class="header-anchor" href="#10.%20extra(%E9%87%8D%E8%A6%81)">¶</a> 10. extra(重要)</h4><p>这个列包含不适合在其他列中显示单十分重要的额外的信息，这个列可以显示的信息非常多, 有几十种。</p><p><img src="/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9605/image-20201026234200534.png" alt="image-20201026234200534"></p><p><strong>using index (重要)</strong></p><p>​查询时<mark>不需要回表查询，直接通过索引就可以获取查询的结果数据</mark>。</p><ul><li>表示相应的SELECT查询中使用到了<strong>覆盖索引( Covering Index )</strong> ，避免访问表的数据行，效率不错!</li><li>如果同时出现Using Where， 说明索引被用来执行查找索引键值</li><li>如果没有同时出现Using Where表明索引用来读取数据而非执行查找动作。</li></ul><p><img src="/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9605/image-20201026232248331.png" alt="image-20201026232248331"></p><p><img src="/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9605/image-20201026233925768.png" alt="image-20201026233925768"></p><p><strong>using where (重要)</strong></p><p>​表示MySQL将对storage engine提取的结果进行过滤，过滤条件字段无索引</p><p><img src="/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9605/image-20201026233756102.png" alt="image-20201026233756102"></p><p><strong>using index condition(重要 )</strong></p><p>​Using index condition 会先条件过滤索引,过滤完索弓后找到所有符合索引|条件的数据行,随后用WHERE子句中的其他条件去过滤这些数据行;<br><strong>using filesort (重要)</strong></p><ul><li>排序时无法使用到索引时,就会出现这个。常见于order by和group by语句中.</li><li>说明MySQL会使用一 一个外部的索引排序,而不是按照索引顺序进行读取。</li><li>MySQL 中无法利用索引|完成的排序操作称为&quot;文件排序”</li></ul><p><img src="/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9605/image-20201026234323326.png" alt="image-20201026234323326"></p><hr><blockquote><p><a href="http://lampkins.gitee.io/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9601/">MySQL性能优化01：主题和目标</a></p><p><a href="http://lampkins.gitee.io/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9602/">MySQL性能优化02：MySQL架构篇</a></p><p><a href="http://lampkins.gitee.io/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9603/">MySQL性能优化03：MySQL性能分析篇</a></p><p><a href="http://lampkins.gitee.io/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9604/">MySQL性能优化04：MySQL索引篇01索引讲解</a></p><p><a href="http://lampkins.gitee.io/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9605/">MySQL性能优化05：MySQL索引篇02查看执行计划</a></p><p><a href="http://lampkins.gitee.io/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9606/">MySQL性能优化06：MySQL索引篇03索引失效分析</a></p><p><a href="http://lampkins.gitee.io/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9607/">MySQL性能优化07：性能优化篇</a></p></blockquote><script>    let imgs = document.getElementsByTagName('img');    for (let img of imgs) {        img.setAttribute('class', 'fancybox');    }</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.6.0/katex.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;MySQL Explain查看执行计划&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;MySQL%E7%B4%A2%E5%BC%95%E7%AF%87&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#MySQL%E7%B4%A2%E5%BC%95%E7%AF%87&quot;&gt;</summary>
      
    
    
    
    <category term="数据库" scheme="http://lampkins.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="MySQL性能优化" scheme="http://lampkins.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
    <category term="MySQL" scheme="http://lampkins.gitee.io/tags/MySQL/"/>
    
    <category term="索引" scheme="http://lampkins.gitee.io/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>MySQL性能优化04：MySQL索引篇01</title>
    <link href="http://lampkins.gitee.io/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9604/"/>
    <id>http://lampkins.gitee.io/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9604/</id>
    <published>2020-10-26T12:57:24.000Z</published>
    <updated>2020-11-07T09:47:58.111Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL 索引讲解</p><hr><h1 id="MySQL%E7%B4%A2%E5%BC%95%E7%AF%87"><a class="header-anchor" href="#MySQL%E7%B4%A2%E5%BC%95%E7%AF%87">¶</a> MySQL索引篇</h1><h2 id="%E7%B4%A2%E5%BC%95%E4%BB%8B%E7%BB%8D"><a class="header-anchor" href="#%E7%B4%A2%E5%BC%95%E4%BB%8B%E7%BB%8D">¶</a> 索引介绍</h2><h3 id="%E7%B4%A2%E5%BC%95%E6%98%AF%E4%BB%80%E4%B9%88"><a class="header-anchor" href="#%E7%B4%A2%E5%BC%95%E6%98%AF%E4%BB%80%E4%B9%88">¶</a> 索引是什么</h3><ul><li>MySQL官方对索引的定义为：索引(Index)是帮助MySQL<strong>高效获取数据的数据结构</strong>，通俗来讲索引就好比书本的目录，<strong>加快数据库的查询速度。</strong></li><li><strong>使用B+树结构组织(多路搜索树，并不一定是二叉的)的索引。</strong></li><li><strong>索引是存储在磁盘文件中的</strong>(可能在单独的索引文件中，也可能和数据一 起存储在数据文件中)。</li></ul><h3 id="%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E5%8A%BF%E5%92%8C%E5%8A%A3%E5%8A%BF"><a class="header-anchor" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E5%8A%BF%E5%92%8C%E5%8A%A3%E5%8A%BF">¶</a> 索引的优势和劣势</h3><p><strong>优势：</strong></p><ul><li><p>可以<strong>提高数据检索的效率，降低数据库的IO成本</strong>，类似于书的目录。</p></li><li><p>通过<strong>索引列对数据进行排序</strong>，降低数据排序的成本，降低了CPU的消耗。</p><ul><li>被索引的列会自动进行排序，包括【单列索引】和【组合索引】， 只是组合索引的排序要复杂一些</li><li>如果按照索引列的顺序进行排序，对应order by语句来说，效率就会提高很多。</li></ul></li></ul><p><strong>劣势</strong>：</p><ul><li><strong>索引会占据磁盘空间</strong></li><li><strong>索引虽然会提高查询效率，但是会降低更新表的效率</strong>。每次对表进行增删改操作，MySQL不仅要保存数据，还要保存或者更新对应的索引文件。</li></ul><h2 id="%E5%B8%B8%E7%94%A8%E7%B4%A2%E5%BC%95%E5%88%86%E7%B1%BB"><a class="header-anchor" href="#%E5%B8%B8%E7%94%A8%E7%B4%A2%E5%BC%95%E5%88%86%E7%B1%BB">¶</a> 常用索引分类</h2><h3 id="%E5%8D%95%E5%88%97%E7%B4%A2%E5%BC%95"><a class="header-anchor" href="#%E5%8D%95%E5%88%97%E7%B4%A2%E5%BC%95">¶</a> 单列索引</h3><ul><li>普通索引：MySQL中基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值，纯粹为了查询数据更快一点。</li><li>唯一索引：索引列中的值必须是唯一的，但是允许为空值。</li><li>主键索引：是一种特殊的唯一索引，不允许有空值。</li></ul><h3 id="%E7%BB%84%E5%90%88%E7%B4%A2%E5%BC%95"><a class="header-anchor" href="#%E7%BB%84%E5%90%88%E7%B4%A2%E5%BC%95">¶</a> 组合索引</h3><ul><li>在表中的<strong>多个字段组合上创建的一个索引</strong></li><li>组合索引的使用，需要遵循<strong>最左前缀原则(最左匹配原则)</strong>。</li><li>一般情况下，<strong>建议使用组合索引代替单列索引</strong>(主键索引除外，具体原因后面知识点讲解)。</li></ul><h3 id="%E5%85%A8%E6%96%87%E7%B4%A2%E5%BC%95"><a class="header-anchor" href="#%E5%85%A8%E6%96%87%E7%B4%A2%E5%BC%95">¶</a> 全文索引</h3><ul><li>只有在<strong>MyISAM引</strong>擎上才能使用</li><li>只能在<strong>CHAR,VARCHAR,TEXT</strong>类型字段上使用全文索引</li><li>占用很大的物理空间和降低了记录修改性，较为少用。</li></ul><h2 id="%E7%B4%A2%E5%BC%95%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8"><a class="header-anchor" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8">¶</a> 索引的简单使用</h2><h3 id="%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><a class="header-anchor" href="#%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95">¶</a> 创建索引</h3><ul><li>单列索引之普通索引</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX index_name ON table_name(column(length));</span><br><span class="line">ALTER TABLE table_name ADD INDEX index_name (column(length));</span><br></pre></td></tr></table></figure><ul><li>单列索引之唯一索引</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE UNIQUE INDEX idnex_name ON table (column(length));</span><br></pre></td></tr></table></figure><ul><li>单列索引之全文索引</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE FULLTEXT INDEX index_name ON table(column(length));</span><br></pre></td></tr></table></figure><ul><li>组合索引</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE article ADD INDEX index_titme_time (title(50)，time(10))</span><br></pre></td></tr></table></figure><p><mark>注意：创建索引时，可以指定索引列的长度，但是数字类型不要指定</mark></p><h3 id="%E5%88%A0%E9%99%A4%E7%B4%A2%E5%BC%95"><a class="header-anchor" href="#%E5%88%A0%E9%99%A4%E7%B4%A2%E5%BC%95">¶</a> 删除索引</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP INDEX index_name ON table_name</span><br></pre></td></tr></table></figure><h3 id="%E6%9F%A5%E7%9C%8B%E7%B4%A2%E5%BC%95"><a class="header-anchor" href="#%E6%9F%A5%E7%9C%8B%E7%B4%A2%E5%BC%95">¶</a> 查看索引</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW INDEX FROM table_name</span><br></pre></td></tr></table></figure><h2 id="%E7%B4%A2%E5%BC%95%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><a class="header-anchor" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84">¶</a> 索引的存储结构</h2><h3 id="%E7%B4%A2%E5%BC%95%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%BB%8B%E7%BB%8D"><a class="header-anchor" href="#%E7%B4%A2%E5%BC%95%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%BB%8B%E7%BB%8D">¶</a> 索引存储结构介绍</h3><ul><li>索引是<strong>在存储引擎中实现</strong>的，也就是说不同的存储引擎，会使用不同的索引数据结构。</li><li><strong>MyISAM和InnoDB存储引擎</strong>：只支持<strong>BTREE索引</strong>，也就是说<strong>默认使用BTREE，不能够更换。</strong></li><li>MEMORY/HEAP存储引擎：支持HASH和BTREE索引。</li></ul><h3 id="B%E6%A0%91%E5%92%8CB%2B%E6%A0%91"><a class="header-anchor" href="#B%E6%A0%91%E5%92%8CB%2B%E6%A0%91">¶</a> B树和B+树</h3><p><a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html">数据结构示例网站</a></p><h4 id="B%E6%A0%91%E5%9B%BE%E7%A4%BA"><a class="header-anchor" href="#B%E6%A0%91%E5%9B%BE%E7%A4%BA">¶</a> B树图示</h4><p>B树是为了磁盘或其它存储设备而设计的一种多叉平衡查找树(下面你会看到，相对于二叉， B树每个内结点有多个分支，即多叉)。</p><p><img src="/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9604/1.jpg" alt="1"></p><ul><li>B树的高度一般都是在2-4这个高度，树的高度直接决定I0读写的次数以及查询时间复杂度( log(n) )。</li><li>B树三层可以存储bigint类型的主键10亿条</li><li>如果是三层树结构—支撑的数据可以达到20G ，如果是四层树结构—支撑的数据可以达到几十T</li></ul><p><img src="/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9604/image-20201025222508672.png" alt="B+树"></p><h4 id="B%E6%A0%91%E5%92%8CB%2B%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB"><a class="header-anchor" href="#B%E6%A0%91%E5%92%8CB%2B%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB">¶</a> B树和B+树的区别</h4><p>B树和B+树的最大区别在于<mark>非叶子节点是否存储数据</mark>的问题。</p><ul><li>B树是非叶子节点和叶子节点都会存储数据。</li><li>B+树只有叶子节点才会存储数据，而且存储的数据都是在一行上，而且这些数据都是有指针指向的，是有顺链表。</li></ul><h3 id="%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%EF%BC%88InnoDB%EF%BC%89"><a class="header-anchor" href="#%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%EF%BC%88InnoDB%EF%BC%89">¶</a> 聚集索引（InnoDB）</h3><p>Cluster Index：聚簇索引(索引组织表)。</p><p>InnoDB存储引擎的数据组织方式，是聚簇索引表：<strong>完整的记录，存储在主键索引中，通过主键索引，就可以获取记录所有的列，也就是说表数据和索引是在一起，这就是聚集索引。</strong></p><blockquote><p>更多：<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-index-types.html">Clustered and Secondary Indexes</a></p></blockquote><h4 id="%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95"><a class="header-anchor" href="#%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95">¶</a> 主键索引</h4><p>主键索引（聚集索引）的叶子节点会存储数据行，辅助索引只会存储主键值。</p><p>InnoDB要求表必须有主键(MyISAM可以没有)，如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB 表生成-个隐含字段作为主键 ，类型为长整形。</p><p><img src="/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9604/image-20201025163705470.png" alt="image-20201025163705470"></p><p>上图是InnoDB 主索引(同时也是数据文件)的示意图，可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。</p><blockquote><p>如果没有主键？</p></blockquote><p>​选择唯一非空列，无选择则默认创建一个隐藏列作为主键</p><h4 id="%E8%BE%85%E5%8A%A9%E7%B4%A2%E5%BC%95%EF%BC%88%E6%AC%A1%E8%A6%81%E7%B4%A2%E5%BC%95%EF%BC%89"><a class="header-anchor" href="#%E8%BE%85%E5%8A%A9%E7%B4%A2%E5%BC%95%EF%BC%88%E6%AC%A1%E8%A6%81%E7%B4%A2%E5%BC%95%EF%BC%89">¶</a> 辅助索引（次要索引）</h4><p>InnoDB的所有辅助索引都引用主键作为data域。</p><p>聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。</p><p><img src="/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9604/image-20201025164302502.png" alt="image-20201025164302502"></p><blockquote><p>引申：为什么不建议使用过长的字段作为主键?</p></blockquote><p>​因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。同时，请尽量在InnoDB 上采用自增字段做表的主键。</p><h3 id="%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%EF%BC%88MyISAM%EF%BC%89"><a class="header-anchor" href="#%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%EF%BC%88MyISAM%EF%BC%89">¶</a> 非聚集索引（MyISAM）</h3><ul><li>B+树叶子节点只会存储数据行(数据文件)的指针,简单来说数据和索引不在一起，就是非聚集索引。</li><li>非聚集索引中的主键索引和辅助索引都会存储指针的值</li></ul><h4 id="%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95-2"><a class="header-anchor" href="#%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95-2">¶</a> 主键索引</h4><p><img src="/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9604/image-20201025164627980.png" alt="image-20201025164627980"></p><p>这里设表一共有三列,假设我们以Col1为主键,则上图是一个MyISAM表的主索引(Primary key)示意。可以看出MyISAM的索引文件仅仅保存数据记录的地址。</p><p><img src="/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9604/image-20201025165149124.png" alt="image-20201025165149124"></p><h4 id="%E8%BE%85%E5%8A%A9%E7%B4%A2%E5%BC%95%EF%BC%88%E6%AC%A1%E8%A6%81%E7%B4%A2%E5%BC%95%EF%BC%89-2"><a class="header-anchor" href="#%E8%BE%85%E5%8A%A9%E7%B4%A2%E5%BC%95%EF%BC%88%E6%AC%A1%E8%A6%81%E7%B4%A2%E5%BC%95%EF%BC%89-2">¶</a> 辅助索引（次要索引）</h4><p>在 MyISAM 中，主索引和辅助索引(Secondary key)在结构上没有任何区别，只是主索引要求 key 是唯一的，而辅助索引的 key 可以重复。如果我们在 Col2 上建立一个辅助索引,则此索引的结构如下图所示</p><p><img src="/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9604/image-20201025165326966.png" alt="image-20201025165326966"></p><p>同样也是一颗 B+Tree，data 域保存数据记录的地址。因此，MyISAM 中索引检索的算法为首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在,则取出其data 域的值，然后以data 域的值为地址，读取相应数据记录。</p><h2 id="%E7%BB%84%E5%90%88%E7%B4%A2%E5%BC%95%E4%BD%BF%E7%94%A8"><a class="header-anchor" href="#%E7%BB%84%E5%90%88%E7%B4%A2%E5%BC%95%E4%BD%BF%E7%94%A8">¶</a> 组合索引使用</h2><h3 id="%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E7%BB%84%E5%90%88%E7%B4%A2%E5%BC%95"><a class="header-anchor" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E7%BB%84%E5%90%88%E7%B4%A2%E5%BC%95">¶</a> 为什么使用组合索引</h3><p><mark>为了节省mysq1索引存储空间以及提升搜索性能</mark>，可建立组合索引（能使用组合索引就不使用单列索引）</p><p>例如：创建如下的一个组合索引，相当于建立了col1,col1 col2,col1 col2 col3三个索引：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 以下语句会创建一颗B+tree ,但是它相对于三颗索引树的功效。</span><br><span class="line">ALTER TABLE &#39;table_name&#39; ADD INDEX index_ name(&#39;co11&#39;,&#39;co12&#39;,&#39;co13&#39;)</span><br></pre></td></tr></table></figure><h3 id="%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E5%93%AA%E4%BA%9B%E5%88%97%E6%9D%A5%E5%88%9B%E5%BB%BA%E7%BB%84%E5%90%88%E7%B4%A2%E5%BC%95%3F"><a class="header-anchor" href="#%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E5%93%AA%E4%BA%9B%E5%88%97%E6%9D%A5%E5%88%9B%E5%BB%BA%E7%BB%84%E5%90%88%E7%B4%A2%E5%BC%95%3F">¶</a> 如何选择哪些列来创建组合索引?</h3><ol><li>常出现在<code>where</code>条件中的列，建议用来创建组合索引，至于组合索引中的顺序，是很重要的，因为组合索引会使用到最左前缀原则。但是因为MySQL 中存在查询优化器，所以你的书写SQL条件的顺序，不一定是执行时候的<code>where</code>条件顺序。</li><li>常出现在<code>order by</code>和<code>group by</code>语句中的列。最后按照顺序去创建组合索引。</li><li>常出现在<code>select</code>语句中的列，也建议按照顺序，创建组合索引。</li></ol><h3 id="%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8E%9F%E5%88%99"><a class="header-anchor" href="#%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8E%9F%E5%88%99">¶</a> 最左前缀原则</h3><p>顾名思义，就是最左优先，这个最左是针对于组合索引和前缀索引，理解如下:</p><ol><li>最左前缀匹配原则，非常重要的原则，MySQL会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、 like )就停止匹配 <mark>（索引最多用于一个范围列）</mark> ，比如<code>a = 1 and b = 2 and c &gt; 3 and d = 4</code>如果建立<code>(a, b, c, d)</code>顺序的索引，d是用不到索引的；如果建立<code>(a, b, d, c)</code>的索引则都可以用到，且a, b, d的顺序可以任意调整。</li><li>如果通配符 % 不出现在开头，则可以用到索引，但根据具体情况不同可能只会用其中一个前缀<br>like “value%” 可以使用索引，但是 like “%value%” 不会使用索引，走的是全表扫描.</li><li>=和in可以乱序，比如<code>a = 1 and b = 2 and C = 3</code>建立<code>(a, b, c)</code>索引，可以任意顺序, MySQL的查询优化器会帮你优化成索引可以识别的形式</li></ol><h2 id="%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95"><a class="header-anchor" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95">¶</a> 如何使用索引</h2><h3 id="%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E9%9C%80%E8%A6%81%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><a class="header-anchor" href="#%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E9%9C%80%E8%A6%81%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95">¶</a> 哪些情况需要创建索引</h3><ol><li>主键自动建立唯一索引</li><li>频繁作为查询条件的字段应该创建索引(业务)</li><li>多表关联查询中,关联字段应该创建索引</li><li>查询中统计或者分组字段,应该创建索引</li><li>查询中排序的字段,应该创建索引</li></ol><p>mysq1创建组合索引的规则是首先会对组合索引的最左边的，也就是第一个name字段的数据进行排序，在第一个字段的排序基础上，然后再对后面第二个的cid字段进行排序。其实就相当于实现了类似<code>order by name cid</code>这样一种排序规则。</p><h3 id="%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E4%B8%8D%E9%9C%80%E8%A6%81%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><a class="header-anchor" href="#%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E4%B8%8D%E9%9C%80%E8%A6%81%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95">¶</a> 哪些情况不需要创建索引</h3><ol><li>表记录太少（少于1千）</li><li>经常进行增删改操作的表</li><li>频繁更新的字段</li><li>where条件里使用频率不高的字段</li></ol><hr><blockquote><p><a href="http://lampkins.gitee.io/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9601/">MySQL性能优化01：主题和目标</a></p><p><a href="http://lampkins.gitee.io/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9602/">MySQL性能优化02：MySQL架构篇</a></p><p><a href="http://lampkins.gitee.io/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9603/">MySQL性能优化03：MySQL性能分析篇</a></p><p><a href="http://lampkins.gitee.io/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9604/">MySQL性能优化04：MySQL索引篇01索引讲解</a></p><p><a href="http://lampkins.gitee.io/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9605/">MySQL性能优化05：MySQL索引篇02查看执行计划</a></p><p><a href="http://lampkins.gitee.io/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9606/">MySQL性能优化06：MySQL索引篇03索引失效分析</a></p><p><a href="http://lampkins.gitee.io/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9607/">MySQL性能优化07：性能优化篇</a></p></blockquote><script>    let imgs = document.getElementsByTagName('img');    for (let img of imgs) {        img.setAttribute('class', 'fancybox');    }</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.6.0/katex.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;MySQL 索引讲解&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;MySQL%E7%B4%A2%E5%BC%95%E7%AF%87&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#MySQL%E7%B4%A2%E5%BC%95%E7%AF%87&quot;&gt;¶&lt;/a&gt; MyS</summary>
      
    
    
    
    <category term="数据库" scheme="http://lampkins.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="MySQL性能优化" scheme="http://lampkins.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
    <category term="MySQL" scheme="http://lampkins.gitee.io/tags/MySQL/"/>
    
    <category term="索引" scheme="http://lampkins.gitee.io/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>数据库事务ACID</title>
    <link href="http://lampkins.gitee.io/2020/10/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1ACID/"/>
    <id>http://lampkins.gitee.io/2020/10/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1ACID/</id>
    <published>2020-10-25T03:46:57.000Z</published>
    <updated>2021-08-05T10:08:09.836Z</updated>
    
    <content type="html"><![CDATA[<p>事务具有4个特征，分别是原子性、一致性、隔离性和持久性，简称事务的ACID特性；</p><h2 id="%E4%B8%80%E3%80%81%E5%8E%9F%E5%AD%90%E6%80%A7%EF%BC%88atomicity)"><a class="header-anchor" href="#%E4%B8%80%E3%80%81%E5%8E%9F%E5%AD%90%E6%80%A7%EF%BC%88atomicity)">¶</a> 一、原子性（atomicity)</h2><p>一个事务要么全部提交成功，要么全部失败回滚，不能只执行其中的一部分操作，这就是事务的原子性</p><h2 id="%E4%BA%8C%E3%80%81%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%88consistency)"><a class="header-anchor" href="#%E4%BA%8C%E3%80%81%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%88consistency)">¶</a> 二、一致性（consistency)</h2><p>事务的执行不能破坏数据库数据的完整性和一致性，一个事务在执行之前和执行之后，数据库都必须处于一致性状态。</p><p>如果数据库系统在运行过程中发生故障，有些事务尚未完成就被迫中断，这些未完成的事务对数据库所作的修改有一部分已写入物理数据库，这是数据库就处于一种不正确的状态，也就是不一致的状态</p><h2 id="%E4%B8%89%E3%80%81%E9%9A%94%E7%A6%BB%E6%80%A7%EF%BC%88isolation%EF%BC%89"><a class="header-anchor" href="#%E4%B8%89%E3%80%81%E9%9A%94%E7%A6%BB%E6%80%A7%EF%BC%88isolation%EF%BC%89">¶</a> 三、隔离性（isolation）</h2><p>事务的隔离性是指在并发环境中，并发的事务时相互隔离的，一个事务的执行不能不被其他事务干扰。不同的事务并发操作相同的数据时，每个事务都有各自完成的数据空间，即一个事务内部的操作及使用的数据对其他并发事务时隔离的，并发执行的各个事务之间不能相互干扰。</p><p>在标准SQL规范中，定义了4个事务隔离级别，不同的隔离级别对事务的处理不同，分别是：<mark>未授权读取，授权读取，可重复读取和串行化</mark>。</p><h3 id="1%E3%80%81%E8%AF%BB%E6%9C%AA%E6%8F%90%E4%BA%A4%EF%BC%88Read%20Uncommited%EF%BC%89"><a class="header-anchor" href="#1%E3%80%81%E8%AF%BB%E6%9C%AA%E6%8F%90%E4%BA%A4%EF%BC%88Read%20Uncommited%EF%BC%89">¶</a> 1、读未提交（Read Uncommited）</h3><p><mark>该隔离级别允许脏读取，其隔离级别最低</mark>；比如事务A和事务B同时进行，事务A在整个执行阶段，会将某数据的值从1开始一直加到10，然后进行事务提交，此时，事务B能够看到这个数据项在事务A操作过程中的所有中间值（如1变成2，2变成3等），而对这一系列的中间值的读取就是未授权读取</p><h3 id="2%E3%80%81%E6%8E%88%E6%9D%83%E8%AF%BB%E5%8F%96%E4%B9%9F%E7%A7%B0%E4%B8%BA%E5%B7%B2%E6%8F%90%E4%BA%A4%E8%AF%BB%EF%BC%88Read%20Commited%EF%BC%89"><a class="header-anchor" href="#2%E3%80%81%E6%8E%88%E6%9D%83%E8%AF%BB%E5%8F%96%E4%B9%9F%E7%A7%B0%E4%B8%BA%E5%B7%B2%E6%8F%90%E4%BA%A4%E8%AF%BB%EF%BC%88Read%20Commited%EF%BC%89">¶</a> 2、授权读取也称为已提交读（Read Commited）</h3><p><mark>授权读取只允许获取已经提交的数据</mark>。比如事务A和事务B同时进行，事务A进行+1操作，此时，事务B无法看到这个数据项在事务A操作过程中的所有中间值，只能看到最终的10。另外，如果说有一个事务C，和事务A进行非常类似的操作，只是事务C是将数据项从10加到20，此时事务B也同样可以读取到20，即授权读取允许不可重复读取。</p><h3 id="3%E3%80%81%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%EF%BC%88Repeatable%20Read)"><a class="header-anchor" href="#3%E3%80%81%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%EF%BC%88Repeatable%20Read)">¶</a> 3、可重复读（Repeatable Read)</h3><p>就是保证在事务处理过程中，多次读取同一个数据时，其值都和事务开始时刻是一致的，因此该事务级别==禁止不可重复读取和脏读取，但是有可能出现幻影数据。==所谓幻影数据，就是指同样的事务操作，在前后两个时间段内执行对同一个数据项的读取，可能出现不一致的结果。在上面的例子中，可重复读取隔离级别能够保证事务B在第一次事务操作过程中，始终对数据项读取到1，但是在下一次事务操作中，即使事务B（注意，事务名字虽然相同，但是指的是另一个事务操作）采用同样的查询方式，就可能读取到10或20；</p><h3 id="4%E3%80%81%E4%B8%B2%E8%A1%8C%E5%8C%96"><a class="header-anchor" href="#4%E3%80%81%E4%B8%B2%E8%A1%8C%E5%8C%96">¶</a> 4、串行化</h3><p>是最严格的事务隔离级别，它要求所有事务被串行执行，即事务只能一个接一个的进行处理，不能并发执行。</p><h3 id="%E9%9A%94%E7%A6%BB%E6%80%A7%E7%BA%A7%E5%88%AB%E7%9A%84%E6%80%BB%E7%BB%93"><a class="header-anchor" href="#%E9%9A%94%E7%A6%BB%E6%80%A7%E7%BA%A7%E5%88%AB%E7%9A%84%E6%80%BB%E7%BB%93">¶</a> 隔离性级别的总结</h3><table><thead><tr><th style="text-align:center">隔离级别/存在的问题</th><th style="text-align:center">脏读</th><th style="text-align:center">不可重复读</th><th style="text-align:center">幻读</th></tr></thead><tbody><tr><td style="text-align:center">读未提交</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">读已提交</td><td style="text-align:center">-</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">可重复读</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">可序列化</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr></tbody></table><p>在基于锁的并发控制中，依靠不同的锁持有时间实现各隔离级别。锁均从操作前开始持有，”S”表示操作结束后释放，”C”表示事务提交后释放：</p><table><thead><tr><th style="text-align:left">隔离级别/问题</th><th style="text-align:left">写锁</th><th style="text-align:left">读锁</th><th style="text-align:left">范围锁</th></tr></thead><tbody><tr><td style="text-align:left">读未提交</td><td style="text-align:left">S</td><td style="text-align:left">S</td><td style="text-align:left">S</td></tr><tr><td style="text-align:left">读已提交</td><td style="text-align:left">C</td><td style="text-align:left">S</td><td style="text-align:left">S</td></tr><tr><td style="text-align:left">可重复读</td><td style="text-align:left">C</td><td style="text-align:left">C</td><td style="text-align:left">S</td></tr><tr><td style="text-align:left">可序列化</td><td style="text-align:left">C</td><td style="text-align:left">C</td><td style="text-align:left">C</td></tr></tbody></table><p>MySQL的默认隔离级别是可重复读，解决了脏读、部分不可重复读问题，有幻读问题。</p><h2 id="%E5%9B%9B%E3%80%81%E6%8C%81%E4%B9%85%E6%80%A7%EF%BC%88durability%EF%BC%89"><a class="header-anchor" href="#%E5%9B%9B%E3%80%81%E6%8C%81%E4%B9%85%E6%80%A7%EF%BC%88durability%EF%BC%89">¶</a> 四、持久性（durability）</h2><p>一旦事务提交，那么它对数据库中的对应数据的状态的变更就会永久保存到数据库中。–即使发生系统崩溃或机器宕机等故障，只要数据库能够重新启动，那么一定能够将其恢复到事务成功结束的状态</p><blockquote><p>来源：<br><a href="https://www.jianshu.com/p/fc8a654f2205">https://www.jianshu.com/p/fc8a654f2205</a></p><p><a href="https://blog.csdn.net/echizao1839/article/details/90378014">https://blog.csdn.net/echizao1839/article/details/90378014</a></p></blockquote><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.6.0/katex.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;事务具有4个特征，分别是原子性、一致性、隔离性和持久性，简称事务的ACID特性；&lt;/p&gt;
&lt;h2 id=&quot;%E4%B8%80%E3%80%81%E5%8E%9F%E5%AD%90%E6%80%A7%EF%BC%88atomicity)&quot;&gt;&lt;a class=&quot;header-a</summary>
      
    
    
    
    <category term="数据库" scheme="http://lampkins.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="事务" scheme="http://lampkins.gitee.io/tags/%E4%BA%8B%E5%8A%A1/"/>
    
    <category term="ACID" scheme="http://lampkins.gitee.io/tags/ACID/"/>
    
  </entry>
  
  <entry>
    <title>MySQL性能优化03：MySQL性能分析篇</title>
    <link href="http://lampkins.gitee.io/2020/10/23/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9603/"/>
    <id>http://lampkins.gitee.io/2020/10/23/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9603/</id>
    <published>2020-10-23T09:32:44.000Z</published>
    <updated>2020-10-30T13:48:57.334Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL性能分析之慢查询日志介绍和show profile介绍</p><hr><h1 id="MySQL%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E7%AF%87"><a class="header-anchor" href="#MySQL%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E7%AF%87">¶</a> MySQL性能分析篇</h1><h2 id="%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E7%9A%84%E6%80%9D%E8%B7%AF"><a class="header-anchor" href="#%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E7%9A%84%E6%80%9D%E8%B7%AF">¶</a> 性能分析的思路</h2><ol><li>首先需要使用【慢查询日志】功能，去获取所有查询时间比较长的SQL语句。上线前开，生产中一般不使用。</li><li>其次【查看执行计划】查看有问题的SQL的执行计划</li><li>最后可以使用【show profile[s]]】查看有问题的SQL 的性能使用情况</li></ol><h2 id="%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97"><a class="header-anchor" href="#%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97">¶</a> 慢查询日志</h2><p>​数据库查询快慢是影响项目性能的一大因素,对于数据库，我们除了要优化SQL，更重要的是得先<mark>找到需要优化的SQL</mark>。 MySQL数据库有一个**“慢查询日志“**功能，用来记录查询时间超过某个设定值的SQL语句，这将极大程度帮助我们<mark>快速定位到症结所在</mark>，以便对症下药。<br>至于查询时间的多少才算慢,每个项目、业务都有不同的要求。</p><p>**作用：**记录在MySQL中响应时间超过阀值的语句，即运行时间超过long_query_time值的SQL，会被记录到慢查询日志中。</p><p>MySQL的慢查询日志功能<mark>默认是关闭的,需要手动开启</mark>。</p><blockquote><p><a href="https://www.cnblogs.com/saneri/p/6656161.html">MySQL慢查询日志总结</a></p></blockquote><h2 id="explain%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92"><a class="header-anchor" href="#explain%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92">¶</a> explain执行计划</h2><p>​EXPLAIN 命令是查看查询优化器如何决定执行查询的主要方法，使用EXPLAIN，只需要在查询中的SELECT关键字之前增加EXPLAIN这个词即可，MYSQL会在查询上设置一个标记，当执行查询时，这个标记会使其返回关于在执行计划中每一步的信息，它会返回一行或多行信息，显示出执行计划中的每一部分和执行的次序，从而可以从分析结果中找到查询语句或表结构的性能瓶颈。</p><p><strong>EXPLAIN作用</strong></p><ul><li>分析出表的读取顺序</li><li>数据读取操作的操作类型</li><li>哪些索引可以使用</li><li>哪些索引被实际使用</li><li>表之间的引用</li><li>每张表有多少行被优化器查询</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 使用时在前面加上explain即可</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tbl_dept;</span><br></pre></td></tr></table></figure><p><img src="/2020/10/23/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9603/image-20201026191651069.png" alt="20180521155012377"></p><blockquote><p><a href="https://www.cnblogs.com/myseries/p/10736268.html">MySQL — 优化之explain执行计划详解（转）</a></p></blockquote><h2 id="profile%E5%88%86%E6%9E%90%E8%AF%AD%E5%8F%A5"><a class="header-anchor" href="#profile%E5%88%86%E6%9E%90%E8%AF%AD%E5%8F%A5">¶</a> profile分析语句</h2><p>Query Profiler是MySQL 自带的一种query诊断分析工具通过它可以分析出一 条SQL语句的硬件性能瓶颈在什么地方。</p><p>通常我们使用的explain，以及slow query log都无法做到精确分析，但是Query Profiler却可以定位出一条SQL语句执行的各种资源消耗情况，比如CPU/IO等，以及该SQL执行所耗费的时间等。不过该工具只有在MySQL5.0.37以及以上版本中才有实现。</p><p>MYSQL的该功能<mark>默认是关闭的，需要手动启动</mark>。</p><hr><blockquote><p><a href="http://lampkins.gitee.io/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9601/">MySQL性能优化01：主题和目标</a></p><p><a href="http://lampkins.gitee.io/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9602/">MySQL性能优化02：MySQL架构篇</a></p><p><a href="http://lampkins.gitee.io/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9603/">MySQL性能优化03：MySQL性能分析篇</a></p><p><a href="http://lampkins.gitee.io/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9604/">MySQL性能优化04：MySQL索引篇01索引讲解</a></p><p><a href="http://lampkins.gitee.io/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9605/">MySQL性能优化05：MySQL索引篇02查看执行计划</a></p><p><a href="http://lampkins.gitee.io/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9606/">MySQL性能优化06：MySQL索引篇03索引失效分析</a></p><p><a href="http://lampkins.gitee.io/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9607/">MySQL性能优化07：性能优化篇</a></p></blockquote><script>    let imgs = document.getElementsByTagName('img');    for (let img of imgs) {        img.setAttribute('class', 'fancybox');    }</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.6.0/katex.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;MySQL性能分析之慢查询日志介绍和show profile介绍&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;MySQL%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E7%AF%87&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#MyS</summary>
      
    
    
    
    <category term="数据库" scheme="http://lampkins.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="MySQL性能优化" scheme="http://lampkins.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
    <category term="MySQL" scheme="http://lampkins.gitee.io/tags/MySQL/"/>
    
    <category term="索引" scheme="http://lampkins.gitee.io/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>MySQL性能优化02：MySQL架构篇</title>
    <link href="http://lampkins.gitee.io/2020/10/23/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9602/"/>
    <id>http://lampkins.gitee.io/2020/10/23/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9602/</id>
    <published>2020-10-23T09:32:39.000Z</published>
    <updated>2020-10-30T13:47:50.727Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL架构介绍、存储引擎介绍、日志文件、数据文件介绍</p><hr><h1 id="MySQL%E6%9E%B6%E6%9E%84%E7%AF%87"><a class="header-anchor" href="#MySQL%E6%9E%B6%E6%9E%84%E7%AF%87">¶</a> MySQL架构篇</h1><p><img src="/2020/10/23/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9602/timg.jpg" alt="timg"></p><h2 id="%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%BB%8B%E7%BB%8D"><a class="header-anchor" href="#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%BB%8B%E7%BB%8D">¶</a> 存储引擎介绍</h2><p>与其他数据库例如Oracle和SQL Server等数据库中只有一种存储引擎不同的是, MySQL有一个被称为&quot;Pluggable Storage Engine Architecture&quot; (可插拔的存储引擎架构)的特性，也就意味着MySQL数据库提供了多种存储引擎。</p><p>而且<strong>存储引擎是针对表</strong>的，用户可以根据不同的需求为数据表选择不同的存储引擎，用户也可以根据自己的需要编写自己的存储引擎。也就是说，同一数据库不同的表可以选择不同的存储引擎。</p><p><code>creat table xxx() engine=InnoDB/Memory/MyISAM</code></p><p>简而言之，存储引擎就是如何存储数据、如何为存储的数据建立索引和如何更新、查询数据等技术的实现方法。</p><ul><li><strong>MySQL存储引擎种类</strong></li></ul><table><thead><tr><th>存储引擎</th><th>说明</th></tr></thead><tbody><tr><td><strong>MyISAM</strong></td><td>高速引擎,拥有较高的插入,查询速度,但<strong>不支持事务</strong></td></tr><tr><td><strong>InnoDB</strong></td><td>5.5版本后MySQL的默认数据库，支持事务和行级锁定，比MyISAM处理速度稍慢</td></tr><tr><td>ISAM</td><td>MyISAM的前身, MySQL5 . 0以后不再默认安装</td></tr><tr><td>MRG_ MyISAM ( MERGE )</td><td>将多个表联合成一个表使用，在超大规模数据存储时很有用</td></tr><tr><td><strong>Memory</strong></td><td><strong>内存存储引擎，拥有极高的插入，更新和查询效率</strong>。但是会占用和数据量成正比的内存空间。只在内存.上保存数据,意味着数据可能会丢失</td></tr><tr><td>Falcon</td><td>一种新的存储引擎,支持事物处理,传言可能是InnoDB的替代者</td></tr><tr><td>Archive</td><td>将数据压缩后进行存储,非常适合存储大量的独立的，作为历史记录的数据,但是只能进行插入和查询操作</td></tr><tr><td>CSV</td><td>CSV存储引擎是基于CSV 格式文件存储数据(应用于跨平台的数据交换)</td></tr></tbody></table><ul><li><p>查看存储引擎：</p><p><code>mysql&gt; show engines</code></p></li><li><p><strong>InnoDB和MyISAM存储引擎区别</strong></p></li></ul><table><thead><tr><th></th><th>Myisam</th><th>Innodb</th></tr></thead><tbody><tr><td><strong>存储文件</strong></td><td>.frm表定义文件<br><strong>. ibd数据文件和索引文件</strong></td><td>.frm表定义文件<br><strong>.myd数据文件<br>.myi索引文件.</strong></td></tr><tr><td><strong>锁</strong></td><td>表锁、<strong>行锁</strong></td><td>表锁</td></tr><tr><td><strong>事务</strong></td><td>支持</td><td>不支持</td></tr><tr><td><strong>CRDU</strong></td><td>读、写</td><td>读多</td></tr><tr><td><strong>count</strong></td><td>扫表</td><td>专门存储的地方</td></tr><tr><td><strong>索引结构</strong></td><td>B+ Tree</td><td>B+ Tree</td></tr></tbody></table><blockquote><p>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。</p><p>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。</p><p>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般</p></blockquote><h2 id="%E7%89%A9%E7%90%86%E6%96%87%E4%BB%B6"><a class="header-anchor" href="#%E7%89%A9%E7%90%86%E6%96%87%E4%BB%B6">¶</a> 物理文件</h2><h3 id="%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%EF%BC%88%E9%A1%BA%E5%BA%8FIO%EF%BC%89"><a class="header-anchor" href="#%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%EF%BC%88%E9%A1%BA%E5%BA%8FIO%EF%BC%89">¶</a> 日志文件（顺序IO）</h3><p>MySQL通过日志记录了数据库操作信息和错误信息。常用的日志文件包括错误日志、二进制日志、查询日志、慢查询日志和事务Redo日志、中继日志等。</p><h4 id="%E9%94%99%E8%AF%AF%E6%97%A5%E5%BF%97%EF%BC%88errorlog%EF%BC%89"><a class="header-anchor" href="#%E9%94%99%E8%AF%AF%E6%97%A5%E5%BF%97%EF%BC%88errorlog%EF%BC%89">¶</a> 错误日志（errorlog）</h4><p>默认是开启的,而且从5.5.7以后无法关闭错误日志,错误日志记录了运行过程中遇到的所有严重的错误信息,以及MySQL每次启动和关闭的详细信息。</p><h4 id="%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%97%A5%E5%BF%97(bin%20log%20)"><a class="header-anchor" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%97%A5%E5%BF%97(bin%20log%20)">¶</a> 二进制日志(bin log )</h4><p>默认是关闭的<br>binlog记录了数据库所有的dd1语句和dm1语句,但不包括select语句内容,语句以事件的形式保存,描述了数据的变更顺序, binlog还包括了每个更新语句的执行时间信息。如果是DDL语句,则直接记录到binlog日志,而DML语句,必须通过事务提交才能记录到binlog日志中。<br>binlog主要用于实现mysq1主从复制、数据备份、数据恢复。</p><h4 id="%E9%80%9A%E7%94%A8%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97(%20general%20query%20log%20)"><a class="header-anchor" href="#%E9%80%9A%E7%94%A8%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97(%20general%20query%20log%20)">¶</a> 通用查询日志( general query log )</h4><p>默认情况下通用查询日志是关闭的。</p><h4 id="%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97(%20slow%20query%20log%20)"><a class="header-anchor" href="#%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97(%20slow%20query%20log%20)">¶</a> 慢查询日志( slow query log )</h4><p>默认是关闭的。</p><h4 id="%E9%87%8D%E5%81%9A%E6%97%A5%E5%BF%97(%20redo%201og%20)"><a class="header-anchor" href="#%E9%87%8D%E5%81%9A%E6%97%A5%E5%BF%97(%20redo%201og%20)">¶</a> 重做日志( redo 1og )</h4><p>作用:</p><ul><li>确保事务的持久性。</li><li>防止在发生故障的时间点,尚有脏页未写入磁盘，在重启mysq1服务的时候，根据redo 1og进行重做，从而达到事务的持久性这一特性。</li></ul><h4 id="%E5%9B%9E%E6%BB%9A%E6%97%A5%E5%BF%97(%20undo%20log)"><a class="header-anchor" href="#%E5%9B%9E%E6%BB%9A%E6%97%A5%E5%BF%97(%20undo%20log)">¶</a> 回滚日志( undo log)</h4><p>作用:</p><ul><li>保存了事务发生之前的数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读( MVCC ) , 也即非锁定读</li></ul><h4 id="%E4%B8%AD%E7%BB%A7%E6%97%A5%E5%BF%97(%20relay%20log%20)"><a class="header-anchor" href="#%E4%B8%AD%E7%BB%A7%E6%97%A5%E5%BF%97(%20relay%20log%20)">¶</a> 中继日志( relay log )</h4><ul><li>是在主从复制环境中产生的日志。</li><li>主要作用是为了从机可以从中继日志中获取到主机同步过来的SQL语句，然后执行到从机中。</li></ul><h3 id="%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6(%E9%9A%8F%E6%9C%BAIO)"><a class="header-anchor" href="#%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6(%E9%9A%8F%E6%9C%BAIO)">¶</a> 数据文件(随机IO)</h3><p><img src="/2020/10/23/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9602/image-20201015211034313.png" alt="image-20201015211034313"></p><h4 id="InnoDB%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6"><a class="header-anchor" href="#InnoDB%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6">¶</a> InnoDB数据文件</h4><ul><li>.frm文件:主要存放与表相关的数据信息,主要包括表结构的定义信息</li><li>. ibd :使用独享表空间存储表数据和索引信息, 一张表对应一个ibd文件</li><li>ibdata文件 :使用共享表空间存储表数据和索引信息,所有表共同使用一个或者多个ibdata文件。</li></ul><h4 id="MyIsam%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6"><a class="header-anchor" href="#MyIsam%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6">¶</a> MyIsam数据文件</h4><ul><li>.frm文件:主要存放与表相关的数据信息,主要包括表结构的定义信息</li><li>. myd文件:主要用来存储表数据信息。</li><li>.myi文件:主要用来存储表数据文件中任何索引的数据树。</li></ul><hr><blockquote><p><a href="http://lampkins.gitee.io/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9601/">MySQL性能优化01：主题和目标</a></p><p><a href="http://lampkins.gitee.io/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9602/">MySQL性能优化02：MySQL架构篇</a></p><p><a href="http://lampkins.gitee.io/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9603/">MySQL性能优化03：MySQL性能分析篇</a></p><p><a href="http://lampkins.gitee.io/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9604/">MySQL性能优化04：MySQL索引篇01索引讲解</a></p><p><a href="http://lampkins.gitee.io/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9605/">MySQL性能优化05：MySQL索引篇02查看执行计划</a></p><p><a href="http://lampkins.gitee.io/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9606/">MySQL性能优化06：MySQL索引篇03索引失效分析</a></p><p><a href="http://lampkins.gitee.io/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9607/">MySQL性能优化07：性能优化篇</a></p></blockquote><script>    let imgs = document.getElementsByTagName('img');    for (let img of imgs) {        img.setAttribute('class', 'fancybox');    }</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.6.0/katex.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;MySQL架构介绍、存储引擎介绍、日志文件、数据文件介绍&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;MySQL%E6%9E%B6%E6%9E%84%E7%AF%87&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#MySQL%E6%9E%B6%E6%9E%84%E</summary>
      
    
    
    
    <category term="数据库" scheme="http://lampkins.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="MySQL性能优化" scheme="http://lampkins.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
    <category term="MySQL" scheme="http://lampkins.gitee.io/tags/MySQL/"/>
    
    <category term="索引" scheme="http://lampkins.gitee.io/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>MySQL性能优化01：主题和目标</title>
    <link href="http://lampkins.gitee.io/2020/10/23/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9601/"/>
    <id>http://lampkins.gitee.io/2020/10/23/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9601/</id>
    <published>2020-10-23T09:32:30.000Z</published>
    <updated>2020-10-30T13:46:51.069Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL课程主题和目标</p><h2 id="%E4%B8%BB%E9%A2%98%EF%BC%9A"><a class="header-anchor" href="#%E4%B8%BB%E9%A2%98%EF%BC%9A">¶</a> 主题：</h2><p>你真的会使用MySQL索引进行性能优化吗?</p><hr><h2 id="%E7%9B%AE%E6%A0%87"><a class="header-anchor" href="#%E7%9B%AE%E6%A0%87">¶</a> 目标</h2><ol><li><p>性能分析要从三驾马车开始(慢查询日志、<strong>explain执行计划</strong>、 show profile )</p></li><li><p>有了性能分析报告，接下来如何对性能进行优化呢？</p></li><li><p><strong>我们一定要搞清楚通过explain显示查询计划中关于索引是否被用到</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- id是主键</span></span><br><span class="line"><span class="comment">-- name是非唯一索引</span></span><br><span class="line"><span class="comment">-- MySQL在执行查询时一般只会用到一个索引（优化器去进行选择）</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">and</span> <span class="keyword">name</span>= <span class="string">&#x27;zhangsan&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>你知道MySQL的索引在执行过程中是如何被使用的吗？</strong></p></li><li><p><strong>你知道MySQL中的表数据和索引在底层是如何存储的吗？</strong></p></li><li><p>你了解聚集索引（ IOT索引组织表）和非聚集索引（堆组织表）的存储方式的不同吗？</p></li><li><p>你知道聚集索引中的主键索引和辅助索引是如何存储索引和数据的吗？</p></li><li><p>你会正确使用组合索引吗？</p></li><li><p>你明白最左前缀原则是怎么回事吗？</p></li><li><p>你明白什么是索引覆盖吗？索引覆盖如何优化检索性能？</p></li><li><p><strong>如何正确使用索引，才不会引起索引失效？</strong></p></li></ol><hr><blockquote><p><a href="http://lampkins.gitee.io/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9601/">MySQL性能优化01：主题和目标</a></p><p><a href="http://lampkins.gitee.io/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9602/">MySQL性能优化02：MySQL架构篇</a></p><p><a href="http://lampkins.gitee.io/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9603/">MySQL性能优化03：MySQL性能分析篇</a></p><p><a href="http://lampkins.gitee.io/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9604/">MySQL性能优化04：MySQL索引篇01索引讲解</a></p><p><a href="http://lampkins.gitee.io/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9605/">MySQL性能优化05：MySQL索引篇02查看执行计划</a></p><p><a href="http://lampkins.gitee.io/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9606/">MySQL性能优化06：MySQL索引篇03索引失效分析</a></p><p><a href="http://lampkins.gitee.io/2020/10/26/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9607/">MySQL性能优化07：性能优化篇</a></p></blockquote><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.6.0/katex.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;MySQL课程主题和目标&lt;/p&gt;
&lt;h2 id=&quot;%E4%B8%BB%E9%A2%98%EF%BC%9A&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#%E4%B8%BB%E9%A2%98%EF%BC%9A&quot;&gt;¶&lt;/a&gt; 主题：&lt;/h2&gt;
&lt;p&gt;你真的会</summary>
      
    
    
    
    <category term="数据库" scheme="http://lampkins.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="MySQL性能优化" scheme="http://lampkins.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
    <category term="MySQL" scheme="http://lampkins.gitee.io/tags/MySQL/"/>
    
    <category term="索引" scheme="http://lampkins.gitee.io/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>JMM Java内存模型</title>
    <link href="http://lampkins.gitee.io/2020/09/20/JMM-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>http://lampkins.gitee.io/2020/09/20/JMM-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</id>
    <published>2020-09-20T11:59:49.000Z</published>
    <updated>2020-11-05T11:40:31.629Z</updated>
    
    <content type="html"><![CDATA[<p>JMM Java内存模型的一些概念</p><hr><h1 id="JMM(Java%20Memory%20Model)"><a class="header-anchor" href="#JMM(Java%20Memory%20Model)">¶</a> JMM(Java Memory Model)</h1><h2 id="%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E4%B8%89%E4%B8%AA%E6%80%A7%E8%B4%A8"><a class="header-anchor" href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E4%B8%89%E4%B8%AA%E6%80%A7%E8%B4%A8">¶</a> 并发编程的三个性质</h2><p>JMM关键技术点是围绕着多线程的原子性、可见性、有序性来建立的。</p><h3 id="%E5%8E%9F%E5%AD%90%E6%80%A7"><a class="header-anchor" href="#%E5%8E%9F%E5%AD%90%E6%80%A7">¶</a> 原子性</h3><p>原子性是指<strong>一个操作是不可中断的，要么全部执行成功要么全部执行失败</strong>。</p><p>比如 a++ 操作，实际包含三步：</p><ol><li>读取变量a的值，假如a=1</li><li>a的值+1，为2</li><li>将2值赋值给变量a，此时a的值为2</li></ol><p>这三步是不可分割的，所以必须保证这3步操作时原子性的，在操作a++的过程中，其他线程不会改变a的值，如果在该过程中出现其他线程修改了a的值，上面的操作应该执行失败。</p><p>java中实现原子操作的方法大致有2种：<strong>锁机制、无锁CAS机制</strong></p><h3 id="%E5%8F%AF%E8%A7%81%E6%80%A7"><a class="header-anchor" href="#%E5%8F%AF%E8%A7%81%E6%80%A7">¶</a> 可见性</h3><p>可见性是指<strong>一个线程对共享变量的修改，对于其他线程来说是可以看到的</strong>。</p><p>共享变量可见性的<strong>实现原理</strong>：</p><ol><li>线程A在自己的工作内存中修改变量之后，需要将变量的值刷新到主内存中</li><li>线程B要把主内存中变量的值更新到工作内存中</li></ol><p>关于线程可见性的控制，可以使用<strong>volatile、synchronized、锁</strong>来实现</p><h3 id="%E6%9C%89%E5%BA%8F%E6%80%A7"><a class="header-anchor" href="#%E6%9C%89%E5%BA%8F%E6%80%A7">¶</a> 有序性</h3><p>有序性指的是<strong>程序按照代码的先后顺序执行</strong>。</p><p>为了性能优化，编译器和处理器会进行指令重排序，有时候会改变程序语句的先后顺序，比如程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>; <span class="comment">//1 </span></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">20</span>; <span class="comment">//2 </span></span><br><span class="line"><span class="keyword">int</span> c = a + b; <span class="comment">//3</span></span><br></pre></td></tr></table></figure><p>编译器优化后可能变成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> b = <span class="number">20</span>; <span class="comment">//1 </span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>; <span class="comment">//2 </span></span><br><span class="line"><span class="keyword">int</span> c = a + b; <span class="comment">//3</span></span><br></pre></td></tr></table></figure><h2 id="Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><a class="header-anchor" href="#Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B">¶</a> Java内存模型</h2><p>​JMM决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：<strong>线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本。</strong></p><p>​<strong>作用：</strong> 在并行机制的前提下，定义了一种规则，保证多个线程间可以有效正确地协同工作。</p><p>​本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。其关系模型图如下图所示：</p><p><img src="/2020/09/20/JMM-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/image-20201012155842619.png" alt="image-20201012155842619" class="fancybox"></p><p>从上图中可以看出，线程A需要和线程B通信，必须要经历下面2个步骤：</p><ol><li>首先，线程A把本地内存A中更新过的共享变量刷新到主内存中去</li><li>然后，线程B到主内存中去读取线程A之前已更新过的共享变量</li></ol><p><strong>一个例子</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">T1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">T1</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程&quot;</span> + <span class="keyword">this</span>.getName() + <span class="string">&quot; in&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (flag) &#123;;&#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程&quot;</span> + <span class="keyword">this</span>.getName() + <span class="string">&quot;停止了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> T1(<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="comment">//休眠1秒</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">//将flag置为false</span></span><br><span class="line">        flag = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后会发现程序无法终止，也就是说主线程将flag修改为false后，线程t1获取的flag的值依旧为true。</p><p><strong>可能的原因：</strong></p><ul><li><p>主线程修改了flag之后，未将其刷新到主内存，所以t1看不到</p></li><li><p>主线程将flag刷新到了主内存，但是t1一直读取的是自己工作内存中flag的值，没有去主内存中获 取flag最新的值</p></li></ul><p><strong>解决：</strong></p><p>​使用volatile修饰共享变量，<code>public volatile static boolean flag = true;</code></p><blockquote><p>被volatile修改的 变量有以下特点：</p><ol><li>线程中读取的时候，每次读取都会去主内存中读取共享变量最新的值，然后将其复制到工作内存</li><li>线程中修改了工作内存中变量的副本，修改之后会立即刷新到主内存</li></ol></blockquote><p><strong>运行结果：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">线程t1 in</span><br><span class="line">线程t1停止了</span><br></pre></td></tr></table></figure><p>从该例子可知，<strong>volatile解决了共享变量在多线程中可见性的问题</strong>。</p><blockquote><p>更多内容：<a href="https://blog.csdn.net/zs88897/article/details/106385245/">JMM理解整理</a></p></blockquote><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.6.0/katex.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;JMM Java内存模型的一些概念&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;JMM(Java%20Memory%20Model)&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#JMM(Java%20Memory%20Model)&quot;&gt;¶&lt;/a&gt; JMM(Java</summary>
      
    
    
    
    <category term="技术" scheme="http://lampkins.gitee.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Java" scheme="http://lampkins.gitee.io/tags/Java/"/>
    
    <category term="JMM" scheme="http://lampkins.gitee.io/tags/JMM/"/>
    
  </entry>
  
  <entry>
    <title>Java虚拟机 JVM笔记</title>
    <link href="http://lampkins.gitee.io/2020/09/20/Java%E8%99%9A%E6%8B%9F%E6%9C%BAJVM%E7%AC%94%E8%AE%B0/"/>
    <id>http://lampkins.gitee.io/2020/09/20/Java%E8%99%9A%E6%8B%9F%E6%9C%BAJVM%E7%AC%94%E8%AE%B0/</id>
    <published>2020-09-20T11:53:49.000Z</published>
    <updated>2020-11-05T11:40:03.571Z</updated>
    
    <content type="html"><![CDATA[<p>JVM是JRE的一部分，是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。</p><hr><h1 id="JVM%E6%8E%A2%E7%A9%B6"><a class="header-anchor" href="#JVM%E6%8E%A2%E7%A9%B6">¶</a> JVM探究</h1><ul><li>请你谈谈你对JVM的理解？java8虚拟机和之前的变化更新”</li><li>什么是OOM？什么是栈溢出StackOverFlowError？怎么分析？</li><li>JVM的常用调优参数有哪些？</li><li>内存快照如何抓取？怎么分析Dump文件?知道吗？谈谈JVM中，类加载器你的认识？</li></ul><blockquote><p><a href="https://processon.com/view/5c749debe4b0f9fba6921d15"><strong>jvm java运行时数据分析，垃圾回收</strong></a></p><p><a href="https://processon.com/view/5ea7a1b9e401fd21c196eb17"><strong>JVM内存模型完整版</strong></a></p></blockquote><h2 id="1.%20JVM%E7%9A%84%E4%BD%8D%E7%BD%AE"><a class="header-anchor" href="#1.%20JVM%E7%9A%84%E4%BD%8D%E7%BD%AE">¶</a> 1. JVM的位置</h2><p><img src="/2020/09/20/Java%E8%99%9A%E6%8B%9F%E6%9C%BAJVM%E7%AC%94%E8%AE%B0/image-20201004185637450.png" alt="image-20201004185637450" class="fancybox"></p><h2 id="2.%20JVM%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><a class="header-anchor" href="#2.%20JVM%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84">¶</a> 2. JVM的体系结构</h2><p><img src="/2020/09/20/Java%E8%99%9A%E6%8B%9F%E6%9C%BAJVM%E7%AC%94%E8%AE%B0/image-20201101152617785.png" alt="image-20201101152617785"></p><p><img src="/2020/09/20/Java%E8%99%9A%E6%8B%9F%E6%9C%BAJVM%E7%AC%94%E8%AE%B0/image-20201004214922822.png" alt="image-20201004214922822" class="fancybox"></p><p><img src="/2020/09/20/Java%E8%99%9A%E6%8B%9F%E6%9C%BAJVM%E7%AC%94%E8%AE%B0/image-20201005183502733.png" alt="创建对象内存分析" class="fancybox"></p><h2 id="3.%20%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><a class="header-anchor" href="#3.%20%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8">¶</a> 3. 类加载器</h2><p>作用：加载Class文件</p><p><img src="/2020/09/20/Java%E8%99%9A%E6%8B%9F%E6%9C%BAJVM%E7%AC%94%E8%AE%B0/image-20201004230714888.png" alt="image-20201004230714888" class="fancybox"></p><p>虚拟机自带的加载器</p><ol><li><p><strong>启动类（根）加载器 Bootstrap ClassLoader</strong></p><p>加载<code>java</code>核心库 <code>java.*</code>，<code>%JAVA_HOME%/lib</code>路径下的jar包，构造ExtClassLoader和AppClassLoader</p></li><li><p><strong>扩展类加载器 Extension ClassLoader</strong></p><p>加载扩展库，如<code>%JAVA_HOME%/jre/lib/ext</code> ，<code>javax.*</code>或者<code>java.ext.dir</code> 指定位置中的类，开发者可以直接使用标准扩展类加载器。</p></li><li><p><strong>应用程序（系统类）加载器 AppClassLoader</strong></p><p>加载程序所在的目录，如<code>user.dir</code>所在的位置的<code>class</code></p></li><li><p><strong>用户自定义类加载器 CustomClassLoader</strong></p><p>用户自定义的类加载器,可加载指定路径的<code>class</code>文件</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(classLoader); <span class="comment">//AppClassLoader</span></span><br><span class="line">System.out.println(classLoader.getParent()); <span class="comment">//ExtClassLoader jre\lib\ext</span></span><br><span class="line">System.out.println(classLoader.getParent().getParent); <span class="comment">//null jre\lib\rt.jar</span></span><br></pre></td></tr></table></figure><h2 id="4.%20%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><a class="header-anchor" href="#4.%20%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6">¶</a> 4. 双亲委派机制</h2><p>APP – EXC – BOOT</p><p>向上委托，向下查找</p><p><strong>过程</strong></p><ol><li>类加载器收到类加载的请求</li><li>检查该类是否已经被加载，是则直接使用，否则执行3</li><li>将这个请求向上委托给父类加载器去完成，一直向上委托，直到启动类加载器</li><li>启动类加载器检查是否能够加载当前这个类，能加载就结束，使用当前的加载器，否则， 抛出异常，通知子加载器进行加载</li><li>重复步骤4<br>Class Not Found ~</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">    <span class="comment">// 从内存中检查该类是否已被加载过，没有则执行加载流程</span></span><br><span class="line">    Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                c = parent.loadClass(name, <span class="keyword">false</span>); <span class="comment">// 委托给父类加载器加载</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                c = findBootstrapClassOrNull(name); <span class="comment">// 没有父类则委托给启动类加载器加载</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// ClassNotFoundException thrown if class not found from the non-null parent class loader</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果向上委托没有找到，则用当前加载器(不含启动类加载器)去查找并加载</span></span><br><span class="line">            c = findClass(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (resolve) &#123; <span class="comment">//是否需要在加载时解析类</span></span><br><span class="line">        resolveClass(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/09/20/Java%E8%99%9A%E6%8B%9F%E6%9C%BAJVM%E7%AC%94%E8%AE%B0/7634245-7b7882e1f4ea5d7d.png" alt="7634245-7b7882e1f4ea5d7d.png" class="fancybox"></p><p><strong>作用</strong></p><ul><li>防止加载同一个<code>.class</code>。通过委托向上一级询问，加载过了，就不用再加载一遍，保证数据安全</li><li>保证核心<code>.class</code>不能被篡改。通过委托方式，不会去篡改核心<code>.clas</code>，即使篡改也不会去加载，即使加载也不会是同一个<code>.class</code>对象了。不同的加载器加载同一个<code>.class</code>也不是同一个<code>Class</code>对象。这样保证了<code>Class</code>执行安全。</li></ul><h2 id="5.%20%E6%B2%99%E7%AE%B1%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6"><a class="header-anchor" href="#5.%20%E6%B2%99%E7%AE%B1%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6">¶</a> 5. 沙箱安全机制</h2><p>​沙箱是一个限制程序运行的环境。沙箱机制就是将 Java 代码限定在虚拟机(JVM)特定的运行范围中，并且严格限制代码对本地系统资源访问，通过这样的措施来保证对代码的有效隔离，防止对本地系统造成破坏。沙箱<strong>主要限制系统资源访问</strong>，那系统资源包括什么？——<code>CPU、内存、文件系统、网络</code>。不同级别的沙箱对这些资源访问的限制也可以不一样。</p><blockquote><p><a href="https://blog.csdn.net/qq_30336433/article/details/83268945">java中的安全模型(沙箱机制)</a></p></blockquote><h2 id="6.%20Native"><a class="header-anchor" href="#6.%20Native">¶</a> 6. Native</h2><p>native关键字：说明java的作用范围达不到了，进入本地方法栈，调用本地方法接口（JNI）去调用底层的库。</p><p><strong>JNI：Java Native Interface（Java本地方法接口）</strong><br>凡是带了native关键宇的方法就会进入本地方法栈，其他的就是Java栈</p><p><strong>Native Interface</strong>本地接口<br>本地接口的作用是融合不同的编程语言为Java所用，它的具体做法是在Native Method Stack中登记native方法，在(Execution Engine )执行引擎执行的时候加载Native Libraies.</p><p>​目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过Java程序驱动打印机或者Java系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间通信很发达，比如可以使用Socket通信，也可以使用Web Service等等，不多做介绍!</p><p><strong>Native Method Stack</strong></p><h2 id="7.%20PC%E5%AF%84%E5%AD%98%E5%99%A8"><a class="header-anchor" href="#7.%20PC%E5%AF%84%E5%AD%98%E5%99%A8">¶</a> 7. PC寄存器</h2><p>程序计数器: Program Counter Register<br>每个线程都有一个程序计数器，是线程私有的，就是一个指针， 指向方法区中的方法字节码(用来存储指向一条指令的地址，也即将要执行的指令代码)，在执行引擎读取下一-条指令,是一个非常小的内存空间，几乎可以忽略不计</p><h2 id="8.%20%E6%96%B9%E6%B3%95%E5%8C%BA%EF%BC%88%E9%9D%99%E6%80%81%E5%8C%BA%EF%BC%89"><a class="header-anchor" href="#8.%20%E6%96%B9%E6%B3%95%E5%8C%BA%EF%BC%88%E9%9D%99%E6%80%81%E5%8C%BA%EF%BC%89">¶</a> 8. 方法区（静态区）</h2><p>Method Area方法区<br>方法区是被所有线程共享,所有字段和方法字节码，以及-一些特殊方法，如构造函数,接口代码也在此定义，简单说，所有定义的方法的信息都保存在该区域，<strong>此区域属于共享区间</strong>；<br><mark>静态变量、常量、类信息(类元信息、属性、方法等)、串池、运行时常量池存在方法区中，但是实例变量存在堆内存中，和方法区无关</mark></p><p>​static、final、Class、常量池（对象字面量：基本类型的包装类对象字面量[-128,127]，String对象字面量）</p><ul><li><p>实现区域</p><p>永久代：存储包括类信息、常量、字符串常量、类静态变量、即时编译器编译后的代码等数据 <code>-XX:MaxPermSize</code></p><p>元空间：本质和永久代类似，区别是其并不在虚拟机中，而是使用本地内存 <code>-XX:MetaspaceSize -XX:MaxMetaspaceSize</code></p></li></ul><h2 id="9.%20%E6%A0%88%E5%86%85%E5%AD%98"><a class="header-anchor" href="#9.%20%E6%A0%88%E5%86%85%E5%AD%98">¶</a> 9. 栈内存</h2><p>栈（栈内存），主管线程的运行，生命周期和线程同步</p><p>线程结束栈内存就释放了，栈内存空了程序就结束了；不存在垃圾回收问题</p><p>栈内存常存放：局部变量 基本数据类型、对象引用、方法引用</p><p>栈内存运行原理：栈帧</p><p><img src="/2020/09/20/Java%E8%99%9A%E6%8B%9F%E6%9C%BAJVM%E7%AC%94%E8%AE%B0/image-20201005231633641.png" alt="栈内存及栈帧" class="fancybox"></p><blockquote><p><a href="https://www.cnblogs.com/yanl55555/p/12616356.html">Java虚拟机栈–栈帧</a></p></blockquote><h2 id="10.%20%E4%B8%89%E7%A7%8DJVM"><a class="header-anchor" href="#10.%20%E4%B8%89%E7%A7%8DJVM">¶</a> 10. 三种JVM</h2><ul><li>Sun公司：<code>Java HotSpot(TM) 64-Bit Server VM (build 25.221-b11, mixed mode)</code></li><li>BEA公司：<code>Oracle JRockit （原来的 Bea JRockit）</code></li><li>IBM公司：J9VM</li></ul><h2 id="11.%20%E5%A0%86%E5%86%85%E5%AD%98"><a class="header-anchor" href="#11.%20%E5%A0%86%E5%86%85%E5%AD%98">¶</a> 11. 堆内存</h2><p>Heap，一个JVM只有一个堆内存，堆内存的大小是可以调节的。<br>类加载器读取了类文件后，一般会把什么东西放到堆中？<mark>类, 方法，常量，变量，保存引用类型的真实对象</mark></p><p><img src="/2020/09/20/Java%E8%99%9A%E6%8B%9F%E6%9C%BAJVM%E7%AC%94%E8%AE%B0/image-20201006182522720.png" alt="堆内存模型" class="fancybox"></p><ul><li>新生区<ul><li>Eden区</li><li>Survivor from区</li><li>Survivor to区</li><li>8:1:1</li></ul></li><li>老年区</li><li>元空间  永久区</li></ul><p>轻GC在新生区，重GC(full GC)在老年区</p><p>假设内存满了，OOM，堆内存不够！ <code>java.lang.OutOfMemoryError: Java heap space</code></p><h2 id="12.%20%E6%96%B0%E7%94%9F%E5%8C%BA%20%E8%80%81%E5%B9%B4%E5%8C%BA"><a class="header-anchor" href="#12.%20%E6%96%B0%E7%94%9F%E5%8C%BA%20%E8%80%81%E5%B9%B4%E5%8C%BA">¶</a> 12. 新生区 老年区</h2><h2 id="13.%20%E6%B0%B8%E4%B9%85%E5%8C%BA"><a class="header-anchor" href="#13.%20%E6%B0%B8%E4%B9%85%E5%8C%BA">¶</a> 13. 永久区</h2><p>这个区域常驻内存的。用来存放JDK自身携带的lass对象。Interface元数据， 存储的是ava运行时的一些环境或类信息，不存在垃圾回收。关闭jvm虚拟机会释放这个区域的内存。</p><ul><li><p>jdk1.6之前：有永久代，字符串常量池和运行时常量池在方法区；</p></li><li><p>jdk1.7：有永久代，但已经逐步”去永久代“，字符串常量池移到堆中，运行时常量池还在方法区中(永久带)</p></li><li><p>jdk1.8之后：无永久代，被元空间所取代，字符串常量池在堆中，运行时常量池在元空间</p><p>最大区别：<mark>元空间并不在虚拟机中，而是使用本地内存。</mark></p></li></ul><h2 id="14.%20%E5%A0%86%E5%86%85%E5%AD%98%E8%B0%83%E4%BC%98"><a class="header-anchor" href="#14.%20%E5%A0%86%E5%86%85%E5%AD%98%E8%B0%83%E4%BC%98">¶</a> 14. 堆内存调优</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回jvm试图使用的最大内存</span></span><br><span class="line"><span class="keyword">long</span> max = Runtime.getRuntime().maxMemory();</span><br><span class="line"><span class="comment">// 返回jvm的初始化总内存，会随着时间发生变化</span></span><br><span class="line"><span class="keyword">long</span> total = Runtime.getRuntime().totalMemory();</span><br></pre></td></tr></table></figure><p>默认情况下，maxMemory是电脑内存的1/4，totalMemory是1/64</p><p><code>-Xms1024m -Xmx1024m -XX:+PrintGCDetails</code></p><blockquote><p>-Xms<size> 设置初始Java堆大小</size></p><p>Xmx<size> 设置最大Java堆大小</size></p></blockquote><p><img src="/2020/09/20/Java%E8%99%9A%E6%8B%9F%E6%9C%BAJVM%E7%AC%94%E8%AE%B0/image-20201006223130183.png" alt="image-20201006223130183"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -Xms8m -Xmx8m -XX:+PrintGCDetails</span></span><br><span class="line">String str = <span class="string">&quot;str&quot;</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">    str = str +<span class="keyword">new</span> Random().nextInt(<span class="number">999999999</span>)+str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 先进行了5次轻GC，Eden区进入Survivor区导致，满了（或者年龄即轻GC次数到了），进入老年代，老年代满了，进行第一次重GC，清理年轻代，清理老年代(丢弃或进入元空间)...最后Java堆 老年代和元空间都满了 抛出OOM异常</span></span><br></pre></td></tr></table></figure><p><img src="/2020/09/20/Java%E8%99%9A%E6%8B%9F%E6%9C%BAJVM%E7%AC%94%E8%AE%B0/image-20201006234524118.png" alt="image-20201006234524118"></p><blockquote><p>GC表示的是进行一次Minor GC<br>Allocation Failure：表示分配担保失败。<br>PSYoungGen：新生代采用Parallel Scavenge收集器<br>1536K-&gt;504K(2048K)：GC前该区域已使用容量-&gt;GC后该区域已经使用的容量(该区域总容量)<br>1536K-&gt;817K(7680K)：方括号外的数字表示 GC前Java堆已用容量-&gt;GC后Java堆容量(Java堆总容量)<br>0.0013784 secs：该内存区域GC所用的时间<br>Times: user=0.00 sys=0.00, real=0.00 secs：用户态消耗的CPU时间，内核态消耗的CPU时间，操作从开始到结束所经历的墙钟时间(Wall Clock Time)</p><p>Full GC完全的垃圾回收<br>Ergonomics工程<br>ParOldGen老年代采用Parallel Old收集器<br>Metaspace元数据空间垃圾回收</p></blockquote><h3 id="Java%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7"><a class="header-anchor" href="#Java%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7">¶</a> Java内存分析工具</h3><p>OOM，排错：</p><ol><li><p>尝试扩大堆内存看结果</p><ol start="2"><li>分析内存，看一下那里出现问题（工具分析）<ul><li>Debug，一行行分析代码</li><li>内存快照分析工具，MAT，JProfiler</li></ul></li></ol></li></ol><p><strong>MAT、Jprofiler作用：</strong></p><ul><li>分析Dump内存文件，快速定位内存泄露</li><li>获取堆中的数据</li><li>获得大的对象</li><li>…</li></ul><p>当抛出OOM时进行HeapDump：<code>-Xms1m -Xmx8m -XX:+HeapDumpOnOutOfMemoryError</code></p><blockquote><p><a href="https://blog.csdn.net/vicky_pyh/article/details/88797514">Jprofiler的安装和使用</a></p></blockquote><h2 id="15.%20GC"><a class="header-anchor" href="#15.%20GC">¶</a> 15. GC</h2><p><strong>目的：</strong> 回收堆内存中不再使用的对象，释放资源<br><strong>回收时间：</strong> 当对象永久地失去引用后，系统会在合适的时候回收它所占用的内存。</p><p><code>System.gc(); / Runtime.getRuntime().gc();</code></p><h3 id="15.1%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%B8%8E%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95"><a class="header-anchor" href="#15.1%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%B8%8E%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95">¶</a> 15.1 垃圾回收与常用算法</h3><h4 id="%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E5%9E%83%E5%9C%BE%EF%BC%9F"><a class="header-anchor" href="#%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E5%9E%83%E5%9C%BE%EF%BC%9F">¶</a> 如何确定垃圾？</h4><ul><li><p><strong>引用计数法</strong></p><p>​一个对象如果没有任何与之关联的引用，即他的引用计数都为0，则说明对象不太可能再被用到，那么这个对象就是可回收对象。会出现<strong>循环引用问题</strong></p></li></ul><p><img src="/2020/09/20/Java%E8%99%9A%E6%8B%9F%E6%9C%BAJVM%E7%AC%94%E8%AE%B0/image-20201007225319656.png" alt="image-20201007225319656" class="fancybox"></p><ul><li><p><strong>可达性分析</strong></p><p>​当一个对象到任意一个GC Roots对象没有任何引用链相连时，则称该对象是不可达的。 要注意的是，不可达对象不等价于可回收对象，不可达对象变为可回收对象至少要经过两次标记 过程。两次标记后仍然是可回收对象，则将面临回收。</p></li></ul><h4 id="%E5%A6%82%E4%BD%95%E6%B8%85%E9%99%A4%E5%9E%83%E5%9C%BE%EF%BC%9F"><a class="header-anchor" href="#%E5%A6%82%E4%BD%95%E6%B8%85%E9%99%A4%E5%9E%83%E5%9C%BE%EF%BC%9F">¶</a> 如何清除垃圾？</h4><ul><li><p><strong>复制算法</strong></p><p>将内存按内存容量划分为等大小的两块，当这块内存需要垃圾回收时,将此区域还存活的对象复制到另一块中，然后把这块内存清理掉。</p><p>每次对整个半区进行操作，解决了内存碎片化的问题，但会多使用一定的内存空间，且存活对象较多时，效率会大大降低。</p><p><strong>最佳应用场景：</strong> 对象存活度较低的时候，新生代</p><p><img src="/2020/09/20/Java%E8%99%9A%E6%8B%9F%E6%9C%BAJVM%E7%AC%94%E8%AE%B0/image-20201011155401200.png" alt="image-20201011155401200" class="fancybox"></p></li><li><p><strong>标记清除法</strong></p><p>最基础的垃圾回收算法，分为两个阶段，<mark>标记和清除</mark>。标记阶段标记出所有需要回收的对象，清除阶段回收所有被标记的对象。</p><p>内存碎片化严重，可能发生大对象找不到可利用空间的问题。</p><p><img src="/2020/09/20/Java%E8%99%9A%E6%8B%9F%E6%9C%BAJVM%E7%AC%94%E8%AE%B0/image-20201011155131800.png" alt="image-20201011155131800" class="fancybox"></p></li><li><p><strong>标记整理法</strong></p><p>标记后将存活对象移向内存的一端，然后清除端边界外的对象。</p><p>防止了内存碎片的产生，整理需耗用一定时间</p><p><img src="/2020/09/20/Java%E8%99%9A%E6%8B%9F%E6%9C%BAJVM%E7%AC%94%E8%AE%B0/image-20201011155936528.png" alt="image-20201011155936528" class="fancybox"></p></li><li><p><strong>标记清除整理</strong>：先标记清除，内存碎片较多时再使用标记整理</p></li><li><p><strong>分代收集法 GC</strong></p><p>根据对象存活的不同生命周期将内存划分为不同的域，一般情况下将 GC 堆划分为<mark>新生代(Young Generation)<mark>和</mark>老生代(Tenured/Old Generation)</mark>。</p><p><strong>新生代</strong>的特点是对象生存时间比较短，存活率低，每次可回收的垃圾对象较多，采用复制算法。</p><p>​<strong>HotSpot实现的复制算法流程：</strong></p><ol><li>当Eden区满的时候会触发第一次Minor gc，把还存活的对象拷贝到Survivor From区中。</li><li>当Eden区再一次触发Minor gc时，会对Eden区和Survivor From区进行垃圾回收,把还存活的对象复制到To区域,并将Eden和From区清空，此时Form和To名称交换。</li><li>有些对象会在From区和To区来回复制，如此交换15次(默认为15次,<code>-XX:MaxTenuringThreshold=15</code>)，最终如果还是存活，就存入老年代。</li></ol><p><strong>老生代</strong>的特点是空间比较大，存活率高，每次可回收的垃圾对象较少，采用标记清除(内存碎片较少)和标记整理算法。</p></li><li><p><strong>总结</strong></p><p>内存效率：复制算法 &gt; 标记清除算法 &gt; 标记整理算法(时间复杂度)<br>内存整齐度：复制算法 = 标记整理算法 &gt; 标记清除算法<br>内存利用率：标记整理算法 = 标记清除算法 &gt; 复制算法</p></li></ul><h2 id="16.%20JMM(Java%20Memory%20Model)"><a class="header-anchor" href="#16.%20JMM(Java%20Memory%20Model)">¶</a> 16. JMM(Java Memory Model)</h2><p>​JMM决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：<mark>线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本。</mark></p><p>​本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。其关系模型图如下图所示：JMM对这八种指令的使用，制定了如下规则：</p><p><img src="/2020/09/20/Java%E8%99%9A%E6%8B%9F%E6%9C%BAJVM%E7%AC%94%E8%AE%B0/image-20201012155842619.png" alt="image-20201012155842619" class="fancybox"></p><blockquote><p>更多内容：<a href="https://blog.csdn.net/TJtulong/article/details/89598598">深入理解java虚拟机（全章节完整）</a></p></blockquote><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.6.0/katex.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;JVM是JRE的一部分，是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;JVM%E6%8E%A2%E7%A9%B6&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#JVM%E6%8E%A2%</summary>
      
    
    
    
    <category term="Java" scheme="http://lampkins.gitee.io/categories/Java/"/>
    
    
    <category term="Java" scheme="http://lampkins.gitee.io/tags/Java/"/>
    
    <category term="JVM" scheme="http://lampkins.gitee.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Redis基础 学习笔记</title>
    <link href="http://lampkins.gitee.io/2020/09/16/Redis%E5%9F%BA%E7%A1%80-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://lampkins.gitee.io/2020/09/16/Redis%E5%9F%BA%E7%A1%80-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2020-09-16T14:14:16.000Z</published>
    <updated>2020-11-05T11:40:00.326Z</updated>
    
    <content type="html"><![CDATA[<p>Redis 是一个内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。</p><hr><h2 id="NoSQL%E6%A6%82%E8%BF%B0"><a class="header-anchor" href="#NoSQL%E6%A6%82%E8%BF%B0">¶</a> NoSQL概述</h2><p>NoSQL = Not Only SQL 不仅仅是SQL</p><p>关系型数据库：表格，行、列</p><p>很多的数据类型，如用户的个人信息、社交网络、地理位置。这些数据类型的存储不需要一个固定的格式， 不需要多余的操作就可以横向扩展。</p><h4 id="%E7%89%B9%E7%82%B9"><a class="header-anchor" href="#%E7%89%B9%E7%82%B9">¶</a> 特点</h4><ol><li>方便扩展(数据之间没有关系，很好扩展! )</li><li>大数据量高性能( Redis一秒写8万次，读取11万，NoSQL的缓存记录级是一种细粒度的缓存，性能高!)</li><li>数据类型是多样型的（不需要事先设计数据库，随取随用）</li><li>传统RDBMS和NoSQL</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">传统的 RDBMS</span><br><span class="line">- 结构化组织</span><br><span class="line">- SQL</span><br><span class="line">- 数据和关系都存在单独的表中</span><br><span class="line">- 操作操作，数据定义语言</span><br><span class="line">- 严格的一致性</span><br><span class="line">- 基础的事务</span><br><span class="line">- ...</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Nosq1</span><br><span class="line">- 不仅仅是数据</span><br><span class="line">- 没有固定的查询语言</span><br><span class="line">- 键值对存储，列存储，文档存储，图形数据库(社交关系)</span><br><span class="line">- 最终一致性，</span><br><span class="line">- CAP定理和BASE (异地多活)</span><br><span class="line">- 高性能，高可用，高可扩</span><br><span class="line">- ...</span><br></pre></td></tr></table></figure><blockquote><p>大数据的3V+3高</p><p>描述问题的：</p><ol><li>海量Volume</li><li>多样Variety</li><li>实时Velocity</li></ol><p>对程序的要求：</p><ol><li>高并发</li><li>高可拓</li><li>高性能</li></ol></blockquote><h2 id="%E4%BA%94%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><a class="header-anchor" href="#%E4%BA%94%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">¶</a> 五种基本数据类型</h2><h3 id="Key%EF%BC%88%E9%94%AE%EF%BC%89"><a class="header-anchor" href="#Key%EF%BC%88%E9%94%AE%EF%BC%89">¶</a> Key（键）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis-benchmark -h localhost -p 6379 -c 100 -n 100000</span><br><span class="line">select x<span class="comment">#切换数据库</span></span><br><span class="line">keys *<span class="comment">#查看数据库所有key</span></span><br><span class="line">del key <span class="comment">#删除key </span></span><br><span class="line">flushdb<span class="comment">#清空当前数据库</span></span><br><span class="line">flushall<span class="comment">#清空全部数据库</span></span><br><span class="line">exists key</span><br><span class="line"><span class="built_in">type</span> key</span><br><span class="line">move key 2<span class="comment">#将kv移动到指定的库</span></span><br><span class="line">expire key sec<span class="comment">#设置kv过期时间</span></span><br><span class="line">ttl key<span class="comment">#查看剩余时间</span></span><br></pre></td></tr></table></figure><h3 id="String(%E5%AD%97%E7%AC%A6%E4%B8%B2)"><a class="header-anchor" href="#String(%E5%AD%97%E7%AC%A6%E4%B8%B2)">¶</a> String(字符串)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&gt;strlen k1 <span class="comment">#获取value的长度</span></span><br><span class="line">&gt;append k1 str <span class="comment">#追加字符串，如果key不存在则相当于set key</span></span><br><span class="line"></span><br><span class="line">&gt;incr num <span class="comment">#加一</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">&gt;get num</span><br><span class="line"><span class="string">&quot;2&quot;</span></span><br><span class="line">&gt; decr num <span class="comment">#减一</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">&gt; incrby num 5 <span class="comment">#加一，步长为5</span></span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line">&gt; get k1</span><br><span class="line"><span class="string">&quot;strstr&quot;</span></span><br><span class="line">&gt;getrange k1 1 2 <span class="comment">#截取字符串[1, 2]</span></span><br><span class="line"><span class="string">&quot;tr&quot;</span></span><br><span class="line">&gt; getrange k1 1 -1 <span class="comment">#-1表示末尾</span></span><br><span class="line"><span class="string">&quot;trstr&quot;</span></span><br><span class="line">&gt; setrange k1 2 x <span class="comment">#替换指定位置的字符</span></span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line">get k1</span><br><span class="line"><span class="string">&quot;stxstr&quot;</span></span><br><span class="line"><span class="comment"># setex 设置含过期时间</span></span><br><span class="line"><span class="comment"># getnx key不存在才设置值（分布式锁中常用）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># msetmsetnx(当且仅当所有给定 key 都不存在才设值)</span></span><br><span class="line"><span class="comment">#mget</span></span><br><span class="line"><span class="comment"># HashTag即是用&#123;&#125;包裹key的一个子串，如&#123;k&#125;1，</span></span><br><span class="line"><span class="comment">#两个key拥有相同的HashTag:&#123;k&#125;, 它们会被分配到同一个slot，从而可使用MGET命令</span></span><br><span class="line">&gt; mset &#123;k&#125;1 v1 &#123;k&#125;2 v2 &#123;k&#125;3 v3</span><br><span class="line">OK</span><br><span class="line">mget &#123;k&#125;1 &#123;k&#125;2 &#123;k&#125;3</span><br><span class="line">1) <span class="string">&quot;v1&quot;</span></span><br><span class="line">2) <span class="string">&quot;v2&quot;</span></span><br><span class="line">3) <span class="string">&quot;v3&quot;</span></span><br><span class="line">&gt; <span class="built_in">set</span> user:1 &#123;name:zs,age:21&#125;</span><br><span class="line">OK</span><br><span class="line">&gt; get user:1</span><br><span class="line"><span class="string">&quot;&#123;name:zs,age:21&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># getset</span></span><br><span class="line">&gt; get k1</span><br><span class="line"><span class="string">&quot;str&quot;</span></span><br><span class="line">&gt; getset k1 str2 <span class="comment"># 获取原来的值并设置新的值</span></span><br><span class="line"><span class="string">&quot;str&quot;</span></span><br><span class="line">&gt; get k1</span><br><span class="line"><span class="string">&quot;str2&quot;</span></span><br></pre></td></tr></table></figure><p>String类型使用场景：</p><ul><li>计数器</li><li>统计多单位的数量</li><li>抢购<ul><li>通过exists判断是否存在，如果不存在则先通过setnx初始化值，之后通过decrby判断商品数是否大于0，大于则抢购成功，否则失败</li></ul></li></ul><h3 id="List%EF%BC%88%E5%88%97%E8%A1%A8%EF%BC%89"><a class="header-anchor" href="#List%EF%BC%88%E5%88%97%E8%A1%A8%EF%BC%89">¶</a> List（列表）</h3><p>栈、队列、阻塞队列</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">&gt; lpush l1 one <span class="comment">#将一个或多个值插入到列表 key 的表头</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">&gt; lpush l1 two</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">&gt; lpush l1 three</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">&gt; lrange l1 0 -1</span><br><span class="line">1) <span class="string">&quot;three&quot;</span></span><br><span class="line">2) <span class="string">&quot;two&quot;</span></span><br><span class="line">3) <span class="string">&quot;one&quot;</span></span><br><span class="line">&gt; rpush l1 rone <span class="comment">#将一个或多个值插入到列表 key 的表尾</span></span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">&gt; lrange l1 0 -1</span><br><span class="line">1) <span class="string">&quot;three&quot;</span></span><br><span class="line">2) <span class="string">&quot;two&quot;</span></span><br><span class="line">3) <span class="string">&quot;one&quot;</span></span><br><span class="line">4) <span class="string">&quot;rone&quot;</span></span><br><span class="line"></span><br><span class="line">&gt; lpop l1 <span class="comment">#移除并返回列表 key 的头元素。</span></span><br><span class="line"><span class="string">&quot;three&quot;</span></span><br><span class="line">&gt; rpop l1 <span class="comment">#移除并返回列表 key 的尾元素。</span></span><br><span class="line"><span class="string">&quot;rone&quot;</span></span><br><span class="line">&gt; lrange l1 0 -1</span><br><span class="line">1) <span class="string">&quot;two&quot;</span></span><br><span class="line">2) <span class="string">&quot;one&quot;</span></span><br><span class="line"></span><br><span class="line">&gt; lindex l1 0 <span class="comment">#返回列表 key 中，下标为 index 的元素。</span></span><br><span class="line"><span class="string">&quot;two&quot;</span></span><br><span class="line">&gt; lindex l1 -1</span><br><span class="line"><span class="string">&quot;one&quot;</span></span><br><span class="line"></span><br><span class="line">&gt; llen l1 <span class="comment">#返回列表的长度</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">&gt; lrange l1 0 -1</span><br><span class="line">1) <span class="string">&quot;three&quot;</span></span><br><span class="line">2) <span class="string">&quot;two&quot;</span></span><br><span class="line">3) <span class="string">&quot;one&quot;</span></span><br><span class="line">4) <span class="string">&quot;three&quot;</span></span><br><span class="line">&gt; lrem l1 2 three <span class="comment"># 移除列表中|count|个value元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">&gt; lrange l1 0 -1</span><br><span class="line">1) <span class="string">&quot;two&quot;</span></span><br><span class="line">2) <span class="string">&quot;one&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># count&gt;0: 表头-&gt;表尾；&lt;0: 表尾-&gt;表头；=0: 所有</span></span><br><span class="line">&gt; lrem l1 -1 three</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">&gt; lrange l1 0 -1</span><br><span class="line">1) <span class="string">&quot;three&quot;</span></span><br><span class="line">2) <span class="string">&quot;two&quot;</span></span><br><span class="line">3) <span class="string">&quot;one&quot;</span></span><br><span class="line">&gt; lrem l1 1 three</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">&gt; lrange l1 0 -1</span><br><span class="line">1) <span class="string">&quot;two&quot;</span></span><br><span class="line">2) <span class="string">&quot;one&quot;</span></span><br><span class="line">3) <span class="string">&quot;three&quot;</span></span><br><span class="line">&gt; lrem l1 0 three</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">&gt; lrange l1 0 -1</span><br><span class="line">1) <span class="string">&quot;two&quot;</span></span><br><span class="line">2) <span class="string">&quot;one&quot;</span></span><br><span class="line"></span><br><span class="line">&gt; lrange l1 0 -1</span><br><span class="line">1) <span class="string">&quot;hello&quot;</span></span><br><span class="line">2) <span class="string">&quot;two&quot;</span></span><br><span class="line">3) <span class="string">&quot;one&quot;</span></span><br><span class="line">4) <span class="string">&quot;value&quot;</span></span><br><span class="line">&gt; ltrim l1 2 3 <span class="comment">#修剪list</span></span><br><span class="line">OK</span><br><span class="line">&gt; lrange l1 0 -1</span><br><span class="line">1) <span class="string">&quot;one&quot;</span></span><br><span class="line">2) <span class="string">&quot;value&quot;</span></span><br><span class="line"></span><br><span class="line">&gt; lrange l1 0 -1</span><br><span class="line">1) <span class="string">&quot;one&quot;</span></span><br><span class="line">2) <span class="string">&quot;two&quot;</span></span><br><span class="line">3) <span class="string">&quot;three&quot;</span></span><br><span class="line"><span class="comment"># 将l1的最后一个元素弹出，并返回给客户端。</span></span><br><span class="line"><span class="comment"># 并将弹出的元素作为l2的头元素 （）</span></span><br><span class="line">&gt; rpoplpush l1 l2 </span><br><span class="line"><span class="string">&quot;three&quot;</span></span><br><span class="line">&gt; lrange l1 0 -1</span><br><span class="line">1) <span class="string">&quot;one&quot;</span></span><br><span class="line">2) <span class="string">&quot;two&quot;</span></span><br><span class="line">&gt; lrange l2 0 -1</span><br><span class="line">1) <span class="string">&quot;three&quot;</span></span><br><span class="line"></span><br><span class="line">&gt; exists l1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">&gt; lset l1 1 two2 <span class="comment">#将列表下标为index的值设置为value</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将value插入到列表的值pivot的前面或后面</span></span><br><span class="line"><span class="comment"># linsert key before|after pivot value</span></span><br><span class="line">&gt; linsert l1 after two2 insert</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br></pre></td></tr></table></figure><h3 id="Set%EF%BC%88%E9%9B%86%E5%90%88%EF%BC%89"><a class="header-anchor" href="#Set%EF%BC%88%E9%9B%86%E5%90%88%EF%BC%89">¶</a> Set（集合）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&gt; sadd set1 hello</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">&gt; sadd set1 one</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">&gt; sadd set1 two</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">&gt; smembers set1 <span class="comment">#查看set的所有成员</span></span><br><span class="line">1) <span class="string">&quot;two&quot;</span></span><br><span class="line">2) <span class="string">&quot;one&quot;</span></span><br><span class="line">3) <span class="string">&quot;hello&quot;</span></span><br><span class="line">&gt; sismember set1 one <span class="comment">#判断元素是否在集合中</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">&gt; scard set1 <span class="comment">#获取集合中元素数量</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">&gt; srem set1 one <span class="comment">#删除指定的元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">&gt; srandmember set1 </span><br><span class="line"><span class="string">&quot;hello&quot;</span></span><br><span class="line">&gt; srandmember set1 2 <span class="comment">#从集合中随机获取指定数量的元素</span></span><br><span class="line">1) <span class="string">&quot;memeber&quot;</span></span><br><span class="line">2) <span class="string">&quot;hello&quot;</span></span><br><span class="line">&gt; spop set1 [count] <span class="comment">#随机移除一个元素并返回该元素</span></span><br><span class="line"><span class="string">&quot;memeber&quot;</span></span><br><span class="line">&gt; smove set1 set2 two <span class="comment">#将该元素从一个集合中移动到另一个集合中</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 集合论：差集、交集、并集</span></span><br><span class="line">&gt; sadd &#123;<span class="built_in">set</span>&#125;1 one hello member</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">&gt; sadd &#123;<span class="built_in">set</span>&#125;2 one two three</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">&gt; sdiff &#123;<span class="built_in">set</span>&#125;1 &#123;<span class="built_in">set</span>&#125;2 <span class="comment">#差集 A-B</span></span><br><span class="line">1) <span class="string">&quot;member&quot;</span></span><br><span class="line">2) <span class="string">&quot;hello&quot;</span></span><br><span class="line">&gt; sinter &#123;<span class="built_in">set</span>&#125;1 &#123;<span class="built_in">set</span>&#125;2 <span class="comment">#交集 A∩B</span></span><br><span class="line">1) <span class="string">&quot;one&quot;</span></span><br><span class="line">&gt; sunion &#123;<span class="built_in">set</span>&#125;1 &#123;<span class="built_in">set</span>&#125;2 <span class="comment">#并集 A∪B</span></span><br><span class="line">1) <span class="string">&quot;one&quot;</span></span><br><span class="line">2) <span class="string">&quot;hello&quot;</span></span><br><span class="line">3) <span class="string">&quot;member&quot;</span></span><br><span class="line">4) <span class="string">&quot;three&quot;</span></span><br><span class="line">5) <span class="string">&quot;two&quot;</span></span><br></pre></td></tr></table></figure><ul><li>共同关注</li><li>推荐好友</li><li>···</li></ul><h3 id="SortedSet%EF%BC%88%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%EF%BC%89"><a class="header-anchor" href="#SortedSet%EF%BC%88%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%EF%BC%89">¶</a> SortedSet（有序集合）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&gt; zadd zset1 1 one</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">&gt; zadd zset1 2 two 3 three</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">&gt; zrange zset1 0 -1</span><br><span class="line">1) <span class="string">&quot;one&quot;</span></span><br><span class="line">2) <span class="string">&quot;two&quot;</span></span><br><span class="line">3) <span class="string">&quot;three&quot;</span></span><br><span class="line"></span><br><span class="line">&gt; zadd score 75 zhangsan 87 lisi 60 wangwu</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">&gt; zrange score 1 2 <span class="comment">#返回指定下标区间的成员，按score值递增排列</span></span><br><span class="line">1) <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">2) <span class="string">&quot;lisi&quot;</span></span><br><span class="line"><span class="comment"># 返回有序集中所有 score 值介于 min 和 max 之间(默认闭区间)的成员，并递增排列。</span></span><br><span class="line">&gt; zrangebyscore score -inf +inf <span class="comment">#区间[-∞, +∞]</span></span><br><span class="line">1) <span class="string">&quot;wangwu&quot;</span></span><br><span class="line">2) zhangsan </span><br><span class="line">3) <span class="string">&quot;lisi&quot;</span></span><br><span class="line">&gt; zrangebyscore score 75 100 <span class="comment">#区间[75, 100]</span></span><br><span class="line">1) zhangsan </span><br><span class="line">2) <span class="string">&quot;lisi&quot;</span></span><br><span class="line">&gt; zrangebyscore score (75 +inf <span class="comment">#区间(75, 100]</span></span><br><span class="line">1) <span class="string">&quot;lisi&quot;</span></span><br><span class="line">&gt; zrangebyscore score (75 +inf withscores</span><br><span class="line">1) <span class="string">&quot;lisi&quot;</span></span><br><span class="line">2) <span class="string">&quot;87&quot;</span></span><br><span class="line">&gt; zrevrange score 1 2</span><br><span class="line"><span class="comment"># 返回有序集中所有 score 值介于 max 和 min 之间(默认闭区间)的成员，并递减排列。</span></span><br><span class="line">&gt; zrevrangebyscore score 100 75</span><br><span class="line">1) <span class="string">&quot;lisi&quot;</span></span><br><span class="line">2) <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">&gt; zcount score 75 80</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">&gt; zrem score lisi</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">&gt; zcard score</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br></pre></td></tr></table></figure><ul><li>1,普通消息 2, 重要消息   带权重存储</li></ul><h3 id="Hash%EF%BC%88%E5%93%88%E5%B8%8C%EF%BC%89"><a class="header-anchor" href="#Hash%EF%BC%88%E5%93%88%E5%B8%8C%EF%BC%89">¶</a> Hash（哈希）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&gt; hset h1 f1 v1 <span class="comment">#将哈希表 key 中的域 field 的值设为 value 。</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">&gt; hget h1 f1</span><br><span class="line"><span class="string">&quot;v1&quot;</span></span><br><span class="line">&gt; hmset h1 f1 v11 f2 hello f3 ye</span><br><span class="line">OK</span><br><span class="line">&gt; hmget h1 f1 f2 </span><br><span class="line">1) <span class="string">&quot;v11&quot;</span></span><br><span class="line">2) <span class="string">&quot;hello&quot;</span></span><br><span class="line">&gt; hgetall h1 <span class="comment">#获取全部的域和值</span></span><br><span class="line">&gt; hdel h1 f3 <span class="comment">#删除指定的域</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">&gt; hlen h1</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">&gt; hkeys h1 <span class="comment">#获取所有的域</span></span><br><span class="line">1) <span class="string">&quot;f1&quot;</span></span><br><span class="line">2) <span class="string">&quot;f2&quot;</span></span><br><span class="line">&gt; hvals h1 <span class="comment">#获取所有域的值</span></span><br><span class="line">1) <span class="string">&quot;v11&quot;</span></span><br><span class="line">2) <span class="string">&quot;hello&quot;</span></span><br><span class="line"></span><br><span class="line">&gt; hset h1 f3 3</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">&gt; hincrby h1 f3 2 <span class="comment">#加上一个值</span></span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br></pre></td></tr></table></figure><h2 id="%E4%B8%89%E7%A7%8D%E7%89%B9%E6%AE%8A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><a class="header-anchor" href="#%E4%B8%89%E7%A7%8D%E7%89%B9%E6%AE%8A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">¶</a> 三种特殊数据类型</h2><h3 id="Geospatial%EF%BC%88%E5%9C%B0%E7%90%86%E4%BD%8D%E7%BD%AE%EF%BC%89"><a class="header-anchor" href="#Geospatial%EF%BC%88%E5%9C%B0%E7%90%86%E4%BD%8D%E7%BD%AE%EF%BC%89">¶</a> Geospatial（地理位置）</h3><p>存储到sorted set中</p><ul><li>朋友定位</li><li>附近的人</li><li>打车距离</li><li>···</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt; geoadd china:city 104.065735 30.659462 ChengDu <span class="comment">#添加位置的经纬度</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">&gt; geoadd china:city 116.405285 39.904989 BeiJing 121.472644 31.231706 ShangHai</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">&gt; geopos china:city ChengDu <span class="comment">#获取指定成员的经纬度</span></span><br><span class="line">1) 1) <span class="string">&quot;104.06573742628097534&quot;</span></span><br><span class="line">   2) <span class="string">&quot;30.65946118872339099&quot;</span></span><br><span class="line">&gt; geopos china:city BeiJing ShangHai</span><br><span class="line">1) 1) <span class="string">&quot;116.40528291463851929&quot;</span></span><br><span class="line">   2) <span class="string">&quot;39.9049884229125027&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;121.47264629602432251&quot;</span></span><br><span class="line">   2) <span class="string">&quot;31.23170490709807012&quot;</span></span><br></pre></td></tr></table></figure><p><strong>GEODIST key member1 member2 [unit]</strong><br>unit:</p><ul><li>m 表示单位为米。</li><li>km 表示单位为千米。</li><li>mi 表示单位为英里。</li><li>ft 表示单位为英尺。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; geodist china:city ChengDu ShangHai <span class="comment">#获取成都到上海的直线距离</span></span><br><span class="line"><span class="string">&quot;1660019.7699&quot;</span></span><br><span class="line">&gt; geodist china:city ChengDu ShangHai km</span><br><span class="line"><span class="string">&quot;1660.0198&quot;</span></span><br></pre></td></tr></table></figure><p><strong>GEORADIUS key longitude latitude radius m|km|ft|mi [WITHCOORD(经纬度)] [WITHDIST(距离)] [WITHHASH] [COUNT count]</strong><br>以给定的经纬度为中心， 返回键包含的位置元素当中， 与中心的距离不超过给定最大距离的所有位置元素。<br><strong>GEORADIUSBYMEMBER key member radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count]</strong><br>以给定成员为中心， 返回键包含的位置元素当中， 与中心的距离不超过给定最大距离的所有位置元素。</p><ul><li>附近的人 （当前定位+半径）</li><li>···</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt; georadius china:city 104 30 100 km</span><br><span class="line">1) <span class="string">&quot;wuhou&quot;</span></span><br><span class="line">2) <span class="string">&quot;jingjiang&quot;</span></span><br><span class="line">3) <span class="string">&quot;ChengDu&quot;</span></span><br><span class="line">&gt; georadius china:city 104 30 100 km withdist</span><br><span class="line">1) 1) <span class="string">&quot;wuhou&quot;</span></span><br><span class="line">   2) <span class="string">&quot;71.5655&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;jingjiang&quot;</span></span><br><span class="line">   2) <span class="string">&quot;73.4188&quot;</span></span><br><span class="line">3) 1) <span class="string">&quot;ChengDu&quot;</span></span><br><span class="line">   2) <span class="string">&quot;73.6204&quot;</span></span><br><span class="line">&gt; georadius china:city 104 30 100000 m withdist count 1</span><br><span class="line">1) 1) <span class="string">&quot;wuhou&quot;</span></span><br><span class="line">   2) <span class="string">&quot;71565.4799&quot;</span></span><br><span class="line">&gt; georadiusbymember china:city ChengDu 100 km</span><br><span class="line">1) <span class="string">&quot;jingjiang&quot;</span></span><br><span class="line">2) <span class="string">&quot;ChengDu&quot;</span></span><br><span class="line">3) <span class="string">&quot;wuhou&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 该命令将返回11个字符的Geohash字符串</span></span><br><span class="line">&gt; geohash china:city jingjiang wuhou</span><br><span class="line">1) <span class="string">&quot;wm6n2kz2bw0&quot;</span></span><br><span class="line">2) <span class="string">&quot;wm3yrd3bd70&quot;</span></span><br></pre></td></tr></table></figure><h3 id="HyperLogLogs"><a class="header-anchor" href="#HyperLogLogs">¶</a> HyperLogLogs</h3><p>基数计算：统计一批数据中的不重复元素的个数<br>优点：占用固定的内存大小，最多2^64 12kb，大小和元素个数有关<br>缺点：有0.81%的标准误差，不能获取元素本身</p><ul><li>记录一天会执行多少次各不相同的搜索查询</li><li>···</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; pfadd &#123;pf&#125;1 a b c d <span class="comment">#将元素存入HyperLogLogs结构中</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">&gt; pfadd &#123;pf&#125;2 c d e f g</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">&gt; pfcount &#123;pf&#125;1 <span class="comment">#返回其近似基数，</span></span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">&gt; pfcount &#123;pf&#125;1 &#123;pf&#125;2</span><br><span class="line">(<span class="built_in">integer</span>) 7</span><br><span class="line">&gt; pfmerge &#123;pf&#125;3 &#123;pf&#125;1 &#123;pf&#125;2 <span class="comment">#合并两组集合，并集</span></span><br><span class="line">OK</span><br><span class="line">&gt; pfcount &#123;pf&#125;3</span><br><span class="line">(<span class="built_in">integer</span>) 7</span><br></pre></td></tr></table></figure><h3 id="Bitmap"><a class="header-anchor" href="#Bitmap">¶</a> Bitmap</h3><p>Blob类型，最大512MB</p><ul><li>签到打卡 365 bit=45.625 byte</li><li>统计活跃用户（或运算）</li><li>用户是否在线</li><li>···</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt; setbit signin 0 1 <span class="comment">#设置或者清空key的value(字符串)在offset处的bit值。</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">&gt; setbit signin 1 0</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">&gt; setbit signin 2 0</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">&gt; setbit signin 3 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">&gt; setbit signin 4 0</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">&gt; setbit signin 5 0</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">&gt; getbit signin 4 <span class="comment">#返回offset处的bit值</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">&gt; bitcount signin</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">&gt; BITOP AND dest key1 key2</span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br></pre></td></tr></table></figure><h2 id="%E4%BA%8B%E5%8A%A1"><a class="header-anchor" href="#%E4%BA%8B%E5%8A%A1">¶</a> 事务</h2><h3 id="Redis%E7%9A%84%E4%BA%8B%E5%8A%A1"><a class="header-anchor" href="#Redis%E7%9A%84%E4%BA%8B%E5%8A%A1">¶</a> Redis的事务</h3><ul><li>开启事务（multi）</li><li>命令入队（…）</li><li>执行事务（exec）</li><li>取消事务 （discard）<br>编译时异常：如命令错误，事务中所有的命令都不会被执行<br>运行时异常：事务队列中，错误的命令抛出运行时异常，但其他命令是可以正常执行的</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">set</span> str string</span><br><span class="line">OK</span><br><span class="line">&gt; multi</span><br><span class="line">OK</span><br><span class="line">&gt; get str <span class="comment">#语法错误，事务不会被执行</span></span><br><span class="line">QUEUED</span><br><span class="line">&gt; <span class="built_in">set</span> str</span><br><span class="line">(error) ERR wrong number of arguments <span class="keyword">for</span> <span class="string">&#x27;set&#x27;</span> <span class="built_in">command</span></span><br><span class="line">&gt; <span class="built_in">exec</span></span><br><span class="line">(error) EXECABORT Transaction discarded because of previous errors.</span><br><span class="line"></span><br><span class="line">&gt; multi</span><br><span class="line">OK</span><br><span class="line">&gt; incr str <span class="comment">#会产生运行时异常，事务中的该条命令不会被执行</span></span><br><span class="line">QUEUED</span><br><span class="line">&gt; get str <span class="comment"># 正常执行</span></span><br><span class="line">QUEUED</span><br><span class="line">&gt; <span class="built_in">exec</span></span><br><span class="line">1) (error) ERR value is not an <span class="built_in">integer</span> or out of range</span><br><span class="line">2) <span class="string">&quot;string&quot;</span></span><br></pre></td></tr></table></figure><h3 id="%E7%9B%91%E6%8E%A7%20Watch"><a class="header-anchor" href="#%E7%9B%91%E6%8E%A7%20Watch">¶</a> 监控 Watch</h3><p>监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。<br><strong>悲观锁</strong></p><ul><li>认为写操作多，遇到并发写的可能性高，以每次在读写数据的时候都会上锁</li><li>java中的悲观锁就是Synchronized</li></ul><p><strong>乐观锁</strong></p><ul><li>认为读多写少，遇到并发写的可能性低</li><li>不会上锁，提交更新时会对数据冲突进行检测（比较版本号），失败则要重复读-比较-写的操作</li><li>CAS、version控制</li></ul><p>正常执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">set</span> &#123;a&#125;money 100</span><br><span class="line">OK</span><br><span class="line">&gt; <span class="built_in">set</span> &#123;a&#125;out 0</span><br><span class="line">OK</span><br><span class="line">&gt; watch money</span><br><span class="line">OK</span><br><span class="line">&gt; multi</span><br><span class="line">OK</span><br><span class="line">&gt; DECRBY money 20</span><br><span class="line">QUEUED</span><br><span class="line">&gt; INCRBY out 20</span><br><span class="line">QUEUED</span><br><span class="line">&gt; <span class="built_in">exec</span></span><br><span class="line">1) (<span class="built_in">integer</span>) 80</span><br><span class="line">2) (<span class="built_in">integer</span>) 20</span><br></pre></td></tr></table></figure><p>测试多进程修改值。如果修改失败，获取最新的值就行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; watch money</span><br><span class="line">OK</span><br><span class="line">&gt; multi</span><br><span class="line">OK</span><br><span class="line">&gt; DECRBY money 10</span><br><span class="line">QUEUED</span><br><span class="line">&gt; INCRBY out 10</span><br><span class="line">QUEUED</span><br><span class="line">&gt; <span class="built_in">exec</span> <span class="comment">#执行之前，另一个线程修改了值，这时就会导致事务执行失败</span></span><br><span class="line">(nil)</span><br><span class="line"></span><br><span class="line">&gt; unwatch <span class="comment"># 如果发现事务执行失败，则先解锁再重新监视（select version）</span></span><br><span class="line">OK</span><br><span class="line">&gt; watch money </span><br></pre></td></tr></table></figure><h2 id="SpringBoot%E6%95%B4%E5%90%88"><a class="header-anchor" href="#SpringBoot%E6%95%B4%E5%90%88">¶</a> SpringBoot整合</h2><p><strong>jedis</strong>：采用直连Redis Server，线程不安全，像BIO<br><strong>lettuce</strong>：连接基于netty，连接实例可以再多个线程间共享，线程安全，像NIO</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(name = &#123;&quot;redisTemplate&quot;&#125;)</span></span><br><span class="line"><span class="comment">// 默认的RedisTemplate设置较少</span></span><br><span class="line"><span class="comment">// 泛型都是Object，需要强转为&lt;Sring, Object&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> <span class="keyword">throws</span> UnknownHostException </span>&#123;</span><br><span class="line">    RedisTemplate&lt;Object, Object&gt; template = <span class="keyword">new</span> RedisTemplate();</span><br><span class="line">    template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">    <span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span> </span><br><span class="line"><span class="comment">//由于String比较常用，所以单独封装了一个</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StringRedisTemplate <span class="title">stringRedisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> <span class="keyword">throws</span> UnknownHostException </span>&#123;</span><br><span class="line">    StringRedisTemplate template = <span class="keyword">new</span> StringRedisTemplate();</span><br><span class="line">    template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">    <span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义RedisTemplate</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">redisTemplate</span><span class="params">(LettuceConnectionFactory lettuceConnectionFactory)</span> </span>&#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">        template.setConnectionFactory(lettuceConnectionFactory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Json序列化配置</span></span><br><span class="line">        Jackson2JsonRedisSerializer&lt;Object&gt; jackson2JsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer&lt;&gt;(Object.class);</span><br><span class="line">        ObjectMapper om = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        <span class="comment">// 指定要序列化的域，field,get和set,以及修饰符范围，ANY是都有包括private和public</span></span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        <span class="comment">// 指定序列化输入的类型，类必须是非final修饰的，final修饰的类，比如String,Integer等会抛出异常</span></span><br><span class="line">        om.activateDefaultTyping(LaissezFaireSubTypeValidator.instance, ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// key和hash的key 采用String的序列化方式</span></span><br><span class="line">        template.setKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line">        template.setHashKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line">        <span class="comment">// value和hash的value 采用Jackson的序列化方式</span></span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Redis.conf"><a class="header-anchor" href="#Redis.conf">¶</a> Redis.conf</h2><h3 id="1.%20%E5%8C%85%E5%90%AB%20INCLUDES"><a class="header-anchor" href="#1.%20%E5%8C%85%E5%90%AB%20INCLUDES">¶</a> 1. 包含 INCLUDES</h3><p><img src="/2020/09/16/Redis%E5%9F%BA%E7%A1%80-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20201001180930883-1603273481613.png" alt="0" class="fancybox"></p><h3 id="2.%20%E7%BD%91%E7%BB%9C%20NETWORK"><a class="header-anchor" href="#2.%20%E7%BD%91%E7%BB%9C%20NETWORK">¶</a> 2. 网络 NETWORK</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bind</span> 192.168.26.128 127.0.0.1 <span class="comment"># 绑定的ip</span></span><br><span class="line">protected-mode yes <span class="comment"># 保护模式</span></span><br><span class="line">port 6379 <span class="comment"># 端口设置</span></span><br></pre></td></tr></table></figure><h3 id="3.%20%E9%80%9A%E7%94%A8%E9%85%8D%E7%BD%AE%20GENERAL"><a class="header-anchor" href="#3.%20%E9%80%9A%E7%94%A8%E9%85%8D%E7%BD%AE%20GENERAL">¶</a> 3. 通用配置 GENERAL</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">daemonize yes <span class="comment"># 以守护进程的方式运行，默认为no</span></span><br><span class="line">supervised no <span class="comment"># 可以通过upstart和systemd管理Redis守护进程, no/upstart/systemd/auto</span></span><br><span class="line">pidfile /var/run/redis_6379.pid <span class="comment"># 如果以后台的方式运行，需要指定一个pid文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 日志</span></span><br><span class="line"><span class="comment"># Specify the server verbosity level.</span></span><br><span class="line"><span class="comment"># This can be one of:</span></span><br><span class="line"><span class="comment"># debug (a lot of information, useful for development/testing)</span></span><br><span class="line"><span class="comment"># verbose (many rarely useful info, but not a mess like the debug level)</span></span><br><span class="line"><span class="comment"># notice (moderately verbose, what you want in production probably)</span></span><br><span class="line"><span class="comment"># warning (only very important / critical messages are logged)</span></span><br><span class="line">loglevel notice</span><br><span class="line">logfile <span class="string">&quot;&quot;</span> <span class="comment"># 日志文件路径</span></span><br><span class="line"> </span><br><span class="line">databases 16 <span class="comment"># 默认16个数据库</span></span><br><span class="line">always-show-logo yes <span class="comment"># 显示Redis Logo</span></span><br></pre></td></tr></table></figure><h3 id="4.%20%E5%BF%AB%E7%85%A7%20SNAPSHOTTING"><a class="header-anchor" href="#4.%20%E5%BF%AB%E7%85%A7%20SNAPSHOTTING">¶</a> 4. 快照 SNAPSHOTTING</h3><p>持久化，在规定的时间内执行了多少次写操作，则会持久化到文件中，rdb、aof。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">save 900 1 <span class="comment"># 如果至少有1个key发生变化，900秒后则会进行持久化操作</span></span><br><span class="line">save 300 10 <span class="comment"># 如果至少有是10个key发生变化，300秒后则会进行持久化操作</span></span><br><span class="line">save 60 10000 <span class="comment"># 如果至少有是10000个key发生变化，60秒后则会进行持久化操作</span></span><br><span class="line"></span><br><span class="line">stop-writes-on-bgsave-error no <span class="comment"># 持久化出错后，是否需要继续工作</span></span><br><span class="line">rdbcompression yes <span class="comment"># 是否压缩rdb文件，需要消耗一CPU资源</span></span><br><span class="line">rdbchecksum yes <span class="comment"># 保存和加载rdb文件时是否进行错误的检查效验</span></span><br><span class="line">dbfilename dump.rdb <span class="comment"># rdb文件名</span></span><br><span class="line">dir ./ <span class="comment"># rdb文件保存路径</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5.%20%E5%A4%8D%E5%88%B6%20REPLICATION"><a class="header-anchor" href="#5.%20%E5%A4%8D%E5%88%B6%20REPLICATION">¶</a> 5. 复制 REPLICATION</h3><p>主从复制</p><h3 id="6.%20%E5%AE%89%E5%85%A8%20SECURITY"><a class="header-anchor" href="#6.%20%E5%AE%89%E5%85%A8%20SECURITY">¶</a> 6. 安全 SECURITY</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">requirepass foobared <span class="comment"># 设置密码</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过命令更改密码</span></span><br><span class="line">&gt; config get requirepass</span><br><span class="line">1) <span class="string">&quot;requirepass&quot;</span></span><br><span class="line">2) <span class="string">&quot;&quot;</span></span><br><span class="line">&gt; config <span class="built_in">set</span> requirepass <span class="string">&quot;123456&quot;</span></span><br><span class="line">OK</span><br><span class="line">&gt; ping</span><br><span class="line">(error) NOAUTH Authentication required.</span><br><span class="line">&gt; auth 123456</span><br><span class="line">OK</span><br><span class="line">&gt; config get requirepass</span><br><span class="line">1) <span class="string">&quot;requirepass&quot;</span></span><br><span class="line">2) <span class="string">&quot;123456&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="7.%20%E5%AE%A2%E6%88%B7%E7%AB%AF%20CLIENTS"><a class="header-anchor" href="#7.%20%E5%AE%A2%E6%88%B7%E7%AB%AF%20CLIENTS">¶</a> 7. 客户端 CLIENTS</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxclients 10000 <span class="comment"># 设置同时连接的最大客户端数量</span></span><br></pre></td></tr></table></figure><h3 id="8.%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%20MEMORY%20MANAGEMENT"><a class="header-anchor" href="#8.%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%20MEMORY%20MANAGEMENT">¶</a> 8. 内存管理 MEMORY MANAGEMENT</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">maxmemory &lt;bytes&gt; <span class="comment"># 配置Redis最大内存限制</span></span><br><span class="line"></span><br><span class="line">axmemory-policy noeviction <span class="comment">#达到内存上限时Redis采用的清除策略</span></span><br><span class="line">    1）volatile-lru利用LRU算法移除有设置过期时间的key (LRU:最近使用 Least Recently Used ) </span><br><span class="line">    2）allkeys-lru利用LRU算法移除任何key </span><br><span class="line">    3）volatile-random移除有设置过期时间的随机key </span><br><span class="line">    4）allkeys-random移除随机key</span><br><span class="line">    5）volatile-ttl移除即将过期的key(minor TTL) </span><br><span class="line">    6）noeviction  noeviction不移除任何key，只是返回一个写错误 。默认选项</span><br></pre></td></tr></table></figure><h3 id="9.%20AOF%E9%85%8D%E7%BD%AE%20APPEND%20ONLY%20MODE"><a class="header-anchor" href="#9.%20AOF%E9%85%8D%E7%BD%AE%20APPEND%20ONLY%20MODE">¶</a> 9. AOF配置 APPEND ONLY MODE</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">appendonly no <span class="comment"># 默认不开启aof，在大部分情况下rdb已经够用了</span></span><br><span class="line">appendfilename <span class="string">&quot;appendonly.aof&quot;</span> <span class="comment"># 持久化的文件名</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># appendfsync always # 每次修改都会fsync()，安全但比较慢且耗性能</span></span><br><span class="line">appendfsync everysec <span class="comment"># 每秒执行一次fsync()，可能丢失1s的数据</span></span><br><span class="line"><span class="comment"># appendfsync no # 不执行fsync()，让操作系统自己同步数据，最快</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重写规则</span></span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line">auto-aof-rewrite-percentage 100 <span class="comment">#当aof日志大小增长率大于该值时，自动开启重写</span></span><br><span class="line">auto-aof-rewrite-min-size 64mb <span class="comment">#当aof日志大小增长到该值时，自动开启重写</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Redis%E6%8C%81%E4%B9%85%E5%8C%96"><a class="header-anchor" href="#Redis%E6%8C%81%E4%B9%85%E5%8C%96">¶</a> Redis持久化</h2><p>Redis是内存数据库，如果没有持久化，那么断电后就会失去数据，所以Redis提供了持久化的功能。</p><h3 id="RDB%EF%BC%88Redis%20Database%EF%BC%89"><a class="header-anchor" href="#RDB%EF%BC%88Redis%20Database%EF%BC%89">¶</a> RDB（Redis Database）</h3><p>在指定的时间间隔类将内存中的数据集进行快照存储，恢复的时候则将快照文件加载到内存中。</p><p><img src="/2020/09/16/Redis%E5%9F%BA%E7%A1%80-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20201002175210711-1603273481614.png" alt="rdb持久化过程" class="fancybox"></p><p>RDB在保存文件时父进程会单独创建（fork）一个子线程来进行持久化操作，先将数据写入一个临时文件中，写完成后，再用其替换掉上次已持久化的文件。整个过程主线程不进行IO操作，故而确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那么RDB方式要比AOF方式更加的高效。</p><p><strong>触发机制</strong></p><ol><li>save的规则满足的情况下，会自动触发RDB操作</li><li>执行flushall命令</li><li>退出Redis，也会产生RDB 文件</li></ol><p>备份就自动生成了一个dump.rdb文件</p><p><strong>恢复rdb文件</strong></p><ol><li><p>只需要将rbd文件放在Redis配置目录，启动时会自动检查dump.rdb并从中恢复数据</p></li><li><p>查看rdb文件保存路径</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; config get dir </span><br><span class="line">1) <span class="string">&quot;dir&quot;</span></span><br><span class="line">2) <span class="string">&quot;/usr/local/redis/redis-cluster/7001&quot;</span></span><br></pre></td></tr></table></figure><p><strong>优点：</strong></p><ul><li>RDB是一个单一的紧凑的文件，方便传输</li><li>适用于数据集的备份，可以根据需求恢复到不同版本的数据集</li><li>适合大规模的数据恢复</li></ul><p><strong>缺点:</strong></p><ul><li>由于需要一定时间间隔进行操作，在Redis意外宕机时丢失的数据较多</li><li>当数据集比较大的时候，创建子进程的过程是非常耗时的，可能会导致Redis在一些毫秒级内不能响应客户端的请求。</li></ul><h3 id="AOF%EF%BC%88Append%20Only%20File%EF%BC%89"><a class="header-anchor" href="#AOF%EF%BC%88Append%20Only%20File%EF%BC%89">¶</a> AOF（Append Only File）</h3><p>以日志文本的形式记录Redis所处理的每一个写操作，恢复的时候把文件汇中的命令都执行一遍即可。</p><p>命令实时写入和重写(rewrite)，由于缓存的写操作是实时写入aof文件，当触发重写规则（如：aof文件过大）时，会重新生成恢复当前数据集所需的最小命令集合，即rewrite操作。</p><p><img src="/2020/09/16/Redis%E5%9F%BA%E7%A1%80-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20201002191438203-1603273481614.png" alt="rewrite流程" class="fancybox"></p><p>appendonly.aof</p><p>如果aof文件有问题，redis启动不了，可以通过<code>redis-check-aof --fix</code>工具修复aof文件。</p><p><strong>优点：</strong></p><ul><li>每一次修改都同步，文件的完整性更好</li><li>每秒fsync时，可能会丢失一秒的数据，</li></ul><p><strong>缺点:</strong></p><ul><li>对于相同的数据集来说，aof文件体积远大于rdb，修复速度也比rdb慢</li><li>根据所使用的 fsync 策略，AOF 的速度可能会慢于 RDB。在处理巨大的写入载入时，RDB 可以提供更有保证的最大延迟时间（latency）</li></ul><p><img src="/2020/09/16/Redis%E5%9F%BA%E7%A1%80-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20201002223857890-1603273481615.png" alt="image-20201002223857890" class="fancybox"></p><p><img src="/2020/09/16/Redis%E5%9F%BA%E7%A1%80-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20201002223944105-1603273481615.png" alt="image-20201002223944105" class="fancybox"></p><h2 id="Redis%E5%8F%91%E5%B8%83%E4%B8%8E%E8%AE%A2%E9%98%85"><a class="header-anchor" href="#Redis%E5%8F%91%E5%B8%83%E4%B8%8E%E8%AE%A2%E9%98%85">¶</a> Redis发布与订阅</h2><p>Redis发布订阅(pub/sub)是一种<mark>消息通信模式</mark>：发送者(pub)发送消息，订阅者(sub)接收消息。传送消息的链路称为<mark>信道</mark>。</p><p><img src="/2020/09/16/Redis%E5%9F%BA%E7%A1%80-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20201002225013710-1603273481615.png" alt="image-20201002225013710" class="fancybox"></p><p><strong>命令</strong></p><table><thead><tr><th>序号</th><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td><a href="https://www.runoob.com/redis/pub-sub-psubscribe.html">PSUBSCRIBE pattern [pattern …]</a></td><td>订阅一个或多个符合给定模式的频道。</td></tr><tr><td>2</td><td>[PUBSUB subcommand <a href="https://www.runoob.com/redis/pub-sub-pubsub.html">argument [argument …]]</a></td><td>查看订阅与发布系统状态。</td></tr><tr><td>3</td><td><a href="https://www.runoob.com/redis/pub-sub-publish.html">PUBLISH channel message</a></td><td>将信息发送到指定的频道。</td></tr><tr><td>4</td><td>[ PUNSUBSCRIBE <a href="https://www.runoob.com/redis/pub-sub-punsubscribe.html">pattern [pattern …]]</a></td><td>退订所有给定模式的频道。</td></tr><tr><td>5</td><td><a href="https://www.runoob.com/redis/pub-sub-subscribe.html"> SUBSCRIBE channel [channel …]</a></td><td>订阅给定的一个或多个频道的信息。</td></tr><tr><td>6</td><td>[ UNSUBSCRIBE <a href="https://www.runoob.com/redis/pub-sub-unsubscribe.html">channel [channel …]]</a></td><td>只退订给定的频道。</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; SUBSCRIBE MyChannel <span class="comment"># 订阅频道</span></span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) <span class="string">&quot;subscribe&quot;</span></span><br><span class="line">2) <span class="string">&quot;MyChannel&quot;</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment"># 等待读取推送的信息</span></span><br><span class="line">1) <span class="string">&quot;message&quot;</span> <span class="comment"># 消息</span></span><br><span class="line">2) <span class="string">&quot;MyChannel&quot;</span> <span class="comment"># 来自哪个频道的消息</span></span><br><span class="line">3) <span class="string">&quot;hello,test&quot;</span> <span class="comment"># 消息的具体内容</span></span><br><span class="line"></span><br><span class="line">&gt; PUBLISH MyChannel <span class="string">&quot;hello,test&quot;</span> <span class="comment"># 将信息发送到指定的频道</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure><p><strong>使用场景</strong></p><ul><li>用于构建即时通信应用，如：网络聊天室、实时广播、实时提醒等</li><li>订阅、关注系统</li></ul><p>较复杂的场景会使用消息中间件 MQ</p><p><img src="/2020/09/16/Redis%E5%9F%BA%E7%A1%80-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20201002232010221-1603273481615.png" alt="image-20201002232010221" class="fancybox"></p><h2 id="Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><a class="header-anchor" href="#Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6">¶</a> Redis主从复制</h2><h4 id="%E6%A6%82%E5%BF%B5"><a class="header-anchor" href="#%E6%A6%82%E5%BF%B5">¶</a> 概念</h4><p>主从复制,是指将一台Redis服务器的数据,复制到其他的Redis服务器。前者称为主节点(master/leader)，后者称为从节点(slave/follower) ；数据的复制是单向的，只能由主节点到从节点。Master以写为主，Slave 以读为主（读写分离）。</p><p>默认情况下，每台Redis服务器都是主节点；且一个主节点可以有多个从节点(或没有从节点) ，但一个从节点只能有一个主节点。</p><p>主从复制的作用主要包括：</p><ol><li><strong>数据冗余：</strong> 主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。</li><li><strong>故障恢复：</strong> 当主节点出现问题时，可以由从节点提供服务,实现快速的故障恢复；实际上是-一种服务的冗余。</li><li><strong>负载均衡：</strong> 在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务(即写Redis数据时应用连接主节点,读Redis数据时应用连接从节点)，分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。</li><li><strong>高可用基石：</strong> 除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。</li></ol><p><img src="/2020/09/16/Redis%E5%9F%BA%E7%A1%80-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20201003180444252-1603273481615.png" alt="image-20201003180444252" class="fancybox"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; info replication <span class="comment"># 查看当前redis节点信息</span></span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:1</span><br><span class="line">slave0:ip=192.168.26.128,port=7006,state=online,offset=280,lag=1</span><br><span class="line">master_replid:8a90b2da230485bb190eb2e443bb324cbb8d7371</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:280</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:280</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="%E6%90%AD%E5%BB%BA"><a class="header-anchor" href="#%E6%90%AD%E5%BB%BA">¶</a> <strong>搭建</strong></h4><h5 id="1.%20%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><a class="header-anchor" href="#1.%20%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">¶</a> 1. 修改配置文件</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bind</span> </span><br><span class="line">port 7001</span><br><span class="line">daemonize yes</span><br><span class="line">pidfile /var/run/redis_7001.pid</span><br><span class="line">logfile <span class="string">&quot;redis_7001.log&quot;</span></span><br><span class="line">dbfilename dump_7006.rdb</span><br><span class="line">cluster-enabled yes <span class="comment"># 开启集群  </span></span><br><span class="line">cluster-config-file nodes_7001.conf   <span class="comment"># 集群的配置 配置文件</span></span><br><span class="line">cluster-node-timeout  15000      </span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="2.%20%E8%84%9A%E6%9C%AC%E5%90%AF%E5%8A%A8%E6%96%87%E4%BB%B6start.sh"><a class="header-anchor" href="#2.%20%E8%84%9A%E6%9C%AC%E5%90%AF%E5%8A%A8%E6%96%87%E4%BB%B6start.sh">¶</a> 2. 脚本启动文件<code>start.sh</code></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">cd</span> 7001 &amp;&amp; ../../bin/redis-server redis.conf</span><br><span class="line"><span class="built_in">cd</span> ../7002 &amp;&amp; ../../bin/redis-server redis.conf</span><br><span class="line"><span class="built_in">cd</span> ../7003 &amp;&amp; ../../bin/redis-server redis.conf</span><br><span class="line"><span class="built_in">cd</span> ..</span><br></pre></td></tr></table></figure><h5 id="3.%20%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%A8%A1%E5%BC%8F%E9%85%8D%E7%BD%AE%EF%BC%88master-slave%20replication%EF%BC%89%EF%BC%88%E8%BF%98%E6%9C%89%E5%A4%9A%E7%BA%A7%E5%A4%8D%E5%88%B6%EF%BC%89"><a class="header-anchor" href="#3.%20%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%A8%A1%E5%BC%8F%E9%85%8D%E7%BD%AE%EF%BC%88master-slave%20replication%EF%BC%89%EF%BC%88%E8%BF%98%E6%9C%89%E5%A4%9A%E7%BA%A7%E5%A4%8D%E5%88%B6%EF%BC%89">¶</a> 3. 主从复制模式配置（master-slave replication）（还有多级复制）</h5><ul><li><p>一主二从，命令中配置，本次运行有效</p><p>主机可以设置值，从机只能读；</p><p>主机宕机后，从机依旧连接到主机，主机重启后从机会自动连接上；</p><p>从机重启后，则会变为主机，只要又设置为从机，则会立即从主机复制数据；</p><p>如果主机断开了连接，可以使用<code>SLAVEOF no one</code>让自己变成主机，其他的节点就可以手动连接到最新的这个主节点( 手动选举)。</p></li></ul><blockquote><p>复制原理</p><p>Slave启动成功连接到master后会发送一个sync同步命令<br>Master接到命令，启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后， <mark>master将传送整个数据文件到slave，并完成一-次完全同步。</mark><br><strong>全量复制：</strong> 而slave服务在接收到数据库文件数据后,将其存盘并加载到内存中。<br><strong>增量复制：</strong> Master继续将新的所有收集到的修改命令依次传给slave，完成同步<br>但是只要是重新连接master , 一次完全同步(全量复制)将被自动执行</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&gt;SLAVEOF 127.0.0.1 7001</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:slave <span class="comment"># 从节点</span></span><br><span class="line">master_host:192.168.26.128</span><br><span class="line">master_port:7001 <span class="comment"># 它的主节点</span></span><br><span class="line">master_link_status:up</span><br><span class="line">master_last_io_seconds_ago:1</span><br><span class="line">master_sync_in_progress:0</span><br><span class="line">slave_repl_offset:2128</span><br><span class="line">slave_priority:100</span><br><span class="line">slave_read_only:1</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_replid:c4b29fdc590e84132d6055078fa03306a6ed1cbf</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:2128</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:2128</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="4.%20%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%EF%BC%88%20Sentinel%EF%BC%89"><a class="header-anchor" href="#4.%20%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%EF%BC%88%20Sentinel%EF%BC%89">¶</a> 4. 哨兵模式（ Sentinel）</h5><p>哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程,作为进程,它会独立运行。</p><p>三个任务：</p><ul><li><strong>监控（Monitoring）</strong>： Sentinel 会不断地检查主服务器和从服务器是否运作正常。</li></ul><ul><li><strong>提醒（Notification）</strong>： 当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。</li><li><strong>自动故障迁移（Automatic failover）</strong>：当一个主服务器不能正常工作时， Sentinel 会使用投票协议（agreement protocols）来决定是否执行自动故障迁移， 以及选择哪个从服务器作为新的主服务器。</li></ul><p><img src="/2020/09/16/Redis%E5%9F%BA%E7%A1%80-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20201003193304549-1603273481616.png" alt="哨兵模式" class="fancybox"></p><p>这里的哨兵有两个作用</p><ul><li>通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器。</li><li>当哨兵监测到master宕机，会自动将slave切换成master，然后通过<mark>发布订阅</mark>模式通知其他的从服务器,修改配置文件，让它们切换主机。</li></ul><p>然而一个哨兵进程对Redis服务器进行监控,可能会出现问题，为此，我们可以使用多个哨兵进行监控。各个哨兵之间还会进行监控,这样就形成了多哨兵模式。</p><p><img src="/2020/09/16/Redis%E5%9F%BA%E7%A1%80-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20201003193545996-1603273481616.png" alt="多哨兵模式" class="fancybox"></p><p>假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行failover过程，仅仅是哨兵1主观的认为主服务器不可用，这个现象成为<strong>主观下线</strong>。当后面的哨兵也检测到主服务器不可用,并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover[故障转移]操作。切换成功后，就会通过发布订阅模式,让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为<strong>客观下线</strong>。</p><p><strong>配置</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 监视一个名为mymaster的主服务器，其IP为127.0.0.1和port为7001，</span></span><br><span class="line"><span class="comment"># 2代表至少需要2个Sentinel同意（大多数Sentinel正常），该服务器才被判断为已失效宕机 </span></span><br><span class="line">sentinel monitor mymaster 127.0.0.1 7001 2</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看节点信息</span></span><br><span class="line">./redis-cli -h 192.168.26.128 -c -p 7001 cluster nodes</span><br></pre></td></tr></table></figure><h2 id="Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%92%8C%E9%9B%AA%E5%B4%A9"><a class="header-anchor" href="#Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%92%8C%E9%9B%AA%E5%B4%A9">¶</a> Redis缓存穿透和雪崩</h2><p>Redis缓存的使用，极大的提升了应用程序的性能和效率，特别是数据查询方面。但同时，它也带来了一些问题。其中，最要害的问题，就是数据的一致性问题，从严格意义上讲，这个问题无解。如果对数据的一致性要求很高，那么就不能使用缓存。</p><p>另外的一些典型问题就是，缓存穿透、缓存雪崩和缓存击穿。目前，业界也都有比较流行的解决方案。</p><p><img src="/2020/09/16/Redis%E5%9F%BA%E7%A1%80-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20201021164003157.png" alt="image-20201021164003157" class="fancybox"></p><h4 id="%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><a class="header-anchor" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F">¶</a> 缓存穿透</h4><blockquote><p><strong>概念：</strong></p></blockquote><p>​缓存穿透的概念很简单，用户想要查询一个数据，发现redis数据库没有，即缓存未命中，于是从持久层数据库查询。发现也没有，则本次查询失败。当用户很多的时候，缓存都没有命中(秒杀! )，于是都去请求持久层数据库。这就给持久层数据库带来很大的压力，这时候就相当于出现了缓存穿透。</p><blockquote><p><strong>解决方案：</strong></p></blockquote><p><strong>布隆过滤器</strong></p><p>布隆过滤器是一种数据结构，对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃，从而避免了对底层存储系统的查询压力;</p><p><img src="/2020/09/16/Redis%E5%9F%BA%E7%A1%80-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20201021165228987.png" alt="image-20201021165228987" class="fancybox"></p><p><strong>缓存空对象</strong></p><p>当存储层未命中后，即使返回的是空对象也将其缓存起来，同时设置一个过期时间，之后再访问该数据将会从缓存中获取，避免了给后端数据库带来压力。</p><p><img src="/2020/09/16/Redis%E5%9F%BA%E7%A1%80-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20201021165652288.png" alt="image-20201021165652288" class="fancybox"></p><p>但是这种方法会存在两个问题：</p><ol><li>如果空值能够被缓存起来，这就意味着缓存需要更多的空间存储更多的键；</li><li>即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响。</li></ol><h4 id="%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><a class="header-anchor" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF">¶</a> 缓存击穿</h4><blockquote><p><strong>概述</strong></p></blockquote><p>​这里需要注意和缓存击穿的区别缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。</p><p>​当某个key在过期的瞬间，有大量的请求并发访问，这类数据一般是热点数据，由于缓存过期，会同时访问数据库来查询最新数据，并且回写缓存，会导使数据库瞬间压力过大。</p><blockquote><p><strong>解决方案</strong></p></blockquote><p><strong>设置热点数据永不过期</strong></p><p>从缓存层面来看，没有设置过期时间，所以不会出现热点key过期后产生的问题。</p><p><strong>加互斥锁</strong></p><p>分布式锁：使用分布式锁，保证对于每个key同时只有一个线程去查询后端服务，其他线程没有获得分布式锁的权限，因此只需要等待即可。这种方式将高井发的压力转移到了分布式锁，因此对分布式锁的考验很大。</p><p><img src="/2020/09/16/Redis%E5%9F%BA%E7%A1%80-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20201021170505844.png" alt="image-20201021170505844" class="fancybox"></p><h4 id="%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><a class="header-anchor" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9">¶</a> 缓存雪崩</h4><p>缓存雪崩，是指在某一个时间段，缓存集中过期失效，Redis 宕机。</p><p>比如在写本文的时候,马上就要到双11零点，很快就会迎来一波抢购，这波商品时间比较集中的放入了缓存，假设缓存一个小时。那么到了凌晨一点钟的时候，这批商品的缓存就都过期了。而对这批商品的访问查询，都落到了数据库上，对于数据库而言,就会产生周期性的压力波峰。于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况。</p><p><img src="/2020/09/16/Redis%E5%9F%BA%E7%A1%80-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20201021170804287.png" alt="image-20201021170804287" class="fancybox"></p><p>其实集中过期，倒不是非常致命，比较致命的缓存雪崩，是缓存服务器某个节点宕机或断网。因为自然形成的缓存雪崩，一定是在某个时间段集中创建缓存，这个时候，数据库也是可以顶住压力的。无非就是对数据库产生周期性的压力而已。而缓存服务节点的宕机，对数据库服务器造成的压力是不可预知的，很有可能瞬间就把数据库压垮。</p><p>双11：停掉一些服务，( 保证主要的服务可用 )</p><blockquote><p><strong>解决方案</strong></p></blockquote><p><strong>redis高可用</strong></p><p>这个思想的含义是，既然redis有可能挂掉，那我多增设几台redis，这样一台挂掉之后其他的还可以继续工作，其实就是搭建的集群。（异地多活）</p><p><strong>限流降级</strong></p><p>这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。</p><p><strong>数据预热</strong></p><p>数据加热的含义就是在正式部署之前，先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。</p><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.6.0/katex.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Redis 是一个内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;NoSQL%E6%A6%82%E8%BF%B0&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#NoSQL%E6%A6%82%E8%BF%B</summary>
      
    
    
    
    <category term="数据库" scheme="http://lampkins.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="Java" scheme="http://lampkins.gitee.io/tags/Java/"/>
    
    <category term="Redis" scheme="http://lampkins.gitee.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Markdown Demo 测试</title>
    <link href="http://lampkins.gitee.io/2020/09/12/Markdown-Demo-%E6%B5%8B%E8%AF%95/"/>
    <id>http://lampkins.gitee.io/2020/09/12/Markdown-Demo-%E6%B5%8B%E8%AF%95/</id>
    <published>2020-09-12T04:14:10.000Z</published>
    <updated>2020-10-31T11:50:38.870Z</updated>
    
    <content type="html"><![CDATA[<p>这是一个段落。<br>这是一个段落。</p><a id="more"></a><h1 id="%E4%B8%80%E7%BA%A7%E6%A0%87%E9%A2%98"><a class="header-anchor" href="#%E4%B8%80%E7%BA%A7%E6%A0%87%E9%A2%98">¶</a> 一级标题</h1><h2 id="%E4%BA%8C%E7%BA%A7%E6%A0%87%E9%A2%98"><a class="header-anchor" href="#%E4%BA%8C%E7%BA%A7%E6%A0%87%E9%A2%98">¶</a> 二级标题</h2><h1 id="%E4%B8%80%E7%BA%A7%E6%A0%87%E9%A2%98-2"><a class="header-anchor" href="#%E4%B8%80%E7%BA%A7%E6%A0%87%E9%A2%98-2">¶</a> 一级标题</h1><h2 id="%E4%BA%8C%E7%BA%A7%E6%A0%87%E9%A2%98-2"><a class="header-anchor" href="#%E4%BA%8C%E7%BA%A7%E6%A0%87%E9%A2%98-2">¶</a> 二级标题</h2><h3 id="%E4%B8%89%E7%BA%A7%E6%A0%87%E9%A2%98"><a class="header-anchor" href="#%E4%B8%89%E7%BA%A7%E6%A0%87%E9%A2%98">¶</a> 三级标题</h3><h4 id="%E5%9B%9B%E7%BA%A7%E6%A0%87%E9%A2%98"><a class="header-anchor" href="#%E5%9B%9B%E7%BA%A7%E6%A0%87%E9%A2%98">¶</a> 四级标题</h4><h5 id="%E4%BA%94%E7%BA%A7%E6%A0%87%E9%A2%98"><a class="header-anchor" href="#%E4%BA%94%E7%BA%A7%E6%A0%87%E9%A2%98">¶</a> 五级标题</h5><h6 id="%E5%85%AD%E7%BA%A7%E6%A0%87%E9%A2%98"><a class="header-anchor" href="#%E5%85%AD%E7%BA%A7%E6%A0%87%E9%A2%98">¶</a> 六级标题</h6><blockquote><p>区块引用</p><blockquote><p>嵌套引用</p></blockquote></blockquote><ul><li>第一项<ul><li>第一项</li><li>第二项</li><li>第三项</li></ul></li><li>第二项<ul><li>第一项</li><li>第二项</li><li>第三项</li></ul></li><li>第三项<ol><li>第一项</li><li>第二项</li><li>第三项</li></ol></li></ul><hr><hr><hr><pre><code>void main()&#123;    printf(&quot;Hello, Markdown.&quot;);&#125;</code></pre><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, Markdown.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">1</th><th style="text-align:center">2</th><th style="text-align:right">3</th></tr></thead><tbody><tr><td style="text-align:left">aaaaa</td><td style="text-align:center">bbbbb</td><td style="text-align:right">ccccc</td></tr><tr><td style="text-align:left"><em>ABC</em></td><td style="text-align:center"><em>123</em></td><td style="text-align:right"><em>abc</em></td></tr></tbody></table><ul><li><input type="checkbox" id="checkbox0"><label for="checkbox0">任务A</label></li><li><input type="checkbox" id="checkbox1" checked="true"><label for="checkbox1">任务B</label><ul><li><input type="checkbox" id="checkbox2" checked="true"><label for="checkbox2">任务1</label></li><li><input type="checkbox" id="checkbox3" checked="true"><label for="checkbox3">任务2</label></li><li><input type="checkbox" id="checkbox4" checked="true"><label for="checkbox4">任务3</label></li></ul></li><li><input type="checkbox" id="checkbox5"><label for="checkbox5">任务C</label></li></ul><dl><dt>Definition</dt><dd>这是一个定义。</dd></dl><p><a href="https://www.baidu.com/">https://www.baidu.com/</a><br><a href="https://www.baidu.com/" title="Baidu">链接</a><br><a href="https://www.baidu.com/" title="Baidu">链接</a><br><img src="https://www.baidu.com/img/bd_logo1.png" alt="图片" title="Baidu" class="fancybox"><br><img src="https://www.baidu.com/img/bd_logo1.png" alt="图片" title="Baidu" class="fancybox center-block"></p><p><img src="https://www.baidu.com/img/bd_logo1.png" class="fancybox center-block"></p><p><a href="#anchor" title="Anchor">锚点</a><br><a href="#anchor" title="Anchor">锚点</a></p><p id="anchor" name="anchor">锚点</p><p>这是一个脚注<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。</p><p>这是一个缩写（<abbr title="Hyper Text Markup Language">HTML</abbr>）。</p><p>H<sup>2</sup>，H<sub>2</sub><br><em>斜体</em>，<em>斜体</em><br><strong>粗体</strong>，<strong>粗体</strong><br><em><strong>粗斜体</strong></em>，<em><strong>粗斜体</strong></em><br><s>删除</s>，<ins>插入</ins>，<mark>标记</mark><br><code>printf(&quot;Hello, Markdown.&quot;);</code></p><p>\，`，*，_，{}，[]，()，#，+，-，.，!</p><p>&amp;，&lt;，©，😄，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mo>=</mo><mi>m</mi><msup><mi>c</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">E=mc^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mrel">=</span><span class="mord mathit">m</span><span class="mord"><span class="mord mathit">c</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mo fence="true">{</mo><mtable><mtr><mtd><mrow><msub><mi>a</mi><mn>1</mn></msub><mi>x</mi><mo>+</mo><msub><mi>b</mi><mn>1</mn></msub><mi>y</mi><mo>+</mo><msub><mi>c</mi><mn>1</mn></msub><mi>z</mi><mo>=</mo><msub><mi>d</mi><mn>1</mn></msub></mrow></mtd></mtr><mtr><mtd><mrow><msub><mi>a</mi><mn>2</mn></msub><mi>x</mi><mo>+</mo><msub><mi>b</mi><mn>2</mn></msub><mi>y</mi><mo>+</mo><msub><mi>c</mi><mn>2</mn></msub><mi>z</mi><mo>=</mo><msub><mi>d</mi><mn>2</mn></msub></mrow></mtd></mtr><mtr><mtd><mrow><msub><mi>a</mi><mn>3</mn></msub><mi>x</mi><mo>+</mo><msub><mi>b</mi><mn>3</mn></msub><mi>y</mi><mo>+</mo><msub><mi>c</mi><mn>3</mn></msub><mi>z</mi><mo>=</mo><msub><mi>d</mi><mn>3</mn></msub></mrow></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\begin{cases}a_1x+b_1y+c_1z=d_1\\a_2x+b_2y+c_2z=d_2\\a_3x+b_3y+c_3z=d_3\end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:2.41em;"></span><span class="strut bottom" style="height:4.32em;vertical-align:-1.9099999999999997em;"></span><span class="base displaystyle textstyle uncramped"><span class="minner displaystyle textstyle uncramped"><span class="style-wrap reset-textstyle textstyle uncramped"><span class="delimsizing mult"><span class="vlist"><span style="top:0.9500099999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:0.9500099999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-0.000010000000000287557em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-1.1500100000000002em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-1.4500200000000003em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist"><span style="top:-1.4020000000000001em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord displaystyle textstyle uncramped"><span class="mord"><span class="mord mathit">a</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathit">x</span><span class="mbin">+</span><span class="mord"><span class="mord mathit">b</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mbin">+</span><span class="mord"><span class="mord mathit">c</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathit" style="margin-right:0.04398em;">z</span><span class="mrel">=</span><span class="mord"><span class="mord mathit">d</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span><span style="top:0.0379999999999997em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord displaystyle textstyle uncramped"><span class="mord"><span class="mord mathit">a</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathit">x</span><span class="mbin">+</span><span class="mord"><span class="mord mathit">b</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mbin">+</span><span class="mord"><span class="mord mathit">c</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathit" style="margin-right:0.04398em;">z</span><span class="mrel">=</span><span class="mord"><span class="mord mathit">d</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span><span style="top:1.4779999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord displaystyle textstyle uncramped"><span class="mord"><span class="mord mathit">a</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">3</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathit">x</span><span class="mbin">+</span><span class="mord"><span class="mord mathit">b</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">3</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mbin">+</span><span class="mord"><span class="mord mathit">c</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">3</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathit" style="margin-right:0.04398em;">z</span><span class="mrel">=</span><span class="mord"><span class="mord mathit">d</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">3</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span></span></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">A -&gt; B: Hello</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><blockquote><p>Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy.</p><footer><strong>David Levithan</strong><cite>Wide Awake</cite></footer></blockquote><blockquote><p>Every interaction is both precious and an opportunity to delight.</p><footer><strong>Seth Godin</strong><cite><a href="http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html">Welcome to Island Marketing</a></cite></footer></blockquote><figure class="highlight javascript"><figcaption><span>_.compact</span><a href="http://underscorejs.org/#compact">Underscore.js</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_.compact([<span class="number">0</span>, <span class="number">1</span>, <span class="literal">false</span>, <span class="number">2</span>, <span class="string">&#x27;&#x27;</span>, <span class="number">3</span>]);</span><br><span class="line">=&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><iframe src="https://www.baidu.com/" width="100%" height="300" frameborder="0" loading="lazy" allowfullscreen></iframe><img src="https://www.baidu.com/img/bd_logo1.png" class="image" width="300" height="150" title="Baidu"><a href="https://www.baidu.com/" title="Baidu" target>Baidu</a><p>1、横向流程图源码格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[方形] --&gt;B(圆角)</span><br><span class="line">    B --&gt; C&#123;条件a&#125;</span><br><span class="line">    C --&gt;|a&#x3D;1| D[结果1]</span><br><span class="line">    C --&gt;|a&#x3D;2| E[结果2]</span><br><span class="line">    F[横向流程图]</span><br></pre></td></tr></table></figure><p>2、竖向流程图源码格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">A[方形] --&gt; B(圆角)</span><br><span class="line">    B --&gt; C&#123;条件a&#125;</span><br><span class="line">    C --&gt; |a&#x3D;1| D[结果1]</span><br><span class="line">    C --&gt; |a&#x3D;2| E[结果2]</span><br><span class="line">    F[竖向流程图]</span><br></pre></td></tr></table></figure><p>3、标准流程图源码格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">st&#x3D;&gt;start: 开始框</span><br><span class="line">op&#x3D;&gt;operation: 处理框</span><br><span class="line">cond&#x3D;&gt;condition: 判断框(是或否?)</span><br><span class="line">sub1&#x3D;&gt;subroutine: 子流程</span><br><span class="line">io&#x3D;&gt;inputoutput: 输入输出框</span><br><span class="line">e&#x3D;&gt;end: 结束框</span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;io-&gt;e</span><br><span class="line">cond(no)-&gt;sub1(right)-&gt;op</span><br></pre></td></tr></table></figure><p>4、标准流程图源码格式（横向）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">st&#x3D;&gt;start: 开始框</span><br><span class="line">op&#x3D;&gt;operation: 处理框</span><br><span class="line">cond&#x3D;&gt;condition: 判断框(是或否?)</span><br><span class="line">sub1&#x3D;&gt;subroutine: 子流程</span><br><span class="line">io&#x3D;&gt;inputoutput: 输入输出框</span><br><span class="line">e&#x3D;&gt;end: 结束框</span><br><span class="line">st(right)-&gt;op(right)-&gt;cond</span><br><span class="line">cond(yes)-&gt;io(bottom)-&gt;e</span><br><span class="line">cond(no)-&gt;sub1(right)-&gt;op</span><br></pre></td></tr></table></figure><p>5、UML时序图源码样例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">对象A-&gt;对象B: 对象B你好吗?（请求）</span><br><span class="line">Note right of 对象B: 对象B的描述</span><br><span class="line">Note left of 对象A: 对象A的描述(提示)</span><br><span class="line">对象B--&gt;对象A: 我很好(响应)</span><br><span class="line">对象A-&gt;对象B: 你真的好吗？</span><br></pre></td></tr></table></figure><p>6、UML时序图源码复杂样例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Title: 标题：复杂使用</span><br><span class="line">对象A-&gt;对象B: 对象B你好吗?（请求）</span><br><span class="line">Note right of 对象B: 对象B的描述</span><br><span class="line">Note left of 对象A: 对象A的描述(提示)</span><br><span class="line">对象B--&gt;对象A: 我很好(响应)</span><br><span class="line">对象B-&gt;小三: 你好吗</span><br><span class="line">小三--&gt;&gt;对象A: 对象B找我了</span><br><span class="line">对象A-&gt;对象B: 你真的好吗？</span><br><span class="line">Note over 小三,对象B: 我们是朋友</span><br><span class="line">participant C</span><br><span class="line">Note right of C: 没人陪我玩</span><br></pre></td></tr></table></figure><p>7、UML标准时序图样例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">%% 时序图例子,-&gt; 直线，--&gt;虚线，-&gt;&gt;实线箭头</span><br><span class="line">  sequenceDiagram</span><br><span class="line">    participant 张三</span><br><span class="line">    participant 李四</span><br><span class="line">    张三-&gt;王五: 王五你好吗？</span><br><span class="line">    loop 健康检查</span><br><span class="line">        王五-&gt;王五: 与疾病战斗</span><br><span class="line">    end</span><br><span class="line">    Note right of 王五: 合理 食物 &lt;br&#x2F;&gt;看医生...</span><br><span class="line">    李四--&gt;&gt;张三: 很好!</span><br><span class="line">    王五-&gt;李四: 你怎么样?</span><br><span class="line">    李四--&gt;王五: 很好!</span><br></pre></td></tr></table></figure><p>8、甘特图样例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">%% 语法示例</span><br><span class="line">        gantt</span><br><span class="line">        dateFormat  YYYY-MM-DD</span><br><span class="line">        title 软件开发甘特图</span><br><span class="line">        section 设计</span><br><span class="line">        需求                      :done,    des1, 2014-01-06,2014-01-08</span><br><span class="line">        原型                      :active,  des2, 2014-01-09, 3d</span><br><span class="line">        UI设计                     :         des3, after des2, 5d</span><br><span class="line">    未来任务                     :         des4, after des3, 5d</span><br><span class="line">        section 开发</span><br><span class="line">        学习准备理解需求                      :crit, done, 2014-01-06,24h</span><br><span class="line">        设计框架                             :crit, done, after des2, 2d</span><br><span class="line">        开发                                 :crit, active, 3d</span><br><span class="line">        未来任务                              :crit, 5d</span><br><span class="line">        耍                                   :2d</span><br><span class="line">        section 测试</span><br><span class="line">        功能测试                              :active, a1, after des3, 3d</span><br><span class="line">        压力测试                               :after a1  , 20h</span><br><span class="line">        测试报告                               : 48h</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.6.0/katex.min.css"><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://www.baidu.com/">https://www.baidu.com/</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    
    <summary type="html">&lt;p&gt;这是一个段落。&lt;br&gt;
这是一个段落。&lt;/p&gt;</summary>
    
    
    
    <category term="测试" scheme="http://lampkins.gitee.io/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="markdown" scheme="http://lampkins.gitee.io/tags/markdown/"/>
    
  </entry>
  
</feed>
