<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>博客</title>
  
  <subtitle>Creator by ❤️</subtitle>
  <link href="http://lampkins.gitee.io/atom.xml" rel="self"/>
  
  <link href="http://lampkins.gitee.io/"/>
  <updated>2020-10-23T09:35:24.444Z</updated>
  <id>http://lampkins.gitee.io/</id>
  
  <author>
    <name>Lampkins</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL性能优化03：MySQL性能分析篇</title>
    <link href="http://lampkins.gitee.io/2020/10/23/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9603/"/>
    <id>http://lampkins.gitee.io/2020/10/23/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9603/</id>
    <published>2020-10-23T09:32:44.000Z</published>
    <updated>2020-10-23T09:35:24.444Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL性能分析之慢查询日志介绍和show profile介绍</p><hr><h1 id="MySQL%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E7%AF%87"><a class="header-anchor" href="#MySQL%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E7%AF%87">¶</a> MySQL性能分析篇</h1><h2 id="%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E7%9A%84%E6%80%9D%E8%B7%AF"><a class="header-anchor" href="#%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E7%9A%84%E6%80%9D%E8%B7%AF">¶</a> 性能分析的思路</h2><ol><li>首先需要使用【慢查询日志】功能，去获取所有查询时间比较长的SQL语句。上线前开，生产中一般不使用。</li><li>其次【查看执行计划】查看有问题的SQL的执行计划</li><li>最后可以使用【show profile[s]]】查看有问题的SQL 的性能使用情况</li></ol><h2 id="%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97"><a class="header-anchor" href="#%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97">¶</a> 慢查询日志</h2><p>​数据库查询快慢是影响项目性能的一大因素,对于数据库，我们除了要优化SQL，更重要的是得先<mark>找到需要优化的SQL</mark>。 MySQL数据库有一个**“慢查询日志“**功能，用来记录查询时间超过某个设定值的SQL语句，这将极大程度帮助我们<mark>快速定位到症结所在</mark>，以便对症下药。<br>至于查询时间的多少才算慢,每个项目、业务都有不同的要求。</p><p>**作用：**记录在MySQL中响应时间超过阀值的语句，即运行时间超过long_query_time值的SQL，会被记录到慢查询日志中。</p><p>MySQL的慢查询日志功能<mark>默认是关闭的,需要手动开启</mark>。</p><blockquote><p><a href="https://www.cnblogs.com/saneri/p/6656161.html">MySQL慢查询日志总结</a></p></blockquote><h2 id="explain%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92"><a class="header-anchor" href="#explain%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92">¶</a> explain执行计划</h2><p>​EXPLAIN 命令是查看查询优化器如何决定执行查询的主要方法，使用EXPLAIN，只需要在查询中的SELECT关键字之前增加EXPLAIN这个词即可，MYSQL会在查询上设置一个标记，当执行查询时，这个标记会使其返回关于在执行计划中每一步的信息，它会返回一行或多行信息，显示出执行计划中的每一部分和执行的次序，从而可以从分析结果中找到查询语句或表结构的性能瓶颈。</p><p><strong>EXPLAIN作用</strong></p><ul><li>分析出表的读取顺序</li><li>数据读取操作的操作类型</li><li>哪些索引可以使用</li><li>哪些索引被实际使用</li><li>表之间的引用</li><li>每张表有多少行被优化器查询</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 使用时在前面加上explain即可</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tbl_dept;</span><br></pre></td></tr></table></figure><p><img src="/2020/10/23/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9603/20180521155012377.png" alt="20180521155012377"></p><blockquote><p><a href="https://www.cnblogs.com/myseries/p/10736268.html">MySQL — 优化之explain执行计划详解（转）</a></p></blockquote><h2 id="profile%E5%88%86%E6%9E%90%E8%AF%AD%E5%8F%A5"><a class="header-anchor" href="#profile%E5%88%86%E6%9E%90%E8%AF%AD%E5%8F%A5">¶</a> profile分析语句</h2><p>Query Profiler是MySQL 自带的一种query诊断分析工具通过它可以分析出一 条SQL语句的硬件性能瓶颈在什么地方。</p><p>通常我们使用的explain，以及slow query log都无法做到精确分析，但是Query Profiler却可以定位出一条SQL语句执行的各种资源消耗情况，比如CPU/IO等，以及该SQL执行所耗费的时间等。不过该工具只有在MySQL5.0.37以及以上版本中才有实现。</p><p>MYSQL的该功能<mark>默认是关闭的，需要手动启动</mark>。</p><hr><blockquote><p><a href>MySQL性能优化01：主题和目标</a></p><p><a href>MySQL性能优化02：MySQL架构篇</a></p><p><a href>MySQL性能优化03：MySQL性能分析篇</a></p><p><a href>MySQL性能优化04：MySQL索引篇01索引讲解</a></p><p><a href>MySQL性能优化05：MySQL索引篇02查看执行计划</a></p><p><a href>MySQL性能优化06：MySQL索引篇03索引失效分析</a></p><p><a href>MySQL性能优化07：性能优化篇</a></p></blockquote><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.6.0/katex.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;MySQL性能分析之慢查询日志介绍和show profile介绍&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;MySQL%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E7%AF%87&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#MyS</summary>
      
    
    
    
    <category term="技术" scheme="http://lampkins.gitee.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="数据库" scheme="http://lampkins.gitee.io/categories/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="MySQL" scheme="http://lampkins.gitee.io/tags/MySQL/"/>
    
    <category term="MySQL索引" scheme="http://lampkins.gitee.io/tags/MySQL%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>MySQL性能优化02：MySQL架构篇</title>
    <link href="http://lampkins.gitee.io/2020/10/23/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9602/"/>
    <id>http://lampkins.gitee.io/2020/10/23/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9602/</id>
    <published>2020-10-23T09:32:39.000Z</published>
    <updated>2020-10-23T09:34:41.688Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL架构介绍、存储引擎介绍、日志文件、数据文件介绍</p><hr><h1 id="MySQL%E6%9E%B6%E6%9E%84%E7%AF%87"><a class="header-anchor" href="#MySQL%E6%9E%B6%E6%9E%84%E7%AF%87">¶</a> MySQL架构篇</h1><p><img src="/2020/10/23/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9602/timg.jpg" alt="timg"></p><h2 id="%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%BB%8B%E7%BB%8D"><a class="header-anchor" href="#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%BB%8B%E7%BB%8D">¶</a> 存储引擎介绍</h2><p>与其他数据库例如Oracle和SQL Server等数据库中只有一种存储引擎不同的是, MySQL有一个被称为&quot;Pluggable Storage Engine Architecture&quot; (可插拔的存储引擎架构)的特性，也就意味着MySQL数据库提供了多种存储引擎。</p><p>而且<strong>存储引擎是针对表</strong>的，用户可以根据不同的需求为数据表选择不同的存储引擎，用户也可以根据自己的需要编写自己的存储引擎。也就是说，同一数据库不同的表可以选择不同的存储引擎。</p><p><code>creat table xxx() engine=InnoDB/Memory/MyISAM</code></p><p>简而言之，存储引擎就是如何存储数据、如何为存储的数据建立索引和如何更新、查询数据等技术的实现方法。</p><ul><li><strong>MySQL存储引擎种类</strong></li></ul><table><thead><tr><th>存储引擎</th><th>说明</th></tr></thead><tbody><tr><td><strong>MyISAM</strong></td><td>高速引擎,拥有较高的插入,查询速度,但<strong>不支持事务</strong></td></tr><tr><td><strong>InnoDB</strong></td><td>5.5版本后MySQL的默认数据库，支持事务和行级锁定，比MyISAM处理速度稍慢</td></tr><tr><td>ISAM</td><td>MyISAM的前身, MySQL5 . 0以后不再默认安装</td></tr><tr><td>MRG_ MyISAM ( MERGE )</td><td>将多个表联合成一个表使用，在超大规模数据存储时很有用</td></tr><tr><td><strong>Memory</strong></td><td><strong>内存存储引擎，拥有极高的插入，更新和查询效率</strong>。但是会占用和数据量成正比的内存空间。只在内存.上保存数据,意味着数据可能会丢失</td></tr><tr><td>Falcon</td><td>一种新的存储引擎,支持事物处理,传言可能是InnoDB的替代者</td></tr><tr><td>Archive</td><td>将数据压缩后进行存储,非常适合存储大量的独立的，作为历史记录的数据,但是只能进行插入和查询操作</td></tr><tr><td>CSV</td><td>CSV存储引擎是基于CSV 格式文件存储数据(应用于跨平台的数据交换)</td></tr></tbody></table><ul><li><p>查看存储引擎：</p><p><code>mysql&gt; show engines</code></p></li><li><p><strong>InnoDB和MyISAM存储引擎区别</strong></p></li></ul><table><thead><tr><th></th><th>Myisam</th><th>Innodb</th></tr></thead><tbody><tr><td><strong>存储文件</strong></td><td>.frm表定义文件<br><strong>. ibd数据文件和索引文件</strong></td><td>.frm表定义文件<br><strong>.myd数据文件<br>.myi索引文件.</strong></td></tr><tr><td><strong>锁</strong></td><td>表锁、<strong>行锁</strong></td><td>表锁</td></tr><tr><td><strong>事务</strong></td><td>支持</td><td>不支持</td></tr><tr><td><strong>CRDU</strong></td><td>读、写</td><td>读多</td></tr><tr><td><strong>count</strong></td><td>扫表</td><td>专门存储的地方</td></tr><tr><td><strong>索引结构</strong></td><td>B+ Tree</td><td>B+ Tree</td></tr></tbody></table><blockquote><p>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。</p><p>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。</p><p>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般</p></blockquote><h2 id="%E7%89%A9%E7%90%86%E6%96%87%E4%BB%B6"><a class="header-anchor" href="#%E7%89%A9%E7%90%86%E6%96%87%E4%BB%B6">¶</a> 物理文件</h2><h3 id="%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%EF%BC%88%E9%A1%BA%E5%BA%8FIO%EF%BC%89"><a class="header-anchor" href="#%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%EF%BC%88%E9%A1%BA%E5%BA%8FIO%EF%BC%89">¶</a> 日志文件（顺序IO）</h3><p>MySQL通过日志记录了数据库操作信息和错误信息。常用的日志文件包括错误日志、二进制日志、查询日志、慢查询日志和事务Redo日志、中继日志等。</p><h4 id="%E9%94%99%E8%AF%AF%E6%97%A5%E5%BF%97%EF%BC%88errorlog%EF%BC%89"><a class="header-anchor" href="#%E9%94%99%E8%AF%AF%E6%97%A5%E5%BF%97%EF%BC%88errorlog%EF%BC%89">¶</a> 错误日志（errorlog）</h4><p>默认是开启的,而且从5.5.7以后无法关闭错误日志,错误日志记录了运行过程中遇到的所有严重的错误信息,以及MySQL每次启动和关闭的详细信息。</p><h4 id="%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%97%A5%E5%BF%97(bin%20log%20)"><a class="header-anchor" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%97%A5%E5%BF%97(bin%20log%20)">¶</a> 二进制日志(bin log )</h4><p>默认是关闭的<br>binlog记录了数据库所有的dd1语句和dm1语句,但不包括select语句内容,语句以事件的形式保存,描述了数据的变更顺序, binlog还包括了每个更新语句的执行时间信息。如果是DDL语句,则直接记录到binlog日志,而DML语句,必须通过事务提交才能记录到binlog日志中。<br>binlog主要用于实现mysq1主从复制、数据备份、数据恢复。</p><h4 id="%E9%80%9A%E7%94%A8%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97(%20general%20query%20log%20)"><a class="header-anchor" href="#%E9%80%9A%E7%94%A8%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97(%20general%20query%20log%20)">¶</a> 通用查询日志( general query log )</h4><p>默认情况下通用查询日志是关闭的。</p><h4 id="%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97(%20slow%20query%20log%20)"><a class="header-anchor" href="#%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97(%20slow%20query%20log%20)">¶</a> 慢查询日志( slow query log )</h4><p>默认是关闭的。</p><h4 id="%E9%87%8D%E5%81%9A%E6%97%A5%E5%BF%97(%20redo%201og%20)"><a class="header-anchor" href="#%E9%87%8D%E5%81%9A%E6%97%A5%E5%BF%97(%20redo%201og%20)">¶</a> 重做日志( redo 1og )</h4><p>作用:</p><ul><li>确保事务的持久性。</li><li>防止在发生故障的时间点,尚有脏页未写入磁盘，在重启mysq1服务的时候，根据redo 1og进行重做，从而达到事务的持久性这一特性。</li></ul><h4 id="%E5%9B%9E%E6%BB%9A%E6%97%A5%E5%BF%97(%20undo%20log)"><a class="header-anchor" href="#%E5%9B%9E%E6%BB%9A%E6%97%A5%E5%BF%97(%20undo%20log)">¶</a> 回滚日志( undo log)</h4><p>作用:</p><ul><li>保存了事务发生之前的数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读( MVCC ) , 也即非锁定读</li></ul><h4 id="%E4%B8%AD%E7%BB%A7%E6%97%A5%E5%BF%97(%20relay%20log%20)"><a class="header-anchor" href="#%E4%B8%AD%E7%BB%A7%E6%97%A5%E5%BF%97(%20relay%20log%20)">¶</a> 中继日志( relay log )</h4><ul><li>是在主从复制环境中产生的日志。</li><li>主要作用是为了从机可以从中继日志中获取到主机同步过来的SQL语句，然后执行到从机中。</li></ul><h3 id="%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6(%E9%9A%8F%E6%9C%BAIO)"><a class="header-anchor" href="#%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6(%E9%9A%8F%E6%9C%BAIO)">¶</a> 数据文件(随机IO)</h3><p><img src="/2020/10/23/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9602/image-20201015211034313.png" alt="image-20201015211034313"></p><h4 id="InnoDB%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6"><a class="header-anchor" href="#InnoDB%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6">¶</a> InnoDB数据文件</h4><ul><li>.frm文件:主要存放与表相关的数据信息,主要包括表结构的定义信息</li><li>. ibd :使用独享表空间存储表数据和索引信息, 一张表对应一个ibd文件</li><li>ibdata文件 :使用共享表空间存储表数据和索引信息,所有表共同使用一个或者多个ibdata文件。</li></ul><h4 id="MyIsam%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6"><a class="header-anchor" href="#MyIsam%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6">¶</a> MyIsam数据文件</h4><ul><li>.frm文件:主要存放与表相关的数据信息,主要包括表结构的定义信息</li><li>. myd文件:主要用来存储表数据信息。</li><li>.myi文件:主要用来存储表数据文件中任何索引的数据树。</li></ul><hr><blockquote><p><a href>MySQL性能优化01：主题和目标</a></p><p><a href>MySQL性能优化02：MySQL架构篇</a></p><p><a href>MySQL性能优化03：MySQL性能分析篇</a></p><p><a href>MySQL性能优化04：MySQL索引篇01索引讲解</a></p><p><a href>MySQL性能优化05：MySQL索引篇02查看执行计划</a></p><p><a href>MySQL性能优化06：MySQL索引篇03索引失效分析</a></p><p><a href>MySQL性能优化07：性能优化篇</a></p></blockquote><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.6.0/katex.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;MySQL架构介绍、存储引擎介绍、日志文件、数据文件介绍&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;MySQL%E6%9E%B6%E6%9E%84%E7%AF%87&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#MySQL%E6%9E%B6%E6%9E%84%E</summary>
      
    
    
    
    <category term="技术" scheme="http://lampkins.gitee.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="数据库" scheme="http://lampkins.gitee.io/categories/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="MySQL" scheme="http://lampkins.gitee.io/tags/MySQL/"/>
    
    <category term="MySQL索引" scheme="http://lampkins.gitee.io/tags/MySQL%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>MySQL性能优化01：主题和目标</title>
    <link href="http://lampkins.gitee.io/2020/10/23/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9601/"/>
    <id>http://lampkins.gitee.io/2020/10/23/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%9601/</id>
    <published>2020-10-23T09:32:30.000Z</published>
    <updated>2020-10-23T09:34:03.380Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL课程主题和目标</p><h2 id="%E4%B8%BB%E9%A2%98%EF%BC%9A"><a class="header-anchor" href="#%E4%B8%BB%E9%A2%98%EF%BC%9A">¶</a> 主题：</h2><p>你真的会使用MySQL索引进行性能优化吗?</p><hr><h2 id="%E7%9B%AE%E6%A0%87"><a class="header-anchor" href="#%E7%9B%AE%E6%A0%87">¶</a> 目标</h2><ol><li><p>性能分析要从三驾马车开始(慢查询日志、<strong>explain执行计划</strong>、 show profile )</p></li><li><p>有了性能分析报告，接下来如何对性能进行优化呢？</p></li><li><p><strong>我们一定要搞清楚通过explain显示查询计划中关于索引是否被用到</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- id是主键</span></span><br><span class="line"><span class="comment">-- name是非唯一索引</span></span><br><span class="line"><span class="comment">-- MySQL在执行查询时一般只会用到一个索引（优化器去进行选择）</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">and</span> <span class="keyword">name</span>= <span class="string">&#x27;zhangsan&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>你知道MySQL的索引在执行过程中是如何被使用的吗？</strong></p></li><li><p><strong>你知道MySQL中的表数据和索引在底层是如何存储的吗？</strong></p></li><li><p>你了解聚集索引（ IOT索引组织表）和非聚集索引（堆组织表）的存储方式的不同吗？</p></li><li><p>你知道聚集索引中的主键索引和辅助索引是如何存储索引和数据的吗？</p></li><li><p>你会正确使用组合索引吗？</p></li><li><p>你明白最左前缀原则是怎么回事吗？</p></li><li><p>你明白什么是索引覆盖吗？索引覆盖如何优化检索性能？</p></li><li><p><strong>如何正确使用索引，才不会引起索引失效？</strong></p></li></ol><hr><blockquote><p><a href>MySQL性能优化01：主题和目标</a></p><p><a href>MySQL性能优化02：MySQL架构篇</a></p><p><a href>MySQL性能优化03：MySQL性能分析篇</a></p><p><a href>MySQL性能优化04：MySQL索引篇01索引讲解</a></p><p><a href>MySQL性能优化05：MySQL索引篇02查看执行计划</a></p><p><a href>MySQL性能优化06：MySQL索引篇03索引失效分析</a></p><p><a href>MySQL性能优化07：性能优化篇</a></p></blockquote><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.6.0/katex.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;MySQL课程主题和目标&lt;/p&gt;
&lt;h2 id=&quot;%E4%B8%BB%E9%A2%98%EF%BC%9A&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#%E4%B8%BB%E9%A2%98%EF%BC%9A&quot;&gt;¶&lt;/a&gt; 主题：&lt;/h2&gt;
&lt;p&gt;你真的会</summary>
      
    
    
    
    <category term="技术" scheme="http://lampkins.gitee.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="数据库" scheme="http://lampkins.gitee.io/categories/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="MySQL" scheme="http://lampkins.gitee.io/tags/MySQL/"/>
    
    <category term="MySQL索引" scheme="http://lampkins.gitee.io/tags/MySQL%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>JMM Java内存模型</title>
    <link href="http://lampkins.gitee.io/2020/10/14/JMM-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>http://lampkins.gitee.io/2020/10/14/JMM-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</id>
    <published>2020-10-14T11:53:49.000Z</published>
    <updated>2020-10-23T09:21:59.639Z</updated>
    
    <content type="html"><![CDATA[<p>JMM Java内存模型的一些概念</p><hr><h1 id="JMM(Java%20Memory%20Model)"><a class="header-anchor" href="#JMM(Java%20Memory%20Model)">¶</a> JMM(Java Memory Model)</h1><h2 id="%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E4%B8%89%E4%B8%AA%E6%80%A7%E8%B4%A8"><a class="header-anchor" href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E4%B8%89%E4%B8%AA%E6%80%A7%E8%B4%A8">¶</a> 并发编程的三个性质</h2><p>JMM关键技术点是围绕着多线程的原子性、可见性、有序性来建立的。</p><h3 id="%E5%8E%9F%E5%AD%90%E6%80%A7"><a class="header-anchor" href="#%E5%8E%9F%E5%AD%90%E6%80%A7">¶</a> 原子性</h3><p>原子性是指<strong>一个操作是不可中断的，要么全部执行成功要么全部执行失败</strong>。</p><p>比如 a++ 操作，实际包含三步：</p><ol><li>读取变量a的值，假如a=1</li><li>a的值+1，为2</li><li>将2值赋值给变量a，此时a的值为2</li></ol><p>这三步是不可分割的，所以必须保证这3步操作时原子性的，在操作a++的过程中，其他线程不会改变a的值，如果在该过程中出现其他线程修改了a的值，上面的操作应该执行失败。</p><p>java中实现原子操作的方法大致有2种：<strong>锁机制、无锁CAS机制</strong></p><h3 id="%E5%8F%AF%E8%A7%81%E6%80%A7"><a class="header-anchor" href="#%E5%8F%AF%E8%A7%81%E6%80%A7">¶</a> 可见性</h3><p>可见性是指<strong>一个线程对共享变量的修改，对于其他线程来说是可以看到的</strong>。</p><p>共享变量可见性的<strong>实现原理</strong>：</p><ol><li>线程A在自己的工作内存中修改变量之后，需要将变量的值刷新到主内存中</li><li>线程B要把主内存中变量的值更新到工作内存中</li></ol><p>关于线程可见性的控制，可以使用<strong>volatile、synchronized、锁</strong>来实现</p><h3 id="%E6%9C%89%E5%BA%8F%E6%80%A7"><a class="header-anchor" href="#%E6%9C%89%E5%BA%8F%E6%80%A7">¶</a> 有序性</h3><p>有序性指的是<strong>程序按照代码的先后顺序执行</strong>。</p><p>为了性能优化，编译器和处理器会进行指令重排序，有时候会改变程序语句的先后顺序，比如程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>; <span class="comment">//1 </span></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">20</span>; <span class="comment">//2 </span></span><br><span class="line"><span class="keyword">int</span> c = a + b; <span class="comment">//3</span></span><br></pre></td></tr></table></figure><p>编译器优化后可能变成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> b = <span class="number">20</span>; <span class="comment">//1 </span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>; <span class="comment">//2 </span></span><br><span class="line"><span class="keyword">int</span> c = a + b; <span class="comment">//3</span></span><br></pre></td></tr></table></figure><h2 id="Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><a class="header-anchor" href="#Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B">¶</a> Java内存模型</h2><p>​JMM决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：<strong>线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本。</strong></p><p>​<strong>作用：</strong> 在并行机制的前提下，定义了一种规则，保证多个线程间可以有效正确地协同工作。</p><p>​本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。其关系模型图如下图所示：</p><p><img src="/2020/10/14/JMM-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/image-20201012155842619.png" alt="image-20201012155842619" class="fancybox"></p><p>从上图中可以看出，线程A需要和线程B通信，必须要经历下面2个步骤：</p><ol><li>首先，线程A把本地内存A中更新过的共享变量刷新到主内存中去</li><li>然后，线程B到主内存中去读取线程A之前已更新过的共享变量</li></ol><p><strong>一个例子</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">T1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">T1</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程&quot;</span> + <span class="keyword">this</span>.getName() + <span class="string">&quot; in&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (flag) &#123;;&#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程&quot;</span> + <span class="keyword">this</span>.getName() + <span class="string">&quot;停止了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> T1(<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="comment">//休眠1秒</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">//将flag置为false</span></span><br><span class="line">        flag = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后会发现程序无法终止，也就是说主线程将flag修改为false后，线程t1获取的flag的值依旧为true。</p><p><strong>可能的原因：</strong></p><ul><li><p>主线程修改了flag之后，未将其刷新到主内存，所以t1看不到</p></li><li><p>主线程将flag刷新到了主内存，但是t1一直读取的是自己工作内存中flag的值，没有去主内存中获 取flag最新的值</p></li></ul><p><strong>解决：</strong></p><p>​使用volatile修饰共享变量，<code>public volatile static boolean flag = true;</code></p><blockquote><p>被volatile修改的 变量有以下特点：</p><ol><li>线程中读取的时候，每次读取都会去主内存中读取共享变量最新的值，然后将其复制到工作内存</li><li>线程中修改了工作内存中变量的副本，修改之后会立即刷新到主内存</li></ol></blockquote><p><strong>运行结果：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">线程t1 in</span><br><span class="line">线程t1停止了</span><br></pre></td></tr></table></figure><p>从该例子可知，<strong>volatile解决了共享变量在多线程中可见性的问题</strong>。</p><blockquote><p>更多内容：<a href="https://blog.csdn.net/zs88897/article/details/106385245/">JMM理解整理</a></p></blockquote><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.6.0/katex.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;JMM Java内存模型的一些概念&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;JMM(Java%20Memory%20Model)&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#JMM(Java%20Memory%20Model)&quot;&gt;¶&lt;/a&gt; JMM(Java</summary>
      
    
    
    
    <category term="技术" scheme="http://lampkins.gitee.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Java" scheme="http://lampkins.gitee.io/tags/Java/"/>
    
    <category term="JMM" scheme="http://lampkins.gitee.io/tags/JMM/"/>
    
  </entry>
  
  <entry>
    <title>Redis基础 学习笔记</title>
    <link href="http://lampkins.gitee.io/2020/10/13/Redis%E5%9F%BA%E7%A1%80-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://lampkins.gitee.io/2020/10/13/Redis%E5%9F%BA%E7%A1%80-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2020-10-13T14:14:16.000Z</published>
    <updated>2020-10-23T09:20:07.169Z</updated>
    
    <content type="html"><![CDATA[<p>Redis 是一个内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。</p><hr><h2 id="NoSQL%E6%A6%82%E8%BF%B0"><a class="header-anchor" href="#NoSQL%E6%A6%82%E8%BF%B0">¶</a> NoSQL概述</h2><p>NoSQL = Not Only SQL 不仅仅是SQL</p><p>关系型数据库：表格，行、列</p><p>很多的数据类型，如用户的个人信息、社交网络、地理位置。这些数据类型的存储不需要一个固定的格式， 不需要多余的操作就可以横向扩展。</p><h4 id="%E7%89%B9%E7%82%B9"><a class="header-anchor" href="#%E7%89%B9%E7%82%B9">¶</a> 特点</h4><ol><li>方便扩展(数据之间没有关系，很好扩展! )</li><li>大数据量高性能( Redis一秒写8万次，读取11万，NoSQL的缓存记录级是一种细粒度的缓存，性能高!)</li><li>数据类型是多样型的（不需要事先设计数据库，随取随用）</li><li>传统RDBMS和NoSQL</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">传统的 RDBMS</span><br><span class="line">- 结构化组织</span><br><span class="line">- SQL</span><br><span class="line">- 数据和关系都存在单独的表中</span><br><span class="line">- 操作操作，数据定义语言</span><br><span class="line">- 严格的一致性</span><br><span class="line">- 基础的事务</span><br><span class="line">- ...</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Nosq1</span><br><span class="line">- 不仅仅是数据</span><br><span class="line">- 没有固定的查询语言</span><br><span class="line">- 键值对存储，列存储，文档存储，图形数据库(社交关系)</span><br><span class="line">- 最终一致性，</span><br><span class="line">- CAP定理和BASE (异地多活)</span><br><span class="line">- 高性能，高可用，高可扩</span><br><span class="line">- ...</span><br></pre></td></tr></table></figure><blockquote><p>大数据的3V+3高</p><p>描述问题的：</p><ol><li>海量Volume</li><li>多样Variety</li><li>实时Velocity</li></ol><p>对程序的要求：</p><ol><li>高并发</li><li>高可拓</li><li>高性能</li></ol></blockquote><h2 id="%E4%BA%94%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><a class="header-anchor" href="#%E4%BA%94%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">¶</a> 五种基本数据类型</h2><h3 id="Key%EF%BC%88%E9%94%AE%EF%BC%89"><a class="header-anchor" href="#Key%EF%BC%88%E9%94%AE%EF%BC%89">¶</a> Key（键）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis-benchmark -h localhost -p 6379 -c 100 -n 100000</span><br><span class="line">select x<span class="comment">#切换数据库</span></span><br><span class="line">keys *<span class="comment">#查看数据库所有key</span></span><br><span class="line">del key <span class="comment">#删除key </span></span><br><span class="line">flushdb<span class="comment">#清空当前数据库</span></span><br><span class="line">flushall<span class="comment">#清空全部数据库</span></span><br><span class="line">exists key</span><br><span class="line"><span class="built_in">type</span> key</span><br><span class="line">move key 2<span class="comment">#将kv移动到指定的库</span></span><br><span class="line">expire key sec<span class="comment">#设置kv过期时间</span></span><br><span class="line">ttl key<span class="comment">#查看剩余时间</span></span><br></pre></td></tr></table></figure><h3 id="String(%E5%AD%97%E7%AC%A6%E4%B8%B2)"><a class="header-anchor" href="#String(%E5%AD%97%E7%AC%A6%E4%B8%B2)">¶</a> String(字符串)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&gt;strlen k1 <span class="comment">#获取value的长度</span></span><br><span class="line">&gt;append k1 str <span class="comment">#追加字符串，如果key不存在则相当于set key</span></span><br><span class="line"></span><br><span class="line">&gt;incr num <span class="comment">#加一</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">&gt;get num</span><br><span class="line"><span class="string">&quot;2&quot;</span></span><br><span class="line">&gt; decr num <span class="comment">#减一</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">&gt; incrby num 5 <span class="comment">#加一，步长为5</span></span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line">&gt; get k1</span><br><span class="line"><span class="string">&quot;strstr&quot;</span></span><br><span class="line">&gt;getrange k1 1 2 <span class="comment">#截取字符串[1, 2]</span></span><br><span class="line"><span class="string">&quot;tr&quot;</span></span><br><span class="line">&gt; getrange k1 1 -1 <span class="comment">#-1表示末尾</span></span><br><span class="line"><span class="string">&quot;trstr&quot;</span></span><br><span class="line">&gt; setrange k1 2 x <span class="comment">#替换指定位置的字符</span></span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line">get k1</span><br><span class="line"><span class="string">&quot;stxstr&quot;</span></span><br><span class="line"><span class="comment"># setex 设置含过期时间</span></span><br><span class="line"><span class="comment"># getnx key不存在才设置值（分布式锁中常用）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># msetmsetnx(当且仅当所有给定 key 都不存在才设值)</span></span><br><span class="line"><span class="comment">#mget</span></span><br><span class="line"><span class="comment"># HashTag即是用&#123;&#125;包裹key的一个子串，如&#123;k&#125;1，</span></span><br><span class="line"><span class="comment">#两个key拥有相同的HashTag:&#123;k&#125;, 它们会被分配到同一个slot，从而可使用MGET命令</span></span><br><span class="line">&gt; mset &#123;k&#125;1 v1 &#123;k&#125;2 v2 &#123;k&#125;3 v3</span><br><span class="line">OK</span><br><span class="line">mget &#123;k&#125;1 &#123;k&#125;2 &#123;k&#125;3</span><br><span class="line">1) <span class="string">&quot;v1&quot;</span></span><br><span class="line">2) <span class="string">&quot;v2&quot;</span></span><br><span class="line">3) <span class="string">&quot;v3&quot;</span></span><br><span class="line">&gt; <span class="built_in">set</span> user:1 &#123;name:zs,age:21&#125;</span><br><span class="line">OK</span><br><span class="line">&gt; get user:1</span><br><span class="line"><span class="string">&quot;&#123;name:zs,age:21&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># getset</span></span><br><span class="line">&gt; get k1</span><br><span class="line"><span class="string">&quot;str&quot;</span></span><br><span class="line">&gt; getset k1 str2 <span class="comment"># 获取原来的值并设置新的值</span></span><br><span class="line"><span class="string">&quot;str&quot;</span></span><br><span class="line">&gt; get k1</span><br><span class="line"><span class="string">&quot;str2&quot;</span></span><br></pre></td></tr></table></figure><p>String类型使用场景：</p><ul><li>计数器</li><li>统计多单位的数量</li><li>抢购<ul><li>通过exists判断是否存在，如果不存在则先通过setnx初始化值，之后通过decrby判断商品数是否大于0，大于则抢购成功，否则失败</li></ul></li></ul><h3 id="List%EF%BC%88%E5%88%97%E8%A1%A8%EF%BC%89"><a class="header-anchor" href="#List%EF%BC%88%E5%88%97%E8%A1%A8%EF%BC%89">¶</a> List（列表）</h3><p>栈、队列、阻塞队列</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">&gt; lpush l1 one <span class="comment">#将一个或多个值插入到列表 key 的表头</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">&gt; lpush l1 two</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">&gt; lpush l1 three</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">&gt; lrange l1 0 -1</span><br><span class="line">1) <span class="string">&quot;three&quot;</span></span><br><span class="line">2) <span class="string">&quot;two&quot;</span></span><br><span class="line">3) <span class="string">&quot;one&quot;</span></span><br><span class="line">&gt; rpush l1 rone <span class="comment">#将一个或多个值插入到列表 key 的表尾</span></span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">&gt; lrange l1 0 -1</span><br><span class="line">1) <span class="string">&quot;three&quot;</span></span><br><span class="line">2) <span class="string">&quot;two&quot;</span></span><br><span class="line">3) <span class="string">&quot;one&quot;</span></span><br><span class="line">4) <span class="string">&quot;rone&quot;</span></span><br><span class="line"></span><br><span class="line">&gt; lpop l1 <span class="comment">#移除并返回列表 key 的头元素。</span></span><br><span class="line"><span class="string">&quot;three&quot;</span></span><br><span class="line">&gt; rpop l1 <span class="comment">#移除并返回列表 key 的尾元素。</span></span><br><span class="line"><span class="string">&quot;rone&quot;</span></span><br><span class="line">&gt; lrange l1 0 -1</span><br><span class="line">1) <span class="string">&quot;two&quot;</span></span><br><span class="line">2) <span class="string">&quot;one&quot;</span></span><br><span class="line"></span><br><span class="line">&gt; lindex l1 0 <span class="comment">#返回列表 key 中，下标为 index 的元素。</span></span><br><span class="line"><span class="string">&quot;two&quot;</span></span><br><span class="line">&gt; lindex l1 -1</span><br><span class="line"><span class="string">&quot;one&quot;</span></span><br><span class="line"></span><br><span class="line">&gt; llen l1 <span class="comment">#返回列表的长度</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">&gt; lrange l1 0 -1</span><br><span class="line">1) <span class="string">&quot;three&quot;</span></span><br><span class="line">2) <span class="string">&quot;two&quot;</span></span><br><span class="line">3) <span class="string">&quot;one&quot;</span></span><br><span class="line">4) <span class="string">&quot;three&quot;</span></span><br><span class="line">&gt; lrem l1 2 three <span class="comment"># 移除列表中|count|个value元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">&gt; lrange l1 0 -1</span><br><span class="line">1) <span class="string">&quot;two&quot;</span></span><br><span class="line">2) <span class="string">&quot;one&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># count&gt;0: 表头-&gt;表尾；&lt;0: 表尾-&gt;表头；=0: 所有</span></span><br><span class="line">&gt; lrem l1 -1 three</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">&gt; lrange l1 0 -1</span><br><span class="line">1) <span class="string">&quot;three&quot;</span></span><br><span class="line">2) <span class="string">&quot;two&quot;</span></span><br><span class="line">3) <span class="string">&quot;one&quot;</span></span><br><span class="line">&gt; lrem l1 1 three</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">&gt; lrange l1 0 -1</span><br><span class="line">1) <span class="string">&quot;two&quot;</span></span><br><span class="line">2) <span class="string">&quot;one&quot;</span></span><br><span class="line">3) <span class="string">&quot;three&quot;</span></span><br><span class="line">&gt; lrem l1 0 three</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">&gt; lrange l1 0 -1</span><br><span class="line">1) <span class="string">&quot;two&quot;</span></span><br><span class="line">2) <span class="string">&quot;one&quot;</span></span><br><span class="line"></span><br><span class="line">&gt; lrange l1 0 -1</span><br><span class="line">1) <span class="string">&quot;hello&quot;</span></span><br><span class="line">2) <span class="string">&quot;two&quot;</span></span><br><span class="line">3) <span class="string">&quot;one&quot;</span></span><br><span class="line">4) <span class="string">&quot;value&quot;</span></span><br><span class="line">&gt; ltrim l1 2 3 <span class="comment">#修剪list</span></span><br><span class="line">OK</span><br><span class="line">&gt; lrange l1 0 -1</span><br><span class="line">1) <span class="string">&quot;one&quot;</span></span><br><span class="line">2) <span class="string">&quot;value&quot;</span></span><br><span class="line"></span><br><span class="line">&gt; lrange l1 0 -1</span><br><span class="line">1) <span class="string">&quot;one&quot;</span></span><br><span class="line">2) <span class="string">&quot;two&quot;</span></span><br><span class="line">3) <span class="string">&quot;three&quot;</span></span><br><span class="line"><span class="comment"># 将l1的最后一个元素弹出，并返回给客户端。</span></span><br><span class="line"><span class="comment"># 并将弹出的元素作为l2的头元素 （）</span></span><br><span class="line">&gt; rpoplpush l1 l2 </span><br><span class="line"><span class="string">&quot;three&quot;</span></span><br><span class="line">&gt; lrange l1 0 -1</span><br><span class="line">1) <span class="string">&quot;one&quot;</span></span><br><span class="line">2) <span class="string">&quot;two&quot;</span></span><br><span class="line">&gt; lrange l2 0 -1</span><br><span class="line">1) <span class="string">&quot;three&quot;</span></span><br><span class="line"></span><br><span class="line">&gt; exists l1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">&gt; lset l1 1 two2 <span class="comment">#将列表下标为index的值设置为value</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将value插入到列表的值pivot的前面或后面</span></span><br><span class="line"><span class="comment"># linsert key before|after pivot value</span></span><br><span class="line">&gt; linsert l1 after two2 insert</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br></pre></td></tr></table></figure><h3 id="Set%EF%BC%88%E9%9B%86%E5%90%88%EF%BC%89"><a class="header-anchor" href="#Set%EF%BC%88%E9%9B%86%E5%90%88%EF%BC%89">¶</a> Set（集合）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&gt; sadd set1 hello</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">&gt; sadd set1 one</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">&gt; sadd set1 two</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">&gt; smembers set1 <span class="comment">#查看set的所有成员</span></span><br><span class="line">1) <span class="string">&quot;two&quot;</span></span><br><span class="line">2) <span class="string">&quot;one&quot;</span></span><br><span class="line">3) <span class="string">&quot;hello&quot;</span></span><br><span class="line">&gt; sismember set1 one <span class="comment">#判断元素是否在集合中</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">&gt; scard set1 <span class="comment">#获取集合中元素数量</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">&gt; srem set1 one <span class="comment">#删除指定的元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">&gt; srandmember set1 </span><br><span class="line"><span class="string">&quot;hello&quot;</span></span><br><span class="line">&gt; srandmember set1 2 <span class="comment">#从集合中随机获取指定数量的元素</span></span><br><span class="line">1) <span class="string">&quot;memeber&quot;</span></span><br><span class="line">2) <span class="string">&quot;hello&quot;</span></span><br><span class="line">&gt; spop set1 [count] <span class="comment">#随机移除一个元素并返回该元素</span></span><br><span class="line"><span class="string">&quot;memeber&quot;</span></span><br><span class="line">&gt; smove set1 set2 two <span class="comment">#将该元素从一个集合中移动到另一个集合中</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 集合论：差集、交集、并集</span></span><br><span class="line">&gt; sadd &#123;<span class="built_in">set</span>&#125;1 one hello member</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">&gt; sadd &#123;<span class="built_in">set</span>&#125;2 one two three</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">&gt; sdiff &#123;<span class="built_in">set</span>&#125;1 &#123;<span class="built_in">set</span>&#125;2 <span class="comment">#差集 A-B</span></span><br><span class="line">1) <span class="string">&quot;member&quot;</span></span><br><span class="line">2) <span class="string">&quot;hello&quot;</span></span><br><span class="line">&gt; sinter &#123;<span class="built_in">set</span>&#125;1 &#123;<span class="built_in">set</span>&#125;2 <span class="comment">#交集 A∩B</span></span><br><span class="line">1) <span class="string">&quot;one&quot;</span></span><br><span class="line">&gt; sunion &#123;<span class="built_in">set</span>&#125;1 &#123;<span class="built_in">set</span>&#125;2 <span class="comment">#并集 A∪B</span></span><br><span class="line">1) <span class="string">&quot;one&quot;</span></span><br><span class="line">2) <span class="string">&quot;hello&quot;</span></span><br><span class="line">3) <span class="string">&quot;member&quot;</span></span><br><span class="line">4) <span class="string">&quot;three&quot;</span></span><br><span class="line">5) <span class="string">&quot;two&quot;</span></span><br></pre></td></tr></table></figure><ul><li>共同关注</li><li>推荐好友</li><li>···</li></ul><h3 id="SortedSet%EF%BC%88%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%EF%BC%89"><a class="header-anchor" href="#SortedSet%EF%BC%88%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%EF%BC%89">¶</a> SortedSet（有序集合）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&gt; zadd zset1 1 one</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">&gt; zadd zset1 2 two 3 three</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">&gt; zrange zset1 0 -1</span><br><span class="line">1) <span class="string">&quot;one&quot;</span></span><br><span class="line">2) <span class="string">&quot;two&quot;</span></span><br><span class="line">3) <span class="string">&quot;three&quot;</span></span><br><span class="line"></span><br><span class="line">&gt; zadd score 75 zhangsan 87 lisi 60 wangwu</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">&gt; zrange score 1 2 <span class="comment">#返回指定下标区间的成员，按score值递增排列</span></span><br><span class="line">1) <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">2) <span class="string">&quot;lisi&quot;</span></span><br><span class="line"><span class="comment"># 返回有序集中所有 score 值介于 min 和 max 之间(默认闭区间)的成员，并递增排列。</span></span><br><span class="line">&gt; zrangebyscore score -inf +inf <span class="comment">#区间[-∞, +∞]</span></span><br><span class="line">1) <span class="string">&quot;wangwu&quot;</span></span><br><span class="line">2) zhangsan </span><br><span class="line">3) <span class="string">&quot;lisi&quot;</span></span><br><span class="line">&gt; zrangebyscore score 75 100 <span class="comment">#区间[75, 100]</span></span><br><span class="line">1) zhangsan </span><br><span class="line">2) <span class="string">&quot;lisi&quot;</span></span><br><span class="line">&gt; zrangebyscore score (75 +inf <span class="comment">#区间(75, 100]</span></span><br><span class="line">1) <span class="string">&quot;lisi&quot;</span></span><br><span class="line">&gt; zrangebyscore score (75 +inf withscores</span><br><span class="line">1) <span class="string">&quot;lisi&quot;</span></span><br><span class="line">2) <span class="string">&quot;87&quot;</span></span><br><span class="line">&gt; zrevrange score 1 2</span><br><span class="line"><span class="comment"># 返回有序集中所有 score 值介于 max 和 min 之间(默认闭区间)的成员，并递减排列。</span></span><br><span class="line">&gt; zrevrangebyscore score 100 75</span><br><span class="line">1) <span class="string">&quot;lisi&quot;</span></span><br><span class="line">2) <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">&gt; zcount score 75 80</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">&gt; zrem score lisi</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">&gt; zcard score</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br></pre></td></tr></table></figure><ul><li>1,普通消息 2, 重要消息   带权重存储</li></ul><h3 id="Hash%EF%BC%88%E5%93%88%E5%B8%8C%EF%BC%89"><a class="header-anchor" href="#Hash%EF%BC%88%E5%93%88%E5%B8%8C%EF%BC%89">¶</a> Hash（哈希）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&gt; hset h1 f1 v1 <span class="comment">#将哈希表 key 中的域 field 的值设为 value 。</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">&gt; hget h1 f1</span><br><span class="line"><span class="string">&quot;v1&quot;</span></span><br><span class="line">&gt; hmset h1 f1 v11 f2 hello f3 ye</span><br><span class="line">OK</span><br><span class="line">&gt; hmget h1 f1 f2 </span><br><span class="line">1) <span class="string">&quot;v11&quot;</span></span><br><span class="line">2) <span class="string">&quot;hello&quot;</span></span><br><span class="line">&gt; hgetall h1 <span class="comment">#获取全部的域和值</span></span><br><span class="line">&gt; hdel h1 f3 <span class="comment">#删除指定的域</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">&gt; hlen h1</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">&gt; hkeys h1 <span class="comment">#获取所有的域</span></span><br><span class="line">1) <span class="string">&quot;f1&quot;</span></span><br><span class="line">2) <span class="string">&quot;f2&quot;</span></span><br><span class="line">&gt; hvals h1 <span class="comment">#获取所有域的值</span></span><br><span class="line">1) <span class="string">&quot;v11&quot;</span></span><br><span class="line">2) <span class="string">&quot;hello&quot;</span></span><br><span class="line"></span><br><span class="line">&gt; hset h1 f3 3</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">&gt; hincrby h1 f3 2 <span class="comment">#加上一个值</span></span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br></pre></td></tr></table></figure><h2 id="%E4%B8%89%E7%A7%8D%E7%89%B9%E6%AE%8A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><a class="header-anchor" href="#%E4%B8%89%E7%A7%8D%E7%89%B9%E6%AE%8A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">¶</a> 三种特殊数据类型</h2><h3 id="Geospatial%EF%BC%88%E5%9C%B0%E7%90%86%E4%BD%8D%E7%BD%AE%EF%BC%89"><a class="header-anchor" href="#Geospatial%EF%BC%88%E5%9C%B0%E7%90%86%E4%BD%8D%E7%BD%AE%EF%BC%89">¶</a> Geospatial（地理位置）</h3><p>存储到sorted set中</p><ul><li>朋友定位</li><li>附近的人</li><li>打车距离</li><li>···</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt; geoadd china:city 104.065735 30.659462 ChengDu <span class="comment">#添加位置的经纬度</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">&gt; geoadd china:city 116.405285 39.904989 BeiJing 121.472644 31.231706 ShangHai</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">&gt; geopos china:city ChengDu <span class="comment">#获取指定成员的经纬度</span></span><br><span class="line">1) 1) <span class="string">&quot;104.06573742628097534&quot;</span></span><br><span class="line">   2) <span class="string">&quot;30.65946118872339099&quot;</span></span><br><span class="line">&gt; geopos china:city BeiJing ShangHai</span><br><span class="line">1) 1) <span class="string">&quot;116.40528291463851929&quot;</span></span><br><span class="line">   2) <span class="string">&quot;39.9049884229125027&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;121.47264629602432251&quot;</span></span><br><span class="line">   2) <span class="string">&quot;31.23170490709807012&quot;</span></span><br></pre></td></tr></table></figure><p><strong>GEODIST key member1 member2 [unit]</strong><br>unit:</p><ul><li>m 表示单位为米。</li><li>km 表示单位为千米。</li><li>mi 表示单位为英里。</li><li>ft 表示单位为英尺。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; geodist china:city ChengDu ShangHai <span class="comment">#获取成都到上海的直线距离</span></span><br><span class="line"><span class="string">&quot;1660019.7699&quot;</span></span><br><span class="line">&gt; geodist china:city ChengDu ShangHai km</span><br><span class="line"><span class="string">&quot;1660.0198&quot;</span></span><br></pre></td></tr></table></figure><p><strong>GEORADIUS key longitude latitude radius m|km|ft|mi [WITHCOORD(经纬度)] [WITHDIST(距离)] [WITHHASH] [COUNT count]</strong><br>以给定的经纬度为中心， 返回键包含的位置元素当中， 与中心的距离不超过给定最大距离的所有位置元素。<br><strong>GEORADIUSBYMEMBER key member radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count]</strong><br>以给定成员为中心， 返回键包含的位置元素当中， 与中心的距离不超过给定最大距离的所有位置元素。</p><ul><li>附近的人 （当前定位+半径）</li><li>···</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt; georadius china:city 104 30 100 km</span><br><span class="line">1) <span class="string">&quot;wuhou&quot;</span></span><br><span class="line">2) <span class="string">&quot;jingjiang&quot;</span></span><br><span class="line">3) <span class="string">&quot;ChengDu&quot;</span></span><br><span class="line">&gt; georadius china:city 104 30 100 km withdist</span><br><span class="line">1) 1) <span class="string">&quot;wuhou&quot;</span></span><br><span class="line">   2) <span class="string">&quot;71.5655&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;jingjiang&quot;</span></span><br><span class="line">   2) <span class="string">&quot;73.4188&quot;</span></span><br><span class="line">3) 1) <span class="string">&quot;ChengDu&quot;</span></span><br><span class="line">   2) <span class="string">&quot;73.6204&quot;</span></span><br><span class="line">&gt; georadius china:city 104 30 100000 m withdist count 1</span><br><span class="line">1) 1) <span class="string">&quot;wuhou&quot;</span></span><br><span class="line">   2) <span class="string">&quot;71565.4799&quot;</span></span><br><span class="line">&gt; georadiusbymember china:city ChengDu 100 km</span><br><span class="line">1) <span class="string">&quot;jingjiang&quot;</span></span><br><span class="line">2) <span class="string">&quot;ChengDu&quot;</span></span><br><span class="line">3) <span class="string">&quot;wuhou&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 该命令将返回11个字符的Geohash字符串</span></span><br><span class="line">&gt; geohash china:city jingjiang wuhou</span><br><span class="line">1) <span class="string">&quot;wm6n2kz2bw0&quot;</span></span><br><span class="line">2) <span class="string">&quot;wm3yrd3bd70&quot;</span></span><br></pre></td></tr></table></figure><h3 id="HyperLogLogs"><a class="header-anchor" href="#HyperLogLogs">¶</a> HyperLogLogs</h3><p>基数计算：统计一批数据中的不重复元素的个数<br>优点：占用固定的内存大小，最多2^64 12kb，大小和元素个数有关<br>缺点：有0.81%的标准误差，不能获取元素本身</p><ul><li>记录一天会执行多少次各不相同的搜索查询</li><li>···</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; pfadd &#123;pf&#125;1 a b c d <span class="comment">#将元素存入HyperLogLogs结构中</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">&gt; pfadd &#123;pf&#125;2 c d e f g</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">&gt; pfcount &#123;pf&#125;1 <span class="comment">#返回其近似基数，</span></span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">&gt; pfcount &#123;pf&#125;1 &#123;pf&#125;2</span><br><span class="line">(<span class="built_in">integer</span>) 7</span><br><span class="line">&gt; pfmerge &#123;pf&#125;3 &#123;pf&#125;1 &#123;pf&#125;2 <span class="comment">#合并两组集合，并集</span></span><br><span class="line">OK</span><br><span class="line">&gt; pfcount &#123;pf&#125;3</span><br><span class="line">(<span class="built_in">integer</span>) 7</span><br></pre></td></tr></table></figure><h3 id="Bitmap"><a class="header-anchor" href="#Bitmap">¶</a> Bitmap</h3><p>Blob类型，最大512MB</p><ul><li>签到打卡 365 bit=45.625 byte</li><li>统计活跃用户（或运算）</li><li>用户是否在线</li><li>···</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt; setbit signin 0 1 <span class="comment">#设置或者清空key的value(字符串)在offset处的bit值。</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">&gt; setbit signin 1 0</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">&gt; setbit signin 2 0</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">&gt; setbit signin 3 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">&gt; setbit signin 4 0</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">&gt; setbit signin 5 0</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">&gt; getbit signin 4 <span class="comment">#返回offset处的bit值</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">&gt; bitcount signin</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">&gt; BITOP AND dest key1 key2</span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br></pre></td></tr></table></figure><h2 id="%E4%BA%8B%E5%8A%A1"><a class="header-anchor" href="#%E4%BA%8B%E5%8A%A1">¶</a> 事务</h2><h3 id="Redis%E7%9A%84%E4%BA%8B%E5%8A%A1"><a class="header-anchor" href="#Redis%E7%9A%84%E4%BA%8B%E5%8A%A1">¶</a> Redis的事务</h3><ul><li>开启事务（multi）</li><li>命令入队（…）</li><li>执行事务（exec）</li><li>取消事务 （discard）<br>编译时异常：如命令错误，事务中所有的命令都不会被执行<br>运行时异常：事务队列中，错误的命令抛出运行时异常，但其他命令是可以正常执行的</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">set</span> str string</span><br><span class="line">OK</span><br><span class="line">&gt; multi</span><br><span class="line">OK</span><br><span class="line">&gt; get str <span class="comment">#语法错误，事务不会被执行</span></span><br><span class="line">QUEUED</span><br><span class="line">&gt; <span class="built_in">set</span> str</span><br><span class="line">(error) ERR wrong number of arguments <span class="keyword">for</span> <span class="string">&#x27;set&#x27;</span> <span class="built_in">command</span></span><br><span class="line">&gt; <span class="built_in">exec</span></span><br><span class="line">(error) EXECABORT Transaction discarded because of previous errors.</span><br><span class="line"></span><br><span class="line">&gt; multi</span><br><span class="line">OK</span><br><span class="line">&gt; incr str <span class="comment">#会产生运行时异常，事务中的该条命令不会被执行</span></span><br><span class="line">QUEUED</span><br><span class="line">&gt; get str <span class="comment"># 正常执行</span></span><br><span class="line">QUEUED</span><br><span class="line">&gt; <span class="built_in">exec</span></span><br><span class="line">1) (error) ERR value is not an <span class="built_in">integer</span> or out of range</span><br><span class="line">2) <span class="string">&quot;string&quot;</span></span><br></pre></td></tr></table></figure><h3 id="%E7%9B%91%E6%8E%A7%20Watch"><a class="header-anchor" href="#%E7%9B%91%E6%8E%A7%20Watch">¶</a> 监控 Watch</h3><p>监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。<br><strong>悲观锁</strong></p><ul><li>认为写操作多，遇到并发写的可能性高，以每次在读写数据的时候都会上锁</li><li>java中的悲观锁就是Synchronized</li></ul><p><strong>乐观锁</strong></p><ul><li>认为读多写少，遇到并发写的可能性低</li><li>不会上锁，提交更新时会对数据冲突进行检测（比较版本号），失败则要重复读-比较-写的操作</li><li>CAS、version控制</li></ul><p>正常执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">set</span> &#123;a&#125;money 100</span><br><span class="line">OK</span><br><span class="line">&gt; <span class="built_in">set</span> &#123;a&#125;out 0</span><br><span class="line">OK</span><br><span class="line">&gt; watch money</span><br><span class="line">OK</span><br><span class="line">&gt; multi</span><br><span class="line">OK</span><br><span class="line">&gt; DECRBY money 20</span><br><span class="line">QUEUED</span><br><span class="line">&gt; INCRBY out 20</span><br><span class="line">QUEUED</span><br><span class="line">&gt; <span class="built_in">exec</span></span><br><span class="line">1) (<span class="built_in">integer</span>) 80</span><br><span class="line">2) (<span class="built_in">integer</span>) 20</span><br></pre></td></tr></table></figure><p>测试多进程修改值。如果修改失败，获取最新的值就行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; watch money</span><br><span class="line">OK</span><br><span class="line">&gt; multi</span><br><span class="line">OK</span><br><span class="line">&gt; DECRBY money 10</span><br><span class="line">QUEUED</span><br><span class="line">&gt; INCRBY out 10</span><br><span class="line">QUEUED</span><br><span class="line">&gt; <span class="built_in">exec</span> <span class="comment">#执行之前，另一个线程修改了值，这时就会导致事务执行失败</span></span><br><span class="line">(nil)</span><br><span class="line"></span><br><span class="line">&gt; unwatch <span class="comment"># 如果发现事务执行失败，则先解锁再重新监视（select version）</span></span><br><span class="line">OK</span><br><span class="line">&gt; watch money </span><br></pre></td></tr></table></figure><h2 id="SpringBoot%E6%95%B4%E5%90%88"><a class="header-anchor" href="#SpringBoot%E6%95%B4%E5%90%88">¶</a> SpringBoot整合</h2><p><strong>jedis</strong>：采用直连Redis Server，线程不安全，像BIO<br><strong>lettuce</strong>：连接基于netty，连接实例可以再多个线程间共享，线程安全，像NIO</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(name = &#123;&quot;redisTemplate&quot;&#125;)</span></span><br><span class="line"><span class="comment">// 默认的RedisTemplate设置较少</span></span><br><span class="line"><span class="comment">// 泛型都是Object，需要强转为&lt;Sring, Object&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> <span class="keyword">throws</span> UnknownHostException </span>&#123;</span><br><span class="line">    RedisTemplate&lt;Object, Object&gt; template = <span class="keyword">new</span> RedisTemplate();</span><br><span class="line">    template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">    <span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span> </span><br><span class="line"><span class="comment">//由于String比较常用，所以单独封装了一个</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StringRedisTemplate <span class="title">stringRedisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> <span class="keyword">throws</span> UnknownHostException </span>&#123;</span><br><span class="line">    StringRedisTemplate template = <span class="keyword">new</span> StringRedisTemplate();</span><br><span class="line">    template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">    <span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义RedisTemplate</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">redisTemplate</span><span class="params">(LettuceConnectionFactory lettuceConnectionFactory)</span> </span>&#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">        template.setConnectionFactory(lettuceConnectionFactory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Json序列化配置</span></span><br><span class="line">        Jackson2JsonRedisSerializer&lt;Object&gt; jackson2JsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer&lt;&gt;(Object.class);</span><br><span class="line">        ObjectMapper om = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        <span class="comment">// 指定要序列化的域，field,get和set,以及修饰符范围，ANY是都有包括private和public</span></span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        <span class="comment">// 指定序列化输入的类型，类必须是非final修饰的，final修饰的类，比如String,Integer等会抛出异常</span></span><br><span class="line">        om.activateDefaultTyping(LaissezFaireSubTypeValidator.instance, ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// key和hash的key 采用String的序列化方式</span></span><br><span class="line">        template.setKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line">        template.setHashKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line">        <span class="comment">// value和hash的value 采用Jackson的序列化方式</span></span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Redis.conf"><a class="header-anchor" href="#Redis.conf">¶</a> Redis.conf</h2><h3 id="1.%20%E5%8C%85%E5%90%AB%20INCLUDES"><a class="header-anchor" href="#1.%20%E5%8C%85%E5%90%AB%20INCLUDES">¶</a> 1. 包含 INCLUDES</h3><p><img src="/2020/10/13/Redis%E5%9F%BA%E7%A1%80-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20201001180930883-1603273481613.png" alt="0" class="fancybox"></p><h3 id="2.%20%E7%BD%91%E7%BB%9C%20NETWORK"><a class="header-anchor" href="#2.%20%E7%BD%91%E7%BB%9C%20NETWORK">¶</a> 2. 网络 NETWORK</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bind</span> 192.168.26.128 127.0.0.1 <span class="comment"># 绑定的ip</span></span><br><span class="line">protected-mode yes <span class="comment"># 保护模式</span></span><br><span class="line">port 6379 <span class="comment"># 端口设置</span></span><br></pre></td></tr></table></figure><h3 id="3.%20%E9%80%9A%E7%94%A8%E9%85%8D%E7%BD%AE%20GENERAL"><a class="header-anchor" href="#3.%20%E9%80%9A%E7%94%A8%E9%85%8D%E7%BD%AE%20GENERAL">¶</a> 3. 通用配置 GENERAL</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">daemonize yes <span class="comment"># 以守护进程的方式运行，默认为no</span></span><br><span class="line">supervised no <span class="comment"># 可以通过upstart和systemd管理Redis守护进程, no/upstart/systemd/auto</span></span><br><span class="line">pidfile /var/run/redis_6379.pid <span class="comment"># 如果以后台的方式运行，需要指定一个pid文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 日志</span></span><br><span class="line"><span class="comment"># Specify the server verbosity level.</span></span><br><span class="line"><span class="comment"># This can be one of:</span></span><br><span class="line"><span class="comment"># debug (a lot of information, useful for development/testing)</span></span><br><span class="line"><span class="comment"># verbose (many rarely useful info, but not a mess like the debug level)</span></span><br><span class="line"><span class="comment"># notice (moderately verbose, what you want in production probably)</span></span><br><span class="line"><span class="comment"># warning (only very important / critical messages are logged)</span></span><br><span class="line">loglevel notice</span><br><span class="line">logfile <span class="string">&quot;&quot;</span> <span class="comment"># 日志文件路径</span></span><br><span class="line"> </span><br><span class="line">databases 16 <span class="comment"># 默认16个数据库</span></span><br><span class="line">always-show-logo yes <span class="comment"># 显示Redis Logo</span></span><br></pre></td></tr></table></figure><h3 id="4.%20%E5%BF%AB%E7%85%A7%20SNAPSHOTTING"><a class="header-anchor" href="#4.%20%E5%BF%AB%E7%85%A7%20SNAPSHOTTING">¶</a> 4. 快照 SNAPSHOTTING</h3><p>持久化，在规定的时间内执行了多少次写操作，则会持久化到文件中，rdb、aof。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">save 900 1 <span class="comment"># 如果至少有1个key发生变化，900秒后则会进行持久化操作</span></span><br><span class="line">save 300 10 <span class="comment"># 如果至少有是10个key发生变化，300秒后则会进行持久化操作</span></span><br><span class="line">save 60 10000 <span class="comment"># 如果至少有是10000个key发生变化，60秒后则会进行持久化操作</span></span><br><span class="line"></span><br><span class="line">stop-writes-on-bgsave-error no <span class="comment"># 持久化出错后，是否需要继续工作</span></span><br><span class="line">rdbcompression yes <span class="comment"># 是否压缩rdb文件，需要消耗一CPU资源</span></span><br><span class="line">rdbchecksum yes <span class="comment"># 保存和加载rdb文件时是否进行错误的检查效验</span></span><br><span class="line">dbfilename dump.rdb <span class="comment"># rdb文件名</span></span><br><span class="line">dir ./ <span class="comment"># rdb文件保存路径</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5.%20%E5%A4%8D%E5%88%B6%20REPLICATION"><a class="header-anchor" href="#5.%20%E5%A4%8D%E5%88%B6%20REPLICATION">¶</a> 5. 复制 REPLICATION</h3><p>主从复制</p><h3 id="6.%20%E5%AE%89%E5%85%A8%20SECURITY"><a class="header-anchor" href="#6.%20%E5%AE%89%E5%85%A8%20SECURITY">¶</a> 6. 安全 SECURITY</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">requirepass foobared <span class="comment"># 设置密码</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过命令更改密码</span></span><br><span class="line">&gt; config get requirepass</span><br><span class="line">1) <span class="string">&quot;requirepass&quot;</span></span><br><span class="line">2) <span class="string">&quot;&quot;</span></span><br><span class="line">&gt; config <span class="built_in">set</span> requirepass <span class="string">&quot;123456&quot;</span></span><br><span class="line">OK</span><br><span class="line">&gt; ping</span><br><span class="line">(error) NOAUTH Authentication required.</span><br><span class="line">&gt; auth 123456</span><br><span class="line">OK</span><br><span class="line">&gt; config get requirepass</span><br><span class="line">1) <span class="string">&quot;requirepass&quot;</span></span><br><span class="line">2) <span class="string">&quot;123456&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="7.%20%E5%AE%A2%E6%88%B7%E7%AB%AF%20CLIENTS"><a class="header-anchor" href="#7.%20%E5%AE%A2%E6%88%B7%E7%AB%AF%20CLIENTS">¶</a> 7. 客户端 CLIENTS</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxclients 10000 <span class="comment"># 设置同时连接的最大客户端数量</span></span><br></pre></td></tr></table></figure><h3 id="8.%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%20MEMORY%20MANAGEMENT"><a class="header-anchor" href="#8.%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%20MEMORY%20MANAGEMENT">¶</a> 8. 内存管理 MEMORY MANAGEMENT</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">maxmemory &lt;bytes&gt; <span class="comment"># 配置Redis最大内存限制</span></span><br><span class="line"></span><br><span class="line">axmemory-policy noeviction <span class="comment">#达到内存上限时Redis采用的清除策略</span></span><br><span class="line">    1）volatile-lru利用LRU算法移除有设置过期时间的key (LRU:最近使用 Least Recently Used ) </span><br><span class="line">    2）allkeys-lru利用LRU算法移除任何key </span><br><span class="line">    3）volatile-random移除有设置过期时间的随机key </span><br><span class="line">    4）allkeys-random移除随机key</span><br><span class="line">    5）volatile-ttl移除即将过期的key(minor TTL) </span><br><span class="line">    6）noeviction  noeviction不移除任何key，只是返回一个写错误 。默认选项</span><br></pre></td></tr></table></figure><h3 id="9.%20AOF%E9%85%8D%E7%BD%AE%20APPEND%20ONLY%20MODE"><a class="header-anchor" href="#9.%20AOF%E9%85%8D%E7%BD%AE%20APPEND%20ONLY%20MODE">¶</a> 9. AOF配置 APPEND ONLY MODE</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">appendonly no <span class="comment"># 默认不开启aof，在大部分情况下rdb已经够用了</span></span><br><span class="line">appendfilename <span class="string">&quot;appendonly.aof&quot;</span> <span class="comment"># 持久化的文件名</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># appendfsync always # 每次修改都会fsync()，安全但比较慢且耗性能</span></span><br><span class="line">appendfsync everysec <span class="comment"># 每秒执行一次fsync()，可能丢失1s的数据</span></span><br><span class="line"><span class="comment"># appendfsync no # 不执行fsync()，让操作系统自己同步数据，最快</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重写规则</span></span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line">auto-aof-rewrite-percentage 100 <span class="comment">#当aof日志大小增长率大于该值时，自动开启重写</span></span><br><span class="line">auto-aof-rewrite-min-size 64mb <span class="comment">#当aof日志大小增长到该值时，自动开启重写</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Redis%E6%8C%81%E4%B9%85%E5%8C%96"><a class="header-anchor" href="#Redis%E6%8C%81%E4%B9%85%E5%8C%96">¶</a> Redis持久化</h2><p>Redis是内存数据库，如果没有持久化，那么断电后就会失去数据，所以Redis提供了持久化的功能。</p><h3 id="RDB%EF%BC%88Redis%20Database%EF%BC%89"><a class="header-anchor" href="#RDB%EF%BC%88Redis%20Database%EF%BC%89">¶</a> RDB（Redis Database）</h3><p>在指定的时间间隔类将内存中的数据集进行快照存储，恢复的时候则将快照文件加载到内存中。</p><p><img src="/2020/10/13/Redis%E5%9F%BA%E7%A1%80-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20201002175210711-1603273481614.png" alt="rdb持久化过程" class="fancybox"></p><p>RDB在保存文件时父进程会单独创建（fork）一个子线程来进行持久化操作，先将数据写入一个临时文件中，写完成后，再用其替换掉上次已持久化的文件。整个过程主线程不进行IO操作，故而确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那么RDB方式要比AOF方式更加的高效。</p><p><strong>触发机制</strong></p><ol><li>save的规则满足的情况下，会自动触发RDB操作</li><li>执行flushall命令</li><li>退出Redis，也会产生RDB 文件</li></ol><p>备份就自动生成了一个dump.rdb文件</p><p><strong>恢复rdb文件</strong></p><ol><li><p>只需要将rbd文件放在Redis配置目录，启动时会自动检查dump.rdb并从中恢复数据</p></li><li><p>查看rdb文件保存路径</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; config get dir </span><br><span class="line">1) <span class="string">&quot;dir&quot;</span></span><br><span class="line">2) <span class="string">&quot;/usr/local/redis/redis-cluster/7001&quot;</span></span><br></pre></td></tr></table></figure><p><strong>优点：</strong></p><ul><li>RDB是一个单一的紧凑的文件，方便传输</li><li>适用于数据集的备份，可以根据需求恢复到不同版本的数据集</li><li>适合大规模的数据恢复</li></ul><p><strong>缺点:</strong></p><ul><li>由于需要一定时间间隔进行操作，在Redis意外宕机时丢失的数据较多</li><li>当数据集比较大的时候，创建子进程的过程是非常耗时的，可能会导致Redis在一些毫秒级内不能响应客户端的请求。</li></ul><h3 id="AOF%EF%BC%88Append%20Only%20File%EF%BC%89"><a class="header-anchor" href="#AOF%EF%BC%88Append%20Only%20File%EF%BC%89">¶</a> AOF（Append Only File）</h3><p>以日志文本的形式记录Redis所处理的每一个写操作，恢复的时候把文件汇中的命令都执行一遍即可。</p><p>命令实时写入和重写(rewrite)，由于缓存的写操作是实时写入aof文件，当触发重写规则（如：aof文件过大）时，会重新生成恢复当前数据集所需的最小命令集合，即rewrite操作。</p><p><img src="/2020/10/13/Redis%E5%9F%BA%E7%A1%80-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20201002191438203-1603273481614.png" alt="rewrite流程" class="fancybox"></p><p>appendonly.aof</p><p>如果aof文件有问题，redis启动不了，可以通过<code>redis-check-aof --fix</code>工具修复aof文件。</p><p><strong>优点：</strong></p><ul><li>每一次修改都同步，文件的完整性更好</li><li>每秒fsync时，可能会丢失一秒的数据，</li></ul><p><strong>缺点:</strong></p><ul><li>对于相同的数据集来说，aof文件体积远大于rdb，修复速度也比rdb慢</li><li>根据所使用的 fsync 策略，AOF 的速度可能会慢于 RDB。在处理巨大的写入载入时，RDB 可以提供更有保证的最大延迟时间（latency）</li></ul><p><img src="/2020/10/13/Redis%E5%9F%BA%E7%A1%80-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20201002223857890-1603273481615.png" alt="image-20201002223857890" class="fancybox"></p><p><img src="/2020/10/13/Redis%E5%9F%BA%E7%A1%80-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20201002223944105-1603273481615.png" alt="image-20201002223944105" class="fancybox"></p><h2 id="Redis%E5%8F%91%E5%B8%83%E4%B8%8E%E8%AE%A2%E9%98%85"><a class="header-anchor" href="#Redis%E5%8F%91%E5%B8%83%E4%B8%8E%E8%AE%A2%E9%98%85">¶</a> Redis发布与订阅</h2><p>Redis发布订阅(pub/sub)是一种<mark>消息通信模式</mark>：发送者(pub)发送消息，订阅者(sub)接收消息。传送消息的链路称为<mark>信道</mark>。</p><p><img src="/2020/10/13/Redis%E5%9F%BA%E7%A1%80-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20201002225013710-1603273481615.png" alt="image-20201002225013710" class="fancybox"></p><p><strong>命令</strong></p><table><thead><tr><th>序号</th><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td><a href="https://www.runoob.com/redis/pub-sub-psubscribe.html">PSUBSCRIBE pattern [pattern …]</a></td><td>订阅一个或多个符合给定模式的频道。</td></tr><tr><td>2</td><td>[PUBSUB subcommand <a href="https://www.runoob.com/redis/pub-sub-pubsub.html">argument [argument …]]</a></td><td>查看订阅与发布系统状态。</td></tr><tr><td>3</td><td><a href="https://www.runoob.com/redis/pub-sub-publish.html">PUBLISH channel message</a></td><td>将信息发送到指定的频道。</td></tr><tr><td>4</td><td>[ PUNSUBSCRIBE <a href="https://www.runoob.com/redis/pub-sub-punsubscribe.html">pattern [pattern …]]</a></td><td>退订所有给定模式的频道。</td></tr><tr><td>5</td><td><a href="https://www.runoob.com/redis/pub-sub-subscribe.html"> SUBSCRIBE channel [channel …]</a></td><td>订阅给定的一个或多个频道的信息。</td></tr><tr><td>6</td><td>[ UNSUBSCRIBE <a href="https://www.runoob.com/redis/pub-sub-unsubscribe.html">channel [channel …]]</a></td><td>只退订给定的频道。</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; SUBSCRIBE MyChannel <span class="comment"># 订阅频道</span></span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) <span class="string">&quot;subscribe&quot;</span></span><br><span class="line">2) <span class="string">&quot;MyChannel&quot;</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment"># 等待读取推送的信息</span></span><br><span class="line">1) <span class="string">&quot;message&quot;</span> <span class="comment"># 消息</span></span><br><span class="line">2) <span class="string">&quot;MyChannel&quot;</span> <span class="comment"># 来自哪个频道的消息</span></span><br><span class="line">3) <span class="string">&quot;hello,test&quot;</span> <span class="comment"># 消息的具体内容</span></span><br><span class="line"></span><br><span class="line">&gt; PUBLISH MyChannel <span class="string">&quot;hello,test&quot;</span> <span class="comment"># 将信息发送到指定的频道</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure><p><strong>使用场景</strong></p><ul><li>用于构建即时通信应用，如：网络聊天室、实时广播、实时提醒等</li><li>订阅、关注系统</li></ul><p>较复杂的场景会使用消息中间件 MQ</p><p><img src="/2020/10/13/Redis%E5%9F%BA%E7%A1%80-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20201002232010221-1603273481615.png" alt="image-20201002232010221" class="fancybox"></p><h2 id="Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><a class="header-anchor" href="#Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6">¶</a> Redis主从复制</h2><h4 id="%E6%A6%82%E5%BF%B5"><a class="header-anchor" href="#%E6%A6%82%E5%BF%B5">¶</a> 概念</h4><p>主从复制,是指将一台Redis服务器的数据,复制到其他的Redis服务器。前者称为主节点(master/leader)，后者称为从节点(slave/follower) ；数据的复制是单向的，只能由主节点到从节点。Master以写为主，Slave 以读为主（读写分离）。</p><p>默认情况下，每台Redis服务器都是主节点；且一个主节点可以有多个从节点(或没有从节点) ，但一个从节点只能有一个主节点。</p><p>主从复制的作用主要包括：</p><ol><li><strong>数据冗余：</strong> 主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。</li><li><strong>故障恢复：</strong> 当主节点出现问题时，可以由从节点提供服务,实现快速的故障恢复；实际上是-一种服务的冗余。</li><li><strong>负载均衡：</strong> 在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务(即写Redis数据时应用连接主节点,读Redis数据时应用连接从节点)，分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。</li><li><strong>高可用基石：</strong> 除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。</li></ol><p><img src="/2020/10/13/Redis%E5%9F%BA%E7%A1%80-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20201003180444252-1603273481615.png" alt="image-20201003180444252" class="fancybox"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; info replication <span class="comment"># 查看当前redis节点信息</span></span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:1</span><br><span class="line">slave0:ip=192.168.26.128,port=7006,state=online,offset=280,lag=1</span><br><span class="line">master_replid:8a90b2da230485bb190eb2e443bb324cbb8d7371</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:280</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:280</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="%E6%90%AD%E5%BB%BA"><a class="header-anchor" href="#%E6%90%AD%E5%BB%BA">¶</a> <strong>搭建</strong></h4><h5 id="1.%20%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><a class="header-anchor" href="#1.%20%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">¶</a> 1. 修改配置文件</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bind</span> </span><br><span class="line">port 7001</span><br><span class="line">daemonize yes</span><br><span class="line">pidfile /var/run/redis_7001.pid</span><br><span class="line">logfile <span class="string">&quot;redis_7001.log&quot;</span></span><br><span class="line">dbfilename dump_7006.rdb</span><br><span class="line">cluster-enabled yes <span class="comment"># 开启集群  </span></span><br><span class="line">cluster-config-file nodes_7001.conf   <span class="comment"># 集群的配置 配置文件</span></span><br><span class="line">cluster-node-timeout  15000      </span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="2.%20%E8%84%9A%E6%9C%AC%E5%90%AF%E5%8A%A8%E6%96%87%E4%BB%B6start.sh"><a class="header-anchor" href="#2.%20%E8%84%9A%E6%9C%AC%E5%90%AF%E5%8A%A8%E6%96%87%E4%BB%B6start.sh">¶</a> 2. 脚本启动文件<code>start.sh</code></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">cd</span> 7001 &amp;&amp; ../../bin/redis-server redis.conf</span><br><span class="line"><span class="built_in">cd</span> ../7002 &amp;&amp; ../../bin/redis-server redis.conf</span><br><span class="line"><span class="built_in">cd</span> ../7003 &amp;&amp; ../../bin/redis-server redis.conf</span><br><span class="line"><span class="built_in">cd</span> ..</span><br></pre></td></tr></table></figure><h5 id="3.%20%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%A8%A1%E5%BC%8F%E9%85%8D%E7%BD%AE%EF%BC%88master-slave%20replication%EF%BC%89%EF%BC%88%E8%BF%98%E6%9C%89%E5%A4%9A%E7%BA%A7%E5%A4%8D%E5%88%B6%EF%BC%89"><a class="header-anchor" href="#3.%20%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%A8%A1%E5%BC%8F%E9%85%8D%E7%BD%AE%EF%BC%88master-slave%20replication%EF%BC%89%EF%BC%88%E8%BF%98%E6%9C%89%E5%A4%9A%E7%BA%A7%E5%A4%8D%E5%88%B6%EF%BC%89">¶</a> 3. 主从复制模式配置（master-slave replication）（还有多级复制）</h5><ul><li><p>一主二从，命令中配置，本次运行有效</p><p>主机可以设置值，从机只能读；</p><p>主机宕机后，从机依旧连接到主机，主机重启后从机会自动连接上；</p><p>从机重启后，则会变为主机，只要又设置为从机，则会立即从主机复制数据；</p><p>如果主机断开了连接，可以使用<code>SLAVEOF no one</code>让自己变成主机，其他的节点就可以手动连接到最新的这个主节点( 手动选举)。</p></li></ul><blockquote><p>复制原理</p><p>Slave启动成功连接到master后会发送一个sync同步命令<br>Master接到命令，启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后， <mark>master将传送整个数据文件到slave，并完成一-次完全同步。</mark><br><strong>全量复制：</strong> 而slave服务在接收到数据库文件数据后,将其存盘并加载到内存中。<br><strong>增量复制：</strong> Master继续将新的所有收集到的修改命令依次传给slave，完成同步<br>但是只要是重新连接master , 一次完全同步(全量复制)将被自动执行</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&gt;SLAVEOF 127.0.0.1 7001</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:slave <span class="comment"># 从节点</span></span><br><span class="line">master_host:192.168.26.128</span><br><span class="line">master_port:7001 <span class="comment"># 它的主节点</span></span><br><span class="line">master_link_status:up</span><br><span class="line">master_last_io_seconds_ago:1</span><br><span class="line">master_sync_in_progress:0</span><br><span class="line">slave_repl_offset:2128</span><br><span class="line">slave_priority:100</span><br><span class="line">slave_read_only:1</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_replid:c4b29fdc590e84132d6055078fa03306a6ed1cbf</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:2128</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:2128</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="4.%20%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%EF%BC%88%20Sentinel%EF%BC%89"><a class="header-anchor" href="#4.%20%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%EF%BC%88%20Sentinel%EF%BC%89">¶</a> 4. 哨兵模式（ Sentinel）</h5><p>哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程,作为进程,它会独立运行。</p><p>三个任务：</p><ul><li><strong>监控（Monitoring）</strong>： Sentinel 会不断地检查主服务器和从服务器是否运作正常。</li></ul><ul><li><strong>提醒（Notification）</strong>： 当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。</li><li><strong>自动故障迁移（Automatic failover）</strong>：当一个主服务器不能正常工作时， Sentinel 会使用投票协议（agreement protocols）来决定是否执行自动故障迁移， 以及选择哪个从服务器作为新的主服务器。</li></ul><p><img src="/2020/10/13/Redis%E5%9F%BA%E7%A1%80-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20201003193304549-1603273481616.png" alt="哨兵模式" class="fancybox"></p><p>这里的哨兵有两个作用</p><ul><li>通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器。</li><li>当哨兵监测到master宕机，会自动将slave切换成master，然后通过<mark>发布订阅</mark>模式通知其他的从服务器,修改配置文件，让它们切换主机。</li></ul><p>然而一个哨兵进程对Redis服务器进行监控,可能会出现问题，为此，我们可以使用多个哨兵进行监控。各个哨兵之间还会进行监控,这样就形成了多哨兵模式。</p><p><img src="/2020/10/13/Redis%E5%9F%BA%E7%A1%80-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20201003193545996-1603273481616.png" alt="多哨兵模式" class="fancybox"></p><p>假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行failover过程，仅仅是哨兵1主观的认为主服务器不可用，这个现象成为<strong>主观下线</strong>。当后面的哨兵也检测到主服务器不可用,并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover[故障转移]操作。切换成功后，就会通过发布订阅模式,让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为<strong>客观下线</strong>。</p><p><strong>配置</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 监视一个名为mymaster的主服务器，其IP为127.0.0.1和port为7001，</span></span><br><span class="line"><span class="comment"># 2代表至少需要2个Sentinel同意（大多数Sentinel正常），该服务器才被判断为已失效宕机 </span></span><br><span class="line">sentinel monitor mymaster 127.0.0.1 7001 2</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看节点信息</span></span><br><span class="line">./redis-cli -h 192.168.26.128 -c -p 7001 cluster nodes</span><br></pre></td></tr></table></figure><h2 id="Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%92%8C%E9%9B%AA%E5%B4%A9"><a class="header-anchor" href="#Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%92%8C%E9%9B%AA%E5%B4%A9">¶</a> Redis缓存穿透和雪崩</h2><p>Redis缓存的使用，极大的提升了应用程序的性能和效率，特别是数据查询方面。但同时，它也带来了一些问题。其中，最要害的问题，就是数据的一致性问题，从严格意义上讲，这个问题无解。如果对数据的一致性要求很高，那么就不能使用缓存。</p><p>另外的一些典型问题就是，缓存穿透、缓存雪崩和缓存击穿。目前，业界也都有比较流行的解决方案。</p><p><img src="/2020/10/13/Redis%E5%9F%BA%E7%A1%80-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20201021164003157.png" alt="image-20201021164003157" class="fancybox"></p><h4 id="%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><a class="header-anchor" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F">¶</a> 缓存穿透</h4><blockquote><p><strong>概念：</strong></p></blockquote><p>​缓存穿透的概念很简单，用户想要查询一个数据，发现redis数据库没有，即缓存未命中，于是从持久层数据库查询。发现也没有，则本次查询失败。当用户很多的时候，缓存都没有命中(秒杀! )，于是都去请求持久层数据库。这就给持久层数据库带来很大的压力，这时候就相当于出现了缓存穿透。</p><blockquote><p><strong>解决方案：</strong></p></blockquote><p><strong>布隆过滤器</strong></p><p>布隆过滤器是一种数据结构，对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃，从而避免了对底层存储系统的查询压力;</p><p><img src="/2020/10/13/Redis%E5%9F%BA%E7%A1%80-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20201021165228987.png" alt="image-20201021165228987" class="fancybox"></p><p><strong>缓存空对象</strong></p><p>当存储层未命中后，即使返回的是空对象也将其缓存起来，同时设置一个过期时间，之后再访问该数据将会从缓存中获取，避免了给后端数据库带来压力。</p><p><img src="/2020/10/13/Redis%E5%9F%BA%E7%A1%80-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20201021165652288.png" alt="image-20201021165652288" class="fancybox"></p><p>但是这种方法会存在两个问题：</p><ol><li>如果空值能够被缓存起来，这就意味着缓存需要更多的空间存储更多的键；</li><li>即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响。</li></ol><h4 id="%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><a class="header-anchor" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF">¶</a> 缓存击穿</h4><blockquote><p><strong>概述</strong></p></blockquote><p>​这里需要注意和缓存击穿的区别缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。</p><p>​当某个key在过期的瞬间，有大量的请求并发访问，这类数据一般是热点数据，由于缓存过期，会同时访问数据库来查询最新数据，并且回写缓存，会导使数据库瞬间压力过大。</p><blockquote><p><strong>解决方案</strong></p></blockquote><p><strong>设置热点数据永不过期</strong></p><p>从缓存层面来看，没有设置过期时间，所以不会出现热点key过期后产生的问题。</p><p><strong>加互斥锁</strong></p><p>分布式锁：使用分布式锁，保证对于每个key同时只有一个线程去查询后端服务，其他线程没有获得分布式锁的权限，因此只需要等待即可。这种方式将高井发的压力转移到了分布式锁，因此对分布式锁的考验很大。</p><p><img src="/2020/10/13/Redis%E5%9F%BA%E7%A1%80-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20201021170505844.png" alt="image-20201021170505844" class="fancybox"></p><h4 id="%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><a class="header-anchor" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9">¶</a> 缓存雪崩</h4><p>缓存雪崩，是指在某一个时间段，缓存集中过期失效，Redis 宕机。</p><p>比如在写本文的时候,马上就要到双11零点，很快就会迎来一波抢购，这波商品时间比较集中的放入了缓存，假设缓存一个小时。那么到了凌晨一点钟的时候，这批商品的缓存就都过期了。而对这批商品的访问查询，都落到了数据库上，对于数据库而言,就会产生周期性的压力波峰。于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况。</p><p><img src="/2020/10/13/Redis%E5%9F%BA%E7%A1%80-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20201021170804287.png" alt="image-20201021170804287" class="fancybox"></p><p>其实集中过期，倒不是非常致命，比较致命的缓存雪崩，是缓存服务器某个节点宕机或断网。因为自然形成的缓存雪崩，一定是在某个时间段集中创建缓存，这个时候，数据库也是可以顶住压力的。无非就是对数据库产生周期性的压力而已。而缓存服务节点的宕机，对数据库服务器造成的压力是不可预知的，很有可能瞬间就把数据库压垮。</p><p>双11：停掉一些服务，( 保证主要的服务可用 )</p><blockquote><p><strong>解决方案</strong></p></blockquote><p><strong>redis高可用</strong></p><p>这个思想的含义是，既然redis有可能挂掉，那我多增设几台redis，这样一台挂掉之后其他的还可以继续工作，其实就是搭建的集群。（异地多活）</p><p><strong>限流降级</strong></p><p>这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。</p><p><strong>数据预热</strong></p><p>数据加热的含义就是在正式部署之前，先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。</p><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.6.0/katex.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Redis 是一个内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;NoSQL%E6%A6%82%E8%BF%B0&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#NoSQL%E6%A6%82%E8%BF%B</summary>
      
    
    
    
    <category term="技术" scheme="http://lampkins.gitee.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="数据库" scheme="http://lampkins.gitee.io/categories/%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="Java" scheme="http://lampkins.gitee.io/tags/Java/"/>
    
    <category term="Redis" scheme="http://lampkins.gitee.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Java虚拟机 JVM笔记</title>
    <link href="http://lampkins.gitee.io/2020/10/12/Java%E8%99%9A%E6%8B%9F%E6%9C%BAJVM%E7%AC%94%E8%AE%B0/"/>
    <id>http://lampkins.gitee.io/2020/10/12/Java%E8%99%9A%E6%8B%9F%E6%9C%BAJVM%E7%AC%94%E8%AE%B0/</id>
    <published>2020-10-12T12:41:05.202Z</published>
    <updated>2020-10-23T09:23:46.663Z</updated>
    
    <content type="html"><![CDATA[<p>JVM是JRE的一部分，是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。</p><hr><h1 id="JVM%E6%8E%A2%E7%A9%B6"><a class="header-anchor" href="#JVM%E6%8E%A2%E7%A9%B6">¶</a> JVM探究</h1><ul><li>请你谈谈你对JVM的理解？java8虚拟机和之前的变化更新”</li><li>什么是OOM？什么是栈溢出StackOverFlowError？怎么分析？</li><li>JVM的常用调优参数有哪些？</li><li>内存快照如何抓取？怎么分析Dump文件?知道吗？谈谈JVM中，类加载器你的认识？</li></ul><blockquote><p><a href="https://processon.com/view/5c749debe4b0f9fba6921d15"><strong>jvm java运行时数据分析，垃圾回收</strong></a></p><p><a href="https://processon.com/view/5ea7a1b9e401fd21c196eb17"><strong>JVM内存模型完整版</strong></a></p></blockquote><h2 id="1.%20JVM%E7%9A%84%E4%BD%8D%E7%BD%AE"><a class="header-anchor" href="#1.%20JVM%E7%9A%84%E4%BD%8D%E7%BD%AE">¶</a> 1. JVM的位置</h2><p><img src="/2020/10/12/Java%E8%99%9A%E6%8B%9F%E6%9C%BAJVM%E7%AC%94%E8%AE%B0/image-20201004185637450.png" alt="image-20201004185637450" class="fancybox"></p><h2 id="2.%20JVM%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><a class="header-anchor" href="#2.%20JVM%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84">¶</a> 2. JVM的体系结构</h2><p><img src="/2020/10/12/Java%E8%99%9A%E6%8B%9F%E6%9C%BAJVM%E7%AC%94%E8%AE%B0/image-20201004214922822.png" alt="image-20201004214922822" class="fancybox"></p><p><img src="/2020/10/12/Java%E8%99%9A%E6%8B%9F%E6%9C%BAJVM%E7%AC%94%E8%AE%B0/image-20201005183502733.png" alt="创建对象内存分析" class="fancybox"></p><h2 id="3.%20%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><a class="header-anchor" href="#3.%20%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8">¶</a> 3. 类加载器</h2><p>作用：加载Class文件</p><p><img src="/2020/10/12/Java%E8%99%9A%E6%8B%9F%E6%9C%BAJVM%E7%AC%94%E8%AE%B0/image-20201004230714888.png" alt="image-20201004230714888" class="fancybox"></p><p>虚拟机自带的加载器</p><ol><li><p><strong>启动类（根）加载器 Bootstrap ClassLoader</strong></p><p>加载<code>java</code>核心库 <code>java.*</code>，构造<code>ExtClassLoader</code>和<code>AppClassLoader</code></p></li><li><p><strong>扩展类加载器 Extension ClassLoader</strong></p><p>加载扩展库，如<code>classpath</code>中的<code>jre</code> ，<code>javax.*</code>或者<code>java.ext.dir</code> 指定位置中的类，开发者可以直接使用标准扩展类加载器。</p></li><li><p><strong>应用程序（系统类）加载器 AppClassLoader</strong></p><p>加载程序所在的目录，如<code>user.dir</code>所在的位置的<code>class</code></p></li><li><p><strong>用户自定义类加载器 CustomClassLoader</strong></p><p>用户自定义的类加载器,可加载指定路径的<code>class</code>文件</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(classLoader); <span class="comment">//AppClassLoader</span></span><br><span class="line">System.out.println(classLoader.getParent()); <span class="comment">//ExtClassLoader jre\lib\ext</span></span><br><span class="line">System.out.println(classLoader.getParent().getParent); <span class="comment">//null jre\lib\rt.jar</span></span><br></pre></td></tr></table></figure><h2 id="4.%20%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><a class="header-anchor" href="#4.%20%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6">¶</a> 4. 双亲委派机制</h2><p>APP – EXC – BOOT</p><p>向上委托，向下查找</p><p><strong>过程</strong></p><ol><li>类加载器收到类加载的请求!</li><li>将这个请求向上委托给父类加载器去完成，一直向上委托，直到启动类加载器 （loadClass(name, false), findBootstrapClassOrNull(name)）</li><li>启动类加载器检查是否能够加载当前这个类，能加载就结束，使用当前的加载器，否则， 抛出异常，通知子加载器进行加载 （fingClass(name)）</li><li>重复步骤3<br>Class Not Found ~</li></ol><p><img src="/2020/10/12/Java%E8%99%9A%E6%8B%9F%E6%9C%BAJVM%E7%AC%94%E8%AE%B0/7634245-7b7882e1f4ea5d7d.png" alt="7634245-7b7882e1f4ea5d7d.png" class="fancybox"></p><p><strong>作用</strong></p><ul><li>防止加载同一个<code>.class</code>。通过委托向上一级询问，加载过了，就不用再加载一遍，保证数据安全</li><li>保证核心<code>.class</code>不能被篡改。通过委托方式，不会去篡改核心<code>.clas</code>，即使篡改也不会去加载，即使加载也不会是同一个<code>.class</code>对象了。不同的加载器加载同一个<code>.class</code>也不是同一个<code>Class</code>对象。这样保证了<code>Class</code>执行安全。</li></ul><h2 id="5.%20%E6%B2%99%E7%AE%B1%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6"><a class="header-anchor" href="#5.%20%E6%B2%99%E7%AE%B1%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6">¶</a> 5. 沙箱安全机制</h2><p>​沙箱是一个限制程序运行的环境。沙箱机制就是将 Java 代码限定在虚拟机(JVM)特定的运行范围中，并且严格限制代码对本地系统资源访问，通过这样的措施来保证对代码的有效隔离，防止对本地系统造成破坏。沙箱<strong>主要限制系统资源访问</strong>，那系统资源包括什么？——<code>CPU、内存、文件系统、网络</code>。不同级别的沙箱对这些资源访问的限制也可以不一样。</p><blockquote><p><a href="https://blog.csdn.net/qq_30336433/article/details/83268945">java中的安全模型(沙箱机制)</a></p></blockquote><h2 id="6.%20Native"><a class="header-anchor" href="#6.%20Native">¶</a> 6. Native</h2><p>native关键字：说明java的作用范围达不到了，进入本地方法栈，调用本地方法接口（JNI）去调用底层的库。</p><p><strong>JNI：Java Native Interface（Java本地方法接口）</strong><br>凡是带了native关键宇的方法就会进入本地方法栈，其他的就是Java栈</p><p><strong>Native Interface</strong>本地接口<br>本地接口的作用是融合不同的编程语言为Java所用，它的具体做法是在Native Method Stack中登记native方法，在(Execution Engine )执行引擎执行的时候加载Native Libraies.</p><p>​目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过Java程序驱动打印机或者Java系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间通信很发达，比如可以使用Socket通信，也可以使用Web Service等等，不多做介绍!</p><p><strong>Native Method Stack</strong></p><h2 id="7.%20PC%E5%AF%84%E5%AD%98%E5%99%A8"><a class="header-anchor" href="#7.%20PC%E5%AF%84%E5%AD%98%E5%99%A8">¶</a> 7. PC寄存器</h2><p>程序计数器: Program Counter Register<br>每个线程都有一个程序计数器，是线程私有的，就是一个指针， 指向方法区中的方法字节码(用来存储指向一条指令的地址，也即将要执行的指令代码)，在执行引擎读取下一-条指令,是一个非常小的内存空间，几乎可以忽略不计</p><h2 id="8.%20%E6%96%B9%E6%B3%95%E5%8C%BA%EF%BC%88%E9%9D%99%E6%80%81%E5%8C%BA%EF%BC%89"><a class="header-anchor" href="#8.%20%E6%96%B9%E6%B3%95%E5%8C%BA%EF%BC%88%E9%9D%99%E6%80%81%E5%8C%BA%EF%BC%89">¶</a> 8. 方法区（静态区）</h2><p>Method Area方法区<br>方法区是被所有线程共享,所有字段和方法字节码，以及-一些特殊方法，如构造函数,接口代码也在此定义，简单说，所有定义的方法的信息都保存在该区域，<strong>此区域属于共享区间</strong>；<br><mark>静态变量、常量、类信息(构造方法、接口定义)、串池、运行时的常量池存在方法区中，但是实例变量存在堆内存中，和方法区无关</mark></p><p>​static、final、Class、常量池（对象字面量：基本类型的包装类对象字面量[-128,127]，String对象字面量）</p><h2 id="9.%20%E6%A0%88%E5%86%85%E5%AD%98"><a class="header-anchor" href="#9.%20%E6%A0%88%E5%86%85%E5%AD%98">¶</a> 9. 栈内存</h2><p>栈（栈内存），主管线程的运行，生命周期和线程同步</p><p>线程结束栈内存就释放了，栈内存空了程序就结束了；不存在垃圾回收问题</p><p>栈内存常存放：局部变量 基本数据类型、对象引用、方法引用</p><p>栈内存运行原理：栈帧</p><p><img src="/2020/10/12/Java%E8%99%9A%E6%8B%9F%E6%9C%BAJVM%E7%AC%94%E8%AE%B0/image-20201005231633641.png" alt="栈内存及栈帧" class="fancybox"></p><blockquote><p><a href="https://www.cnblogs.com/yanl55555/p/12616356.html">Java虚拟机栈–栈帧</a></p></blockquote><h2 id="10.%20%E4%B8%89%E7%A7%8DJVM"><a class="header-anchor" href="#10.%20%E4%B8%89%E7%A7%8DJVM">¶</a> 10. 三种JVM</h2><ul><li>Sun公司：<code>Java HotSpot(TM) 64-Bit Server VM (build 25.221-b11, mixed mode)</code></li><li>BEA公司：<code>Oracle JRockit （原来的 Bea JRockit）</code></li><li>IBM公司：J9VM</li></ul><h2 id="11.%20%E5%A0%86%E5%86%85%E5%AD%98"><a class="header-anchor" href="#11.%20%E5%A0%86%E5%86%85%E5%AD%98">¶</a> 11. 堆内存</h2><p>Heap，一个JVM只有一个堆内存，堆内存的大小是可以调节的。<br>类加载器读取了类文件后，一般会把什么东西放到堆中？<mark>类, 方法，常量，变量，保存引用类型的真实对象</mark></p><p><img src="/2020/10/12/Java%E8%99%9A%E6%8B%9F%E6%9C%BAJVM%E7%AC%94%E8%AE%B0/image-20201006182522720.png" alt="堆内存模型" class="fancybox"></p><ul><li>新生区<ul><li>Eden区</li><li>Survivor from区</li><li>Survivor to区</li><li>8:1:1</li></ul></li><li>老年区</li><li>元空间  永久区</li></ul><p>轻GC在新生区，重GC(full GC)在老年区</p><p>假设内存满了，OOM，堆内存不够！ <code>java.lang.OutOfMemoryError: Java heap space</code></p><h2 id="12.%20%E6%96%B0%E7%94%9F%E5%8C%BA%20%E8%80%81%E5%B9%B4%E5%8C%BA"><a class="header-anchor" href="#12.%20%E6%96%B0%E7%94%9F%E5%8C%BA%20%E8%80%81%E5%B9%B4%E5%8C%BA">¶</a> 12. 新生区 老年区</h2><h2 id="13.%20%E6%B0%B8%E4%B9%85%E5%8C%BA"><a class="header-anchor" href="#13.%20%E6%B0%B8%E4%B9%85%E5%8C%BA">¶</a> 13. 永久区</h2><p>这个区域常驻内存的。用来存放JDK自身携带的lass对象。Interface元数据， 存储的是ava运行时的一些环境或类信息，不存在垃圾回收。关闭jvm虚拟机会释放这个区域的内存。</p><ul><li>jdk1.6之前：永久代，常量池是在方法区；</li><li>jdk1.7：永久代，但是慢慢的退化了，去永久代，常量池在堆中</li><li>jdk1.8之后：无永久代，被元空间所取代，最大区别：<mark>元空间并不在虚拟机中，而是使用本地内存。</mark></li></ul><h2 id="14.%20%E5%A0%86%E5%86%85%E5%AD%98%E8%B0%83%E4%BC%98"><a class="header-anchor" href="#14.%20%E5%A0%86%E5%86%85%E5%AD%98%E8%B0%83%E4%BC%98">¶</a> 14. 堆内存调优</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回jvm试图使用的最大内存</span></span><br><span class="line"><span class="keyword">long</span> max = Runtime.getRuntime().maxMemory();</span><br><span class="line"><span class="comment">// 返回jvm的初始化总内存，会随着时间发生变化</span></span><br><span class="line"><span class="keyword">long</span> total = Runtime.getRuntime().totalMemory();</span><br></pre></td></tr></table></figure><p>默认情况下，maxMemory是电脑内存的1/4，totalMemory是1/64</p><p><code>-Xms1024m -Xmx1024m -XX:+PrintGCDetails</code></p><blockquote><p>-Xms<size> 设置初始Java堆大小</size></p><p>Xmx<size> 设置最大Java堆大小</size></p></blockquote><p><img src="/2020/10/12/Java%E8%99%9A%E6%8B%9F%E6%9C%BAJVM%E7%AC%94%E8%AE%B0/image-20201006223130183.png" alt="image-20201006223130183"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -Xms8m -Xmx8m -XX:+PrintGCDetails</span></span><br><span class="line">String str = <span class="string">&quot;str&quot;</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">    str = str +<span class="keyword">new</span> Random().nextInt(<span class="number">999999999</span>)+str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 先进行了5次轻GC，Eden区进入Survivor区导致，满了（或者年龄即轻GC次数到了），进入老年代，老年代满了，进行第一次重GC，清理年轻代，清理老年代(丢弃或进入元空间)...最后Java堆 老年代和元空间都满了 抛出OOM异常</span></span><br></pre></td></tr></table></figure><p><img src="/2020/10/12/Java%E8%99%9A%E6%8B%9F%E6%9C%BAJVM%E7%AC%94%E8%AE%B0/image-20201006234524118.png" alt="image-20201006234524118"></p><blockquote><p>GC表示的是进行一次Minor GC<br>Allocation Failure：表示分配担保失败。<br>PSYoungGen：新生代采用Parallel Scavenge收集器<br>1536K-&gt;504K(2048K)：GC前该区域已使用容量-&gt;GC后该区域已经使用的容量(该区域总容量)<br>1536K-&gt;817K(7680K)：方括号外的数字表示 GC前Java堆已用容量-&gt;GC后Java堆容量(Java堆总容量)<br>0.0013784 secs：该内存区域GC所用的时间<br>Times: user=0.00 sys=0.00, real=0.00 secs：用户态消耗的CPU时间，内核态消耗的CPU时间，操作从开始到结束所经历的墙钟时间(Wall Clock Time)</p><p>Full GC完全的垃圾回收<br>Ergonomics工程<br>ParOldGen老年代采用Parallel Old收集器<br>Metaspace元数据空间垃圾回收</p></blockquote><h3 id="Java%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7"><a class="header-anchor" href="#Java%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7">¶</a> Java内存分析工具</h3><p>OOM，排错：</p><ol><li><p>尝试扩大堆内存看结果</p><ol start="2"><li>分析内存，看一下那里出现问题（工具分析）<ul><li>Debug，一行行分析代码</li><li>内存快照分析工具，MAT，JProfiler</li></ul></li></ol></li></ol><p><strong>MAT、Jprofiler作用：</strong></p><ul><li>分析Dump内存文件，快速定位内存泄露</li><li>获取堆中的数据</li><li>获得大的对象</li><li>…</li></ul><p>当抛出OOM时进行HeapDump：<code>-Xms1m -Xmx8m -XX:+HeapDumpOnOutOfMemoryError</code></p><blockquote><p><a href="https://blog.csdn.net/vicky_pyh/article/details/88797514">Jprofiler的安装和使用</a></p></blockquote><h2 id="15.%20GC"><a class="header-anchor" href="#15.%20GC">¶</a> 15. GC</h2><p><strong>目的：</strong> 回收堆内存中不再使用的对象，释放资源<br><strong>回收时间：</strong> 当对象永久地失去引用后，系统会在合适的时候回收它所占用的内存。</p><p><code>System.gc(); / Runtime.getRuntime().gc();</code></p><h3 id="15.1%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%B8%8E%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95"><a class="header-anchor" href="#15.1%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%B8%8E%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95">¶</a> 15.1 垃圾回收与常用算法</h3><h4 id="%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E5%9E%83%E5%9C%BE%EF%BC%9F"><a class="header-anchor" href="#%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E5%9E%83%E5%9C%BE%EF%BC%9F">¶</a> 如何确定垃圾？</h4><ul><li><p><strong>引用计数法</strong></p><p>​一个对象如果没有任何与之关联的引用，即他的引用计数都为0，则说明对象不太可能再被用到，那么这个对象就是可回收对象。会出现<strong>循环引用问题</strong></p></li></ul><p><img src="/2020/10/12/Java%E8%99%9A%E6%8B%9F%E6%9C%BAJVM%E7%AC%94%E8%AE%B0/image-20201007225319656.png" alt="image-20201007225319656" class="fancybox"></p><ul><li><p><strong>可达性分析</strong></p><p>​当一个对象到任意一个GC Roots对象没有任何引用链相连时，则称该对象是不可达的。 要注意的是，不可达对象不等价于可回收对象，不可达对象变为可回收对象至少要经过两次标记 过程。两次标记后仍然是可回收对象，则将面临回收。</p></li></ul><h4 id="%E5%A6%82%E4%BD%95%E6%B8%85%E9%99%A4%E5%9E%83%E5%9C%BE%EF%BC%9F"><a class="header-anchor" href="#%E5%A6%82%E4%BD%95%E6%B8%85%E9%99%A4%E5%9E%83%E5%9C%BE%EF%BC%9F">¶</a> 如何清除垃圾？</h4><ul><li><p><strong>复制算法</strong></p><p>将内存按内存容量划分为等大小的两块，当这块内存需要垃圾回收时,将此区域还存活的对象复制到另一块中，然后把这块内存清理掉。</p><p>每次对整个半区进行操作，解决了内存碎片化的问题，但会多使用一定的内存空间，且存活对象较多时，效率会大大降低。</p><p><strong>最佳应用场景：</strong> 对象存活度较低的时候，新生代</p><p><img src="/2020/10/12/Java%E8%99%9A%E6%8B%9F%E6%9C%BAJVM%E7%AC%94%E8%AE%B0/image-20201011155401200.png" alt="image-20201011155401200" class="fancybox"></p></li><li><p><strong>标记清除法</strong></p><p>最基础的垃圾回收算法，分为两个阶段，<mark>标记和清除</mark>。标记阶段标记出所有需要回收的对象，清除阶段回收所有被标记的对象。</p><p>内存碎片化严重，可能发生大对象找不到可利用空间的问题。</p><p><img src="/2020/10/12/Java%E8%99%9A%E6%8B%9F%E6%9C%BAJVM%E7%AC%94%E8%AE%B0/image-20201011155131800.png" alt="image-20201011155131800" class="fancybox"></p></li><li><p><strong>标记整理法</strong></p><p>标记后将存活对象移向内存的一端，然后清除端边界外的对象。</p><p>防止了内存碎片的产生，整理需耗用一定时间</p><p><img src="/2020/10/12/Java%E8%99%9A%E6%8B%9F%E6%9C%BAJVM%E7%AC%94%E8%AE%B0/image-20201011155936528.png" alt="image-20201011155936528" class="fancybox"></p></li><li><p><strong>标记清除整理</strong>：先标记清除，内存碎片较多时再使用标记整理</p></li><li><p><strong>分代收集法 GC</strong></p><p>根据对象存活的不同生命周期将内存划分为不同的域，一般情况下将 GC 堆划分为<mark>新生代(Young Generation)<mark>和</mark>老生代(Tenured/Old Generation)</mark>。</p><p><strong>新生代</strong>的特点是对象生存时间比较短，存活率低，每次可回收的垃圾对象较多，采用复制算法。</p><p>​<strong>HotSpot实现的复制算法流程：</strong></p><ol><li>当Eden区满的时候会触发第一次Minor gc，把还存活的对象拷贝到Survivor From区中。</li><li>当Eden区再一次触发Minor gc时，会对Eden区和Survivor From区进行垃圾回收,把还存活的对象复制到To区域,并将Eden和From区清空，此时Form和To名称交换。</li><li>有些对象会在From区和To区来回复制，如此交换15次(默认为15次,<code>-XX:MaxTenuringThreshold=15</code>)，最终如果还是存活，就存入老年代。</li></ol><p><strong>老生代</strong>的特点是空间比较大，存活率高，每次可回收的垃圾对象较少，采用标记清除(内存碎片较少)和标记整理算法。</p></li><li><p><strong>总结</strong></p><p>内存效率：复制算法 &gt; 标记清除算法 &gt; 标记整理算法(时间复杂度)<br>内存整齐度：复制算法 = 标记整理算法 &gt; 标记清除算法<br>内存利用率：标记整理算法 = 标记清除算法 &gt; 复制算法</p></li></ul><h2 id="16.%20JMM(Java%20Memory%20Model)"><a class="header-anchor" href="#16.%20JMM(Java%20Memory%20Model)">¶</a> 16. JMM(Java Memory Model)</h2><p>​JMM决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：<mark>线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本。</mark></p><p>​本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。其关系模型图如下图所示：JMM对这八种指令的使用，制定了如下规则：</p><p><img src="/2020/10/12/Java%E8%99%9A%E6%8B%9F%E6%9C%BAJVM%E7%AC%94%E8%AE%B0/image-20201012155842619.png" alt="image-20201012155842619" class="fancybox"></p><blockquote><p>更多内容：<a href="https://blog.csdn.net/TJtulong/article/details/89598598">深入理解java虚拟机（全章节完整）</a></p></blockquote><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.6.0/katex.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;JVM是JRE的一部分，是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;JVM%E6%8E%A2%E7%A9%B6&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#JVM%E6%8E%A2%</summary>
      
    
    
    
    <category term="技术" scheme="http://lampkins.gitee.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Java" scheme="http://lampkins.gitee.io/tags/Java/"/>
    
    <category term="JVM" scheme="http://lampkins.gitee.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Markdown Demo 测试</title>
    <link href="http://lampkins.gitee.io/2020/09/12/Markdown-Demo-%E6%B5%8B%E8%AF%95/"/>
    <id>http://lampkins.gitee.io/2020/09/12/Markdown-Demo-%E6%B5%8B%E8%AF%95/</id>
    <published>2020-09-12T04:14:10.000Z</published>
    <updated>2020-10-14T12:03:37.317Z</updated>
    
    <content type="html"><![CDATA[<p>这是一个段落。<br>这是一个段落。</p><a id="more"></a><h1 id="%E4%B8%80%E7%BA%A7%E6%A0%87%E9%A2%98"><a class="header-anchor" href="#%E4%B8%80%E7%BA%A7%E6%A0%87%E9%A2%98">¶</a> 一级标题</h1><h2 id="%E4%BA%8C%E7%BA%A7%E6%A0%87%E9%A2%98"><a class="header-anchor" href="#%E4%BA%8C%E7%BA%A7%E6%A0%87%E9%A2%98">¶</a> 二级标题</h2><h1 id="%E4%B8%80%E7%BA%A7%E6%A0%87%E9%A2%98-2"><a class="header-anchor" href="#%E4%B8%80%E7%BA%A7%E6%A0%87%E9%A2%98-2">¶</a> 一级标题</h1><h2 id="%E4%BA%8C%E7%BA%A7%E6%A0%87%E9%A2%98-2"><a class="header-anchor" href="#%E4%BA%8C%E7%BA%A7%E6%A0%87%E9%A2%98-2">¶</a> 二级标题</h2><h3 id="%E4%B8%89%E7%BA%A7%E6%A0%87%E9%A2%98"><a class="header-anchor" href="#%E4%B8%89%E7%BA%A7%E6%A0%87%E9%A2%98">¶</a> 三级标题</h3><h4 id="%E5%9B%9B%E7%BA%A7%E6%A0%87%E9%A2%98"><a class="header-anchor" href="#%E5%9B%9B%E7%BA%A7%E6%A0%87%E9%A2%98">¶</a> 四级标题</h4><h5 id="%E4%BA%94%E7%BA%A7%E6%A0%87%E9%A2%98"><a class="header-anchor" href="#%E4%BA%94%E7%BA%A7%E6%A0%87%E9%A2%98">¶</a> 五级标题</h5><h6 id="%E5%85%AD%E7%BA%A7%E6%A0%87%E9%A2%98"><a class="header-anchor" href="#%E5%85%AD%E7%BA%A7%E6%A0%87%E9%A2%98">¶</a> 六级标题</h6><blockquote><p>区块引用</p><blockquote><p>嵌套引用</p></blockquote></blockquote><ul><li>第一项<ul><li>第一项</li><li>第二项</li><li>第三项</li></ul></li><li>第二项<ul><li>第一项</li><li>第二项</li><li>第三项</li></ul></li><li>第三项<ol><li>第一项</li><li>第二项</li><li>第三项</li></ol></li></ul><hr><hr><hr><pre><code>void main()&#123;    printf(&quot;Hello, Markdown.&quot;);&#125;</code></pre><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, Markdown.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">1</th><th style="text-align:center">2</th><th style="text-align:right">3</th></tr></thead><tbody><tr><td style="text-align:left">aaaaa</td><td style="text-align:center">bbbbb</td><td style="text-align:right">ccccc</td></tr><tr><td style="text-align:left"><em>ABC</em></td><td style="text-align:center"><em>123</em></td><td style="text-align:right"><em>abc</em></td></tr></tbody></table><ul><li><input type="checkbox" id="checkbox0"><label for="checkbox0">任务A</label></li><li><input type="checkbox" id="checkbox1" checked="true"><label for="checkbox1">任务B</label><ul><li><input type="checkbox" id="checkbox2" checked="true"><label for="checkbox2">任务1</label></li><li><input type="checkbox" id="checkbox3" checked="true"><label for="checkbox3">任务2</label></li><li><input type="checkbox" id="checkbox4" checked="true"><label for="checkbox4">任务3</label></li></ul></li><li><input type="checkbox" id="checkbox5"><label for="checkbox5">任务C</label></li></ul><dl><dt>Definition</dt><dd>这是一个定义。</dd></dl><p><a href="https://www.baidu.com/">https://www.baidu.com/</a><br><a href="https://www.baidu.com/" title="Baidu">链接</a><br><a href="https://www.baidu.com/" title="Baidu">链接</a><br><img src="https://www.baidu.com/img/bd_logo1.png" alt="图片" title="Baidu" class="fancybox"><br><img src="https://www.baidu.com/img/bd_logo1.png" alt="图片" title="Baidu" class="fancybox center-block"></p><p><img src="https://www.baidu.com/img/bd_logo1.png" class="fancybox center-block"></p><p><a href="#anchor" title="Anchor">锚点</a><br><a href="#anchor" title="Anchor">锚点</a></p><p id="anchor" name="anchor">锚点</p><p>这是一个脚注<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。</p><p>这是一个缩写（<abbr title="Hyper Text Markup Language">HTML</abbr>）。</p><p>H<sup>2</sup>，H<sub>2</sub><br><em>斜体</em>，<em>斜体</em><br><strong>粗体</strong>，<strong>粗体</strong><br><em><strong>粗斜体</strong></em>，<em><strong>粗斜体</strong></em><br><s>删除</s>，<ins>插入</ins>，<mark>标记</mark><br><code>printf(&quot;Hello, Markdown.&quot;);</code></p><p>\，`，*，_，{}，[]，()，#，+，-，.，!</p><p>&amp;，&lt;，©，😄，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mo>=</mo><mi>m</mi><msup><mi>c</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">E=mc^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mrel">=</span><span class="mord mathit">m</span><span class="mord"><span class="mord mathit">c</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mo fence="true">{</mo><mtable><mtr><mtd><mrow><msub><mi>a</mi><mn>1</mn></msub><mi>x</mi><mo>+</mo><msub><mi>b</mi><mn>1</mn></msub><mi>y</mi><mo>+</mo><msub><mi>c</mi><mn>1</mn></msub><mi>z</mi><mo>=</mo><msub><mi>d</mi><mn>1</mn></msub></mrow></mtd></mtr><mtr><mtd><mrow><msub><mi>a</mi><mn>2</mn></msub><mi>x</mi><mo>+</mo><msub><mi>b</mi><mn>2</mn></msub><mi>y</mi><mo>+</mo><msub><mi>c</mi><mn>2</mn></msub><mi>z</mi><mo>=</mo><msub><mi>d</mi><mn>2</mn></msub></mrow></mtd></mtr><mtr><mtd><mrow><msub><mi>a</mi><mn>3</mn></msub><mi>x</mi><mo>+</mo><msub><mi>b</mi><mn>3</mn></msub><mi>y</mi><mo>+</mo><msub><mi>c</mi><mn>3</mn></msub><mi>z</mi><mo>=</mo><msub><mi>d</mi><mn>3</mn></msub></mrow></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\begin{cases}a_1x+b_1y+c_1z=d_1\\a_2x+b_2y+c_2z=d_2\\a_3x+b_3y+c_3z=d_3\end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:2.41em;"></span><span class="strut bottom" style="height:4.32em;vertical-align:-1.9099999999999997em;"></span><span class="base displaystyle textstyle uncramped"><span class="minner displaystyle textstyle uncramped"><span class="style-wrap reset-textstyle textstyle uncramped"><span class="delimsizing mult"><span class="vlist"><span style="top:0.9500099999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:0.9500099999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-0.000010000000000287557em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-1.1500100000000002em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-1.4500200000000003em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist"><span style="top:-1.4020000000000001em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord displaystyle textstyle uncramped"><span class="mord"><span class="mord mathit">a</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathit">x</span><span class="mbin">+</span><span class="mord"><span class="mord mathit">b</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mbin">+</span><span class="mord"><span class="mord mathit">c</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathit" style="margin-right:0.04398em;">z</span><span class="mrel">=</span><span class="mord"><span class="mord mathit">d</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span><span style="top:0.0379999999999997em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord displaystyle textstyle uncramped"><span class="mord"><span class="mord mathit">a</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathit">x</span><span class="mbin">+</span><span class="mord"><span class="mord mathit">b</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mbin">+</span><span class="mord"><span class="mord mathit">c</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathit" style="margin-right:0.04398em;">z</span><span class="mrel">=</span><span class="mord"><span class="mord mathit">d</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span><span style="top:1.4779999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord displaystyle textstyle uncramped"><span class="mord"><span class="mord mathit">a</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">3</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathit">x</span><span class="mbin">+</span><span class="mord"><span class="mord mathit">b</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">3</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mbin">+</span><span class="mord"><span class="mord mathit">c</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">3</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathit" style="margin-right:0.04398em;">z</span><span class="mrel">=</span><span class="mord"><span class="mord mathit">d</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">3</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span></span></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">A -&gt; B: Hello</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><blockquote><p>Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy.</p><footer><strong>David Levithan</strong><cite>Wide Awake</cite></footer></blockquote><blockquote><p>Every interaction is both precious and an opportunity to delight.</p><footer><strong>Seth Godin</strong><cite><a href="http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html">Welcome to Island Marketing</a></cite></footer></blockquote><figure class="highlight javascript"><figcaption><span>_.compact</span><a href="http://underscorejs.org/#compact">Underscore.js</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_.compact([<span class="number">0</span>, <span class="number">1</span>, <span class="literal">false</span>, <span class="number">2</span>, <span class="string">&#x27;&#x27;</span>, <span class="number">3</span>]);</span><br><span class="line">=&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><iframe src="https://www.baidu.com/" width="100%" height="300" frameborder="0" loading="lazy" allowfullscreen></iframe><img src="https://www.baidu.com/img/bd_logo1.png" class="image" width="300" height="150" title="Baidu"><a href="https://www.baidu.com/" title="Baidu" target>Baidu</a><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.6.0/katex.min.css"><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://www.baidu.com/">https://www.baidu.com/</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    
    <summary type="html">&lt;p&gt;这是一个段落。&lt;br&gt;
这是一个段落。&lt;/p&gt;</summary>
    
    
    
    <category term="测试" scheme="http://lampkins.gitee.io/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="markdown" scheme="http://lampkins.gitee.io/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://lampkins.gitee.io/2020/09/12/hello-world/"/>
    <id>http://lampkins.gitee.io/2020/09/12/hello-world/</id>
    <published>2020-09-12T02:14:10.000Z</published>
    <updated>2020-10-13T14:46:27.593Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick%20Start"><a class="header-anchor" href="#Quick%20Start">¶</a> Quick Start</h2><h3 id="Create%20a%20new%20post"><a class="header-anchor" href="#Create%20a%20new%20post">¶</a> Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run%20server"><a class="header-anchor" href="#Run%20server">¶</a> Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate%20static%20files"><a class="header-anchor" href="#Generate%20static%20files">¶</a> Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy%20to%20remote%20sites"><a class="header-anchor" href="#Deploy%20to%20remote%20sites">¶</a> Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.6.0/katex.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    <category term="测试" scheme="http://lampkins.gitee.io/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="hexo" scheme="http://lampkins.gitee.io/tags/hexo/"/>
    
  </entry>
  
</feed>
